This is MemoryPoolSystem.info, produced by makeinfo version 7.1.1 from
MemoryPoolSystem.texi.

     Memory Pool System 1.118.0, Feb 11, 2025

     Ravenbrook Limited

     Copyright © 2025, Ravenbrook Limited

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* MemoryPoolSystem: (MemoryPoolSystem.info). One line description of project.
END-INFO-DIR-ENTRY


   Generated by Sphinx 8.1.3.


File: MemoryPoolSystem.info,  Node: Deferred reference counting,  Next: One-bit reference counting,  Prev: Simple reference counting,  Up: Reference counts

13.3.2.2 Deferred reference counting
....................................

The performance of reference counting can be improved if not all
references are taken into account.  In one important technique, known as
*note deferred reference counting: 165f, only references from other
objects are counted, and references from program variables are ignored.
Since most of the references to the object are likely to be from local
variables, this can substantially reduce the overhead of keeping the
counts up to date.  An object cannot be reclaimed as soon as its count
has dropped to zero, because there might still be a reference to it from
a program variable.  Instead, the program variables (including the *note
control stack: 27.) are periodically *note scanned: 65, and any objects
which are not referenced from there and which have zero count are
reclaimed.

Deferred reference counting cannot normally be used unless it is
directly supported by the compiler.  It’s more common for modern
compilers to support tracing garbage collectors instead, because they
can reclaim loops.  Deferred reference counting may still be useful for
its promptness—but that is limited by the frequency of scanning the
program variables.


File: MemoryPoolSystem.info,  Node: One-bit reference counting,  Next: Weighted reference counting,  Prev: Deferred reference counting,  Up: Reference counts

13.3.2.3 One-bit reference counting
...................................

Another variation on reference counting, known as the *note one-bit
reference count: 16c6, uses a single bit flag to indicate whether each
object has either “one” or “many” references.  If a reference to an
object with “one” reference is removed, then the object can be recycled.
If an object has “many” references, then removing references does not
change this, and that object will never be recycled.  It is possible to
store the flag as part of the 'pointer' to the object, so no additional
space is required in each object to store the count.  One-bit reference
counting is effective in practice because most actual objects have a
reference count of one.


File: MemoryPoolSystem.info,  Node: Weighted reference counting,  Prev: One-bit reference counting,  Up: Reference counts

13.3.2.4 Weighted reference counting
....................................

Reference counting is often used for tracking inter-process references
for *note distributed garbage collection: 1663.  This fails to collect
objects in separate processes if they have looped references, but
tracing collectors are usually too inefficient as inter-process tracing
entails much communication between processes.  Within a process, tracing
collectors are often used for local recycling of memory.

Many distributed collectors use a technique called *note weighted
reference counting: 1666, which reduces the level of communication even
further.  Each time a reference is copied, the weight of the reference
is shared between the new and the old copies.  Since this operation
doesn’t change the total weight of all references, it doesn’t require
any communication with the object.  Communication is only required when
references are deleted.


File: MemoryPoolSystem.info,  Node: Memory management in various languages,  Prev: Recycling techniques,  Up: Introduction to memory management

13.4 Memory management in various languages
===========================================

ALGOL

     ALGOL, designed in 1958 for scientific computing, was the first
     block-structured language.  It spawned a whole family of languages,
     and inspired many more, including *note Scheme: 46, *note Simula:
     17da. and *note Pascal: 17bc.

     The block structure of ALGOL 60 induced a *note stack allocation:
     15e2. discipline.  It had limited dynamic arrays, but no general
     *note heap allocation: 1653.  The substantially redesigned ALGOL 68
     had both heap and stack allocation.  It also had something like the
     modern *note pointer: 15b8. type, and required *note garbage
     collection: f. for the heap.  The new language was complex and
     difficult to implement, and it was never as successful as its
     predecessor.

     *note Branquart & Lewi (1972): 14fd.

BASIC

     BASIC is a simple and easily-learned programming language created
     by T. E. Kurtz and J. G. Kemeny in 1963–4.  The motivation was to
     make computers easily accessible to undergraduate students in all
     disciplines.

     Most BASICs had quite powerful string handling operations that
     required a simple *note garbage collector: 20.  In many
     implementations, the garbage collector could be forced to run by
     running the mysterious expression ‘FRE("")’.

     BASIC is now old-fashioned, but survives as a scripting language,
     in particular in Visual BASIC, which is an application development
     environment with a BASIC-like scripting language.  These
     descendants invariably have automatic memory management as well.

C

     C is a systems programming language sometimes described as “a
     portable assembler” because it was intended to be sufficiently
     low-level to allow performance comparable to assembler or machine
     code, but sufficiently high-level to allow programs to be reused on
     other platforms with little or no modification.

     *note Memory management: 15dd. is typically manual (the standard
     library functions for *note memory (2): 194. management in C, *note
     malloc: 1a. and *note free (2): 1b, have become almost synonymous
     with *note manual memory management: 8.), although with the Memory
     Pool System, or the Boehm–Demers–Weiser collector, it is now
     possible to use *note garbage collection: f.

     The language is notorious for fostering memory management bugs,
     including:

       1. Accessing arrays with indexes that are out of bounds;

       2. Using *note stack-allocated: 15e2. structures beyond their
          *note lifetimes: b5. (see *note use after free: 174f.);

       3. Using *note heap-allocated: 1653. structures after *note
          freeing: 15d2. them (see *note use after free: 174f.);

       4. Neglecting to free heap-allocated objects when they are no
          longer required (see *note memory leak: 234.);

       5. Failing to allocate memory for a *note pointer: 15b8. before
          using it;

       6. Allocating insufficient memory for the intended contents;

       7. Loading from allocated memory before storing into it;

       8. Dereferencing non-pointers as if they were pointers.

     See also
     ........

     *note automatic storage duration: 15d0, *note static storage
     duration: 15e3.

     *note ISO/IEC 9899;1990: 118, *note ISO/IEC 9899;1999: 9d6, *note
     Boehm & Weiser (1988): 14f6, *note Daconta (1993): 150c, *note Zorn
     (1993): 1513.

     Memory Pool System(1), Boehm–Demers–Weiser collector(2), C
     standardization(3), comp.lang.c Frequently Asked Questions(4).

COBOL

     COBOL was designed by the CODASYL committee in 1959–60 to be a
     business programming language, and has been extended many times
     since.  A 1997 Gartner Group report estimated that 80% of computer
     software (by count of source lines) was written in COBOL.

     Prior to 2002, COBOL had no *note heap allocation: 1653, and did
     well in its application domain without it.  COBOL 2002 has *note
     pointers: 15b8. and heap allocation through ‘ALLOCATE’ and ‘FREE’,
     mainly in order to be able to use C-style interfaces.  It also
     supports a high level of abstraction through object-oriented
     programming and *note garbage collection: f. (including *note
     finalization: b.).

     COBOL standardization(5).

Common Lisp

     Common Lisp is the major dialect of the *note Lisp: 28a. family.
     In addition to the usual Lisp features, it has an advanced object
     system, data types from hash tables to complex numbers, and a rich
     standard library.

     Common Lisp is a *note garbage-collected: f. language, and modern
     implementations, such as LispWorks(6) and Allegro CL(7), include
     advanced features, such as *note finalization: b. and *note
     weakness: c.

     Common Lisp HyperSpec(8).

C#

     C# is a strongly typed object-oriented language created at
     Microsoft in 1999–2000.  It is designed to run on the Common
     Language Runtime, the virtual machine from the .NET Framework.  It
     also runs on the open source Mono runtime.

     Memory is *note automatically managed: 9.: memory is allocated when
     an object is created, and reclaimed at some point after the object
     becomes *note unreachable: 21.

     The language supports *note finalization: b. (classes may have
     'destructor functions', which are run just before the object is
     reclaimed by the memory manager), and *note weak references (1): c.
     (via the ‘WeakReference’ class).

     The *note garbage collector: 20. in the .NET Framework is
     configurable to run in soft real time, or in batch mode.

     The Mono runtime comes with two collectors: the Boehm–Demers–Weiser
     *note conservative collector: 349, and a *note generational: e.
     *note copying collector: e3.

     Automatic memory management in C#(9), WeakReference Class(10),
     Memory Management and Garbage Collection in the .NET Framework(11),
     Mono project(12).

C++

     C++ is a (weakly) object-oriented language, extending the systems
     programming language *note C: 1c. with a multiple-inheritance class
     mechanism and simple method dispatch.

     The standard library functions for *note memory (2): 194.
     management in C++ are ‘new’ and ‘delete’.  The higher abstraction
     level of C++ makes the bookkeeping required for *note manual memory
     management: 8. even harder.  Although the standard library provides
     only manual memory management, with the Memory Pool System, or the
     Boehm–Demers–Weiser collector, it is now possible to use *note
     garbage collection: f.  *note Smart pointers: 1711. are another
     popular solution.

     The language is notorious for fostering memory management bugs,
     including:

       1. Using *note stack-allocated: 15e2. structures beyond their
          *note lifetimes: b5. (see *note use after free: 174f.);

       2. Using *note heap-allocated: 1653. structures after *note
          freeing: 15d2. them (see *note use after free: 174f.);

       3. Neglecting to free heap-allocated objects when they are no
          longer required (see *note memory leak: 234.);

       4. Excessive copying by copy *note constructors (1): 15d3.;

       5. Unexpected sharing due to insufficient copying by copy
          constructors;

       6. Allocating insufficient memory for the intended contents;

       7. Accessing arrays with indexes that are out of bounds.

     C++ was designed by Bjarne Stroustrup, as a minimal object-oriented
     extension to C. It has since grown to include some other modern
     programming language ideas.  The first implementations were
     preprocessors that produced C code, but modern implementations are
     dedicated C++ compilers.

     Ellis and Stroustrup write in 'The Annotated C++ Reference Manual':

          C programmers think memory management is too important to be
          left to the computer.  Lisp programmers think memory
          management is too important to be left to the user.

     See also
     ........

     *note constructor (2): 1651, *note destructor (2): 1652.

     *note Attardi & Flagella (1994): 14dd, *note Bartlett (1989): 14f2,
     *note Boehm & Weiser (1988): 14f6, *note Edelson (1992): 151d,
     *note Ellis (1993): 151f, *note Zorn (1993): 1513.

     Memory Pool System(13), Boehm–Demers–Weiser collector(14),
     comp.lang.c++ FAQ(15), C++ standardization(16).

Dylan

     Dylan is a modern programming language invented by Apple around
     1993 and developed by Harlequin(17) and other partners.  The
     language is a distillation of the best ideas in dynamic and
     object-oriented programming.  Its ancestors include *note Lisp:
     28a, *note Smalltalk: 1661, and *note C++: 1d.  Dylan is aimed at
     building modular component software and delivering safe, compact
     applications.  It also facilitates the rapid development and
     incremental refinement of prototype programs.

     Dylan provides *note automatic memory management: 9.  The generic
     allocation function is called ‘make’.  Most implementations provide
     *note finalization: b. and *note weak: c. hash tables, although
     interfaces for these features have not yet been standardized.  An
     object may be registered for finalization via the function
     ‘finalize-when-unreachable’, in which case there will be a call to
     the ‘finalize’ function once the *note garbage collector: 20. has
     determined that the object is *note unreachable: 21.  Weak hash
     tables may have either weak keys or values, depending on a
     parameter supplied at allocation time.  A hash table entry will be
     deleted once the garbage collector has determined that there are no
     *note strong references: 244. to the key or value of the entry, for
     weak key or value tables, respectively.

     Open Dylan(18).

Emacs Lisp

     Emacs Lisp or elisp is a dialect of *note Lisp: 28a. used in the
     Emacs family of text editors, of which the most widely-used is GNU
     Emacs(19).

     Like most Lisps, Emacs Lisp requires *note garbage collection: f.
     GNU Emacs has a simple *note mark-sweep: 15fd. collector.  It has
     been speculated that the non-*note incremental: d. nature of the
     Emacs collector, combined with the fact that, prior to version
     19.31 (May 1996), it printed a message whenever it collected, gave
     garbage collection a bad name in programming circles.

     Erik Naggum reported at the time:

          I have run some tests at the U of Oslo with about 100 users
          who generally agreed that Emacs had become faster in the
          latest Emacs pretest.  All I had done was to remove the
          “Garbage collecting” message which people perceive as slowing
          Emacs down and tell them that it had been sped up.  It is,
          somehow, permissible for a program to take a lot of time doing
          any other task than administrative duties like garbage
          collection.

     Emacs was originally written in Teco, not in Lisp, but it still had
     a garbage collector, though this was heuristic and conservative in
     nature.  Teco-based Emacs was capable of running for weeks at a
     time in a 256 kB *note address space: 54.

     GNU Emacs Lisp Reference Manual(20), Entry on Garbage
     Collection(21).

Fortran

     Fortran, created in 1957, was one of the first languages qualifying
     as a high-level language.  It is popular among scientists and has
     substantial support in the form of numerical libraries.

     Early versions of Fortran required the size of arrays to be known
     at compilation time, and the earliest Fortran compilers accordingly
     used only *note static allocation: 1610. (however, the 1966
     standard gave compiler writers freedom to use other allocation
     mechanisms).

     The Fortran 90 standard added recursion and automatic arrays with
     *note stack allocation: 15e2. semantics (though many compilers in
     fact allocate them on the *note heap: 47.).  It also added *note
     dynamic allocation: 166b. using ‘ALLOCATE’ with manual deallocation
     using ‘DEALLOCATE’.  Fortran 95 made it explicit that allocated
     arrays have *note dynamic extent: 24a. and are automatically
     deallocated when they go out of scope.

     Fortran standardization(22).

Java

     A modern object-oriented language with a rich collection of useful
     features.  The Java language started as an attempt by the Java
     group at Sun Microsystems to overcome software engineering problems
     introduced by *note C++: 1d.  Key reasons for the language’s
     success were the security model and the portable execution
     environment, the Java Virtual Machine (JVM), which created a lot of
     interest for it as a platform for distributed computing on open
     networks.

     Java is *note garbage-collected: f, as this facilitates
     object-oriented programming and is essential for security (which
     *note use after free: 174f. would break).  It had *note
     finalization: b. from version 1.0 and three kinds of *note
     weakness: c. from version 1.2 (confusingly, part of the Java 2
     Platform).

     Early JVMs had simple collectors that didn’t scale well for large
     programs, but the current crop is catching up to the state of the
     art.

     See also
     ........

     *note reference object: 16fb, *note strong reference: 244, *note
     soft reference: 1712, *note weak reference (2): 1713, *note phantom
     reference: 16fa, *note strongly reachable: 16f7, *note softly
     reachable: 16f8, *note weakly reachable: 16f9, *note phantom
     reachable: 16f5.

JavaScript

     JavaScript is a scripting language used by web browsers.  The loose
     type system resembles other scripting languages, although the
     syntax follows *note C: 1c.  There’s a prototype-based object
     system.  Note that JavaScript is not related to *note Java: 167f.
     in any way except name.  There’s a standard by ECMA(23), known as
     ECMAScript.

     Despite the *note C++: 1d.-like syntax (with ‘new’ and ‘delete’
     operators), JavaScript is *note garbage-collected: f.

     Standard ECMA-262: ECMAScript Language Specification(24).

Lisp

     Lisp is a family of computer languages combining functional and
     procedural features with automatic memory management.

     Lisp was invented by John McCarthy around 1958 for the manipulation
     of symbolic expressions.  As part of the original implementation of
     Lisp, he invented *note garbage collection: f.  He noted:

          This process, because it is entirely automatic, is more
          convenient for the programmer than a system in which he has to
          keep track of lists and erase unwanted lists.

     Modern Lisp implementations, such as LispWorks(25) and Allegro
     CL(26), have advanced *note garbage collectors: 20.

     Lisp is now used for all kinds of symbolic programming and other
     advanced software development.  Major dialects today are *note
     Emacs Lisp: 17dd, *note Common Lisp: 17db. and *note Scheme: 46.
     Most modern dialects and related languages, such as *note Dylan:
     1752, are object-oriented.

     See also
     ........

     *note cons (1): 15cf.

     *note Baker (1978): 14e1, *note Edwards: 151e, *note McCarthy &
     Minsky (1959): 1540, *note McCarthy (1960): 1541, *note McCarthy
     (1979): 28b, *note Moon (1984): 1544, *note Moon (1990): 1546,
     *note Moon (1991): 1547, *note Sobalvarro (1988): 1569, *note Zorn
     (1988): 1585.

     Common Lisp HyperSpec(27).

Lisp Machine

     Of particular interest in the history of memory management are the
     'Lisp Machines', early workstation computers built around a custom
     processor designed to improve the execution speed of Lisp by
     implementing primitive Lisp operations in microcode.  The Lisp
     Machine *note garbage collector: 20. is a generalization of the
     algorithm described in *note Baker (1978): 14e1. and used a
     technique similar to that described in *note Ungar (1984): 1573,
     but utilizing hardware to improve performance.

     A description of the garbage collector of one particular model is
     in *note Moon (1984): 1544.  The features important for its
     performance were:

       1. Hardware support for data typing using *note tags: 88.;

       2. Reference-based *note read barriers: 1d6. for *note
          incremental: d. collecting;

       3. *note Write barriers: 214. for *note remembered sets: 213. and
          *note generational: e. collecting;

       4. A tight integration with the *note virtual memory: 51. system.

     The remembered sets were based on a *note BIBOP: 15f6. division of
     the virtual *note address space: 54.  The Lisp Machine *note page
     table: 16a2, unlike virtually all modern virtual memory systems,
     was a flat, hash-based table (sometimes called an *note inverted
     page table: 16b6.), and thus insensitive to sparsely-populated
     virtual address spaces associated with BIBOP schemes.

     These custom processors eventually lost out to rapidly advancing
     stock hardware.  Many of the techniques pioneered on Lisp Machines
     are used in today’s implementations, at a cost of a few more
     cycles.

     Lisp Machine Manual, 6th edition(28), The Garbage Collector(29).

Lua

     Lua is a dynamically typed language created by Roberto
     Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes in
     1993.  The language supports object-oriented and functional styles
     of programming, and is designed to be easily embedded in a larger
     programming system as an extension or scripting language.

     Lua uses *note automatic memory management: 9. and comes with a
     *note non-moving: 5e. *note incremental: d. *note garbage
     collector: 20. supporting soft real time applications.  This uses a
     software *note barrier (1): 60. in order to be highly portable.

     The language supports *note weak references (1): c. in the form of
     weak (hash) tables, which have the unusual feature that their keys
     and values can be dynamically switched from being *note strong
     references: 244. to weak references, and vice versa (by assigning
     to the ‘__mode’ field of the table’s metatable).  It also supports
     *note finalization: b. (by assigning the ‘__gc’ field of the
     object’s metatable).

     Lua(30), Garbage Collection(31).

ML

     ML is a family of strongly-typed functional languages, of which the
     principal members are Standard ML and Caml.

     Like other functional languages, ML provides *note automatic memory
     management: 9.  Modern ML implementations usually have advanced
     *note garbage collectors: 20.  The combination of clean functional
     semantics and strong typing allows advanced techniques, such as
     *note region inference: 15e1.

     The Standard ML of New Jersey (SML/NJ) system, which implements a
     slight variant of Standard ML, has been important to memory
     management research for three reasons.  Firstly, the source code is
     publicly available and widely ported, allowing experimentation with
     both the *note collector (2): 15ae. and *note mutator: 30c.
     Secondly, the compiler generates code that does not use a *note
     control stack: 27, but *note allocates: 15ca. function *note
     activation records: 15ac. on the *note heap: 47. instead.  This
     means that the allocation rate is very high (up to one byte per
     instruction), and also that the collector has a very small *note
     root set: 1716.  Thirdly, it uses a simple *note copying collector:
     e3. that is easy to modify.

     See also
     ........

     *note immutable: 16a7.

     *note Cooper et al.  (1992): 150b, *note Doligez (1993): 1519,
     *note Tofte & Talpin (1997): 1572.

     comp.lang.ml FAQ(32).

Modula-3

     An object-oriented descendant of *note Pascal: 17bc.

     Modula-3 is mostly *note garbage-collected: f, although it is
     possible to use *note manual memory management: 8. in certain
     modules.

     modula3.org(33), Modula-3 language definition(34).

Pascal

     An imperative language characterized by block structure and a
     relatively strong (for its time) static type system.  Pascal was
     designed by Niklaus Wirth around 1970.

     Pascal was popular as a teaching language due to its small size,
     but it lacked many features needed for applications programming.
     Now it’s been largely supplanted by its more feature-rich
     descendants Modula-2, *note Modula-3: 168f, and Oberon, mainly
     surviving in the popular Delphi development tool.

     Pascal uses *note manual memory management: 8. (with the operators
     ‘NEW’ and ‘DISPOSE’).  The descendants mentioned all offer *note
     automatic memory management: 9.

     Embarcadero (formely Borland) Delphi(35), Pascal
     standardization(36).

Perl

     Perl is a complex but powerful language that is an eclectic mixture
     of scripting languages and programming languages.

     Perl programmers can work with strings, arrays, and associative
     arrays without having to worry about *note manual memory
     management: 8.  Perl is well-suited to complex text file
     manipulation, such as report generation, file format conversion,
     and web server CGI scripts.  It is also useful for rapid
     prototyping, but large Perl scripts are often unmaintainable.

     Perl’s *note memory management: 15dd. is well-hidden, but is based
     on *note reference counts: 15e0. and *note garbage collection: f.
     It also has 'mortal' variables, whose *note lifetimes: b5. are
     limited to the current context.  It is possible to *note free (1):
     15d2. the *note memory (2): 194. assigned to variables (including
     arrays) explicitly, by ‘undef’-ing the only reference to them.

     The Perl Programming Language(37).

PostScript

     The PostScript language is an interpretive language with powerful
     graphics features, widely used as a page description language for
     printers and typesetters.

     The Level 1 PostScript language has a simple *note stack:
     15bc.-like memory management model, using ‘save’ and ‘restore’
     operators to *note recycle: 15de. memory.  The Level 2 PostScript
     language adds *note garbage collection: f. to this model.

     See also
     ........

     *note VM (2): 1647, *note composite object: 1644, *note simple
     object: 1646.

     Harlequin RIP(38).

Prolog

     A logic programming language invented by Alain Colmerauer around
     1970, Prolog is popular in the AI and symbolic computation
     community.  It is special because it deals directly with
     relationships and inference rather than functions or commands.

     Storage is usually managed using a *note garbage collector: 20, but
     the complex control flow places special requirements on the
     collector.

     Prolog Standardization(39), Prolog Memory Management - Garbage
     Collection(40).

Python

     Python is a “duck-typed” object-oriented language created in the
     early 1990s by Guido van Rossum.

     There are several implementations running on a variety of virtual
     machines: the original “CPython” implementation runs on its own
     virtual machine; IronPython runs on the Common Language Runtime;
     Jython on the Java Virtual Machine.

     CPython manages memory using a mixture of *note reference counting:
     15e0. and *note non-moving: 1e7. *note mark-and-sweep: 16d3. *note
     garbage collection: f.  Reference counting ensures prompt deletion
     of objects when their reference count falls to zero, while the
     garbage collector reclaims *note cyclic data structures: 1659.

     The language supports *note finalization: b. (classes may have a
     ‘__del__’ method, which is run just before the object is
     destroyed), and *note weak references (1): c. (via the ‘weakref’
     module).

     Python(41), Garbage Collector interface(42), __del__ method(43),
     weakref module(44).

Scheme

     A small functional language blending influences from *note Lisp:
     28a. and *note Algol: 1637.

     Key features of Scheme include symbol and list operations, *note
     heap allocation: 1653. and *note garbage collection: f, lexical
     scoping with first-class function objects (implying *note closures:
     1ee.), reliable tail-call elimination (allowing iterative
     procedures to be described tail-recursively), the ability to
     dynamically obtain the current *note continuation: 15ad. as a
     first-class object, and a language description that includes a
     formal semantics.

     Scheme has been gaining popularity as an extension language;
     Project GNU’s extension package of choice, Guile(45), is a Scheme
     interpreter.  *note Garbage collection: f. is an important part of
     the ease of use that is expected from an extension language.

     Scheme Standards documents(46), Scheme Requests for
     Implementation(47).

Simula

     Simula was designed as a language for simulation, but it expanded
     into a full general-purpose programming language and the first
     object-oriented language.

     Simula I, designed in 1962–64 by Kristen Nygaard and Ole-Johan
     Dahl, was based on *note ALGOL: 1637. 60, but the *note stack
     allocation: 15e2. discipline was replaced by a two-dimensional
     *note free list: 268.

     It was Simula 67 that pioneered classes and inheritance to express
     behavior.  This domain-oriented design was supported by *note
     garbage collection: f.

     *note Dahl (1963): 150e.

Smalltalk

     Smalltalk is an object-oriented language with single inheritance
     and message-passing.

     *note Automatic memory management: 9. is an essential part of the
     Smalltalk philosophy.  Many important techniques were first
     developed or implemented for Smalltalk.

     *note Deutsch & Bobrow (1976): 1514, *note Ungar (1984): 1573,
     *note Ungar (1988): 1574.

     Smalltalk standardization(48).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/

   (2) http://hboehm.info/gc/

   (3) http://www.open-std.org/jtc1/sc22/wg14/

   (4) http://c-faq.com/

   (5) http://www.cobolstandard.info/wg4/wg4.html

   (6) http://www.lispworks.com/

   (7) http://www.franz.com/products/allegro-common-lisp/

   (8) http://www.lispworks.com/documentation/HyperSpec/Front/

   (9) http://msdn.microsoft.com/en-us/library/aa691138.aspx

   (10) 
http://msdn.microsoft.com/en-us/library/system.weakreference.aspx

   (11) http://msdn.microsoft.com/en-us/library/hh156531.aspx

   (12) http://www.mono-project.com/Main_Page

   (13) https://www.ravenbrook.com/project/mps/

   (14) http://hboehm.info/gc/

   (15) http://www.parashift.com/c++-faq/

   (16) http://www.open-std.org/jtc1/sc22/wg21/

   (17) https://en.wikipedia.org/wiki/Harlequin_(software_company)

   (18) http://opendylan.org/

   (19) http://www.gnu.org/software/emacs/emacs.html

   (20) http://www.gnu.org/software/emacs/manual/elisp.html

   (21) 
http://www.gnu.org/software/emacs/manual/html_node/elisp/Garbage-Collection.html

   (22) http://www.j3-fortran.org/

   (23) http://www.ecma-international.org

   (24) 
http://www.ecma-international.org/publications/standards/Ecma-262.htm

   (25) http://www.lispworks.com/

   (26) http://www.franz.com/products/allegro-common-lisp/

   (27) http://www.lispworks.com/documentation/HyperSpec/Front/

   (28) http://common-lisp.net/project/bknr/static/lmman/frontpage.html

   (29) 
http://common-lisp.net/project/bknr/static/lmman/fd-hac.xml#The%20Garbage%20Collector-section

   (30) http://lua.org

   (31) http://www.lua.org/manual/5.1/manual.html#2.10

   (32) http://www.faqs.org/faqs/meta-lang-faq/

   (33) http://www.modula3.org/

   (34) http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-52.pdf

   (35) https://www.embarcadero.com/products/delphi

   (36) http://www.open-std.org/JTC1/sc22/docs/oldwgs/wg2.html

   (37) http://www.perl.org/

   (38) https://en.wikipedia.org/wiki/Harlequin_RIP

   (39) http://people.sju.edu/~jhodgson/wg17/

   (40) http://www.informatik.uni-trier.de/%7Eley/db/prolog/gc.html

   (41) http://python.org/

   (42) http://docs.python.org/3/library/gc.html

   (43) http://docs.python.org/3/reference/datamodel.html#object.__del__

   (44) http://docs.python.org/3/library/weakref.html

   (45) http://www.gnu.org/software/guile/

   (46) http://www.cs.indiana.edu/scheme-repository/doc.standards.html

   (47) http://srfi.schemers.org/

   (48) http://www.smalltalk.org/versions/ANSIStandardSmalltalk.html


File: MemoryPoolSystem.info,  Node: Home,  Next: Frequently Asked Questions,  Prev: Introduction to memory management,  Up: Top

14 Home
*******

Welcome to the 'Memory Management Reference'!  This is a resource for
programmers and computer scientists interested in *note memory
management: 15dd. and *note garbage collection: f.

     Memory Management Glossary: A glossary of more than 500 *note
     memory management: 15dd. terms, from *note absolute address: 15a9.
     to *note zero count table: 1660.

 [image src="MemoryPoolSystem-figures/treadmill.svg" ]


     Introduction to memory management: Articles giving a beginner’s
     overview of *note memory management: 15dd.

 [image src="MemoryPoolSystem-figures/address.svg" ]


     Bibliography: Books and research papers related to *note memory
     management: 15dd.

 [image src="MemoryPoolSystem-figures/copying.svg" ]


     Frequently Asked Questions: Frequently asked questions about *note
     memory management: 15dd.

 [image src="MemoryPoolSystem-figures/snap-out.svg" ]


The Memory Management Reference is maintained by Ravenbrook Limited(1).
We also maintain the Memory Pool System(2) (an open-source, thread-safe,
*note incremental garbage collector: d.), and we are happy to provide
advanced *note memory management: 15dd. solutions to language and
application developers through our consulting service(3).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/

   (2) https://www.ravenbrook.com/project/mps/

   (3) https://www.ravenbrook.com/services/mm/


File: MemoryPoolSystem.info,  Node: Frequently Asked Questions,  Next: Copyright,  Prev: Home,  Up: Top

15 Frequently Asked Questions
*****************************

This is a list of questions that represent the problems people often
have with memory management.  Some answers appear below, with links to
helpful supporting material, such as the *note Memory Management
Glossary: 158e, the *note Bibliography: 14d7, and external sites.  For a
full explanation of any terms used, see the glossary.

* Menu:

* C-specific questions::
* C++-specific questions::
* Common objections to garbage collection::
* Miscellaneous::


File: MemoryPoolSystem.info,  Node: C-specific questions,  Next: C++-specific questions,  Up: Frequently Asked Questions

15.1 C-specific questions
=========================

* Menu:

* Can I use garbage collection in C?::
* Why do I need to test the return value from malloc? Surely it always succeeds?::
* What’s the point of having a garbage collector? Why not use malloc and free?::
* What’s wrong with ANSI malloc in the C library?::


File: MemoryPoolSystem.info,  Node: Can I use garbage collection in C?,  Next: Why do I need to test the return value from malloc? Surely it always succeeds?,  Up: C-specific questions

15.1.1 Can I use garbage collection in C?
-----------------------------------------

Yes.  Various *note conservative garbage collectors: 349. for *note C:
1c. exist as add-on libraries.

Memory Pool System(1), Boehm–Demers–Weiser collector(2).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/

   (2) http://hboehm.info/gc/


File: MemoryPoolSystem.info,  Node: Why do I need to test the return value from malloc? Surely it always succeeds?,  Next: What’s the point of having a garbage collector? Why not use malloc and free?,  Prev: Can I use garbage collection in C?,  Up: C-specific questions

15.1.2 Why do I need to test the return value from malloc? Surely it always succeeds?
-------------------------------------------------------------------------------------

For small programs, and during light testing, it is true that *note
malloc: 1a. usually succeeds.  Unfortunately, there are all sorts of
unpredictable reasons why *note malloc: 1a. might fail one day; for
example:

   * someone uses your program for a far larger data set than you
     anticipated;

   * your program is running on a machine with less memory than you
     expected;

   * the machine your program is running on is heavily loaded.

In this case, *note malloc: 1a. will return ‘NULL’, and your program
will attempt to store data by resolving the null pointer.  This might
cause your program to exit immediately with a helpful message, but it is
more likely to provoke mysterious problems later on.

If you want your code to be robust, and to stand the test of time, you
must check all error or status codes that may be returned by functions
you call, especially those in other libraries, such as the C run-time
library.

If you really don’t want to check the return value from *note malloc:
1a, and you don’t want your program to behave mysteriously when out of
memory, wrap *note malloc: 1a. in something like this:

     #include <stdio.h>
     #include <stdlib.h>

     void *my_malloc(size_t size)
     {
         void *p = malloc(size);

         if (p == NULL) {
             fputs("Out of memory.\n", stderr);
             exit(EXIT_FAILURE);
         }

         return p;
     }

Undefined behavior is worth eliminating even in small programs.


File: MemoryPoolSystem.info,  Node: What’s the point of having a garbage collector? Why not use malloc and free?,  Next: What’s wrong with ANSI malloc in the C library?,  Prev: Why do I need to test the return value from malloc? Surely it always succeeds?,  Up: C-specific questions

15.1.3 What’s the point of having a garbage collector? Why not use malloc and free?
-----------------------------------------------------------------------------------

*note Manual memory management: 8, such as *note malloc: 1a. and *note
free (2): 1b, forces the programmer to keep track of which memory is
still required, and who is responsible for freeing it.  This works for
small programs without internal interfaces, but becomes a rich source of
bugs in larger programs, and is a serious problem for interface
abstraction.

*note Automatic memory management: 9. frees the programmer from these
concerns, making it easier for him to code in the language of his
problem, rather than the tedious details of the implementation.

See also
........

*note garbage collection: f.


File: MemoryPoolSystem.info,  Node: What’s wrong with ANSI malloc in the C library?,  Prev: What’s the point of having a garbage collector? Why not use malloc and free?,  Up: C-specific questions

15.1.4 What’s wrong with ANSI malloc in the C library?
------------------------------------------------------

The *note malloc: 1a. function provides a very basic *note manual memory
management: 8. service.  However, it does not provide the following
things, which may be desirable in your memory manager:

   * high performance for specified block sizes;

   * *note tagged references: 7d.;

   * simultaneous frees;

   * *note locality of reference: 1601. hints;

   * *note formatted objects: 23.;

   * garbage collection;

   * deallocation of partial blocks;

   * multi-threading without synchronization;

   * inlined allocation code;

   * *note finalization: b.

Many of these can be added on top of *note malloc: 1a, but not with full
performance.


File: MemoryPoolSystem.info,  Node: C++-specific questions,  Next: Common objections to garbage collection,  Prev: C-specific questions,  Up: Frequently Asked Questions

15.2 C++-specific questions
===========================

* Menu:

* Can I use garbage collection in C++?::
* Why is delete so slow?::
* What happens if you use class libraries that leak memory?::
* Can’t I get all the benefits of garbage collection using C++ constructors and destructors?::


File: MemoryPoolSystem.info,  Node: Can I use garbage collection in C++?,  Next: Why is delete so slow?,  Up: C++-specific questions

15.2.1 Can I use garbage collection in C++?
-------------------------------------------

Yes.  The C++ specification has always permitted garbage collection.
Bjarne Stroustrup (C++’s designer) has proposed that this be made
explicit in the standard.  There exist various conservative and
semi-conservative garbage collectors for C++.

See also
........

*note C++: 1d, *note conservative garbage collection: 349, *note
semi-conservative garbage collection: 348.

Memory Pool System(1), Boehm–Demers–Weiser collector(2).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/

   (2) http://hboehm.info/gc/


File: MemoryPoolSystem.info,  Node: Why is delete so slow?,  Next: What happens if you use class libraries that leak memory?,  Prev: Can I use garbage collection in C++?,  Up: C++-specific questions

15.2.2 Why is delete so slow?
-----------------------------

Often ‘delete’ must perform a more complex task than simply freeing the
memory associated with an object; this is known as *note finalization:
b.  Finalization typically involves releasing any resources indirectly
associated with the object, such as files that must be closed or
ancillary objects that must be finalized themselves.  This may involve
traversing memory that has been unused for some time and hence is *note
paged out: 16d1.

With *note manual memory management: 8. (such as ‘new’ and ‘delete’), it
is perfectly possible for the *note deallocation: 15d2. operation to
vary in complexity.  Some systems do quite a lot of processing on freed
blocks to *note coalesce: 38c. adjacent blocks, sort free blocks by size
(in a *note buddy system: 15f9, say), or sort the *note free list: 268.
by address.  In the last case, deallocating blocks in address order (or
sometimes reverse address order) can result in poor performance.


File: MemoryPoolSystem.info,  Node: What happens if you use class libraries that leak memory?,  Next: Can’t I get all the benefits of garbage collection using C++ constructors and destructors?,  Prev: Why is delete so slow?,  Up: C++-specific questions

15.2.3 What happens if you use class libraries that leak memory?
----------------------------------------------------------------

In *note C++: 1d, it may be that class libraries expect you to call
‘delete’ on objects they create, to invoke the *note destructor (2):
1652.  Check the interface documentation.

Failing this, if there is a genuine *note memory leak: 234. in a class
library for which you don’t have the source, then the only thing you can
try is to add a *note garbage collector: 20.

Memory Pool System(1), Boehm–Demers–Weiser collector(2).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/

   (2) http://hboehm.info/gc/


File: MemoryPoolSystem.info,  Node: Can’t I get all the benefits of garbage collection using C++ constructors and destructors?,  Prev: What happens if you use class libraries that leak memory?,  Up: C++-specific questions

15.2.4 Can’t I get all the benefits of garbage collection using C++ constructors and destructors?
-------------------------------------------------------------------------------------------------

Carefully designed *note C++: 1d. *note constructors (2): 1651. and
*note destructors (2): 1652. can go a long way towards easing the pain
of *note manual memory management: 8.  Objects can know how to
deallocate all their associated resources, including dependent objects
(by recursive destruction).  This means that clients of a class library
do not need to worry about how to free resources allocated on their
behalf.

Unfortunately, they still need to worry about 'when' to free such
resources.  Unless all objects are allocated for precisely one purpose,
and referred to from just one place (or from within one compound data
structure that will be destroyed atomically), then a piece of code that
has finished with an object cannot determine that it is safe to call the
destructor; it cannot be certain (especially when working with other
people’s code) that there is not another piece of code that will try to
use the object subsequently.

This is where garbage collection has the advantage, because it can
determine when a given object is no longer of interest to anyone (or at
least when there are no more references to it).  This neatly avoids the
problems of having multiple copies of the same data or complex
conditional destruction.  The program can construct objects and store
references to them anywhere it finds convenient; the garbage collector
will deal with all the problems of data sharing.


File: MemoryPoolSystem.info,  Node: Common objections to garbage collection,  Next: Miscellaneous,  Prev: C++-specific questions,  Up: Frequently Asked Questions

15.3 Common objections to garbage collection
============================================

* Menu:

* What languages use garbage collection?::
* What’s the advantage of garbage collection?::
* Programs with GC are huge and bloated; GC isn’t suitable for small programs or systems::
* I can’t use GC because I can’t afford to have my program pause::
* Isn’t it much cheaper to use reference counts rather than garbage collection?::
* Isn’t GC unreliable? I’ve heard that GCs often kill the program::
* I’ve heard that GC uses twice as much memory::
* Doesn’t garbage collection make programs slow?::
* Manual memory management gives me control—it doesn’t pause::


File: MemoryPoolSystem.info,  Node: What languages use garbage collection?,  Next: What’s the advantage of garbage collection?,  Up: Common objections to garbage collection

15.3.1 What languages use garbage collection?
---------------------------------------------

*note Java: 167f, *note C#: 17dc, *note Python: 17df, *note Lisp: 28a,
*note ML: 168e, … the list goes on.  It surprises many to learn that
many implementations of *note BASIC: 17c0. use *note garbage collection:
f. to manage character strings efficiently.

*note C++: 1d. is sometimes characterized as the last holdout against
garbage collection, but this is not accurate.  See *note Can I use
garbage collection in C++?: 17ed.

The notion of *note automatic memory management: 9. has stood the test
of time and is becoming a standard part of modern programming
environments.  Some will say “the right tool for the right job”,
rejecting automatic memory management in some cases; few today are bold
enough to suggest that there is never a place for garbage collection
among tools of the modern programmer—either as part of a language or as
an add-on component.


File: MemoryPoolSystem.info,  Node: What’s the advantage of garbage collection?,  Next: Programs with GC are huge and bloated; GC isn’t suitable for small programs or systems,  Prev: What languages use garbage collection?,  Up: Common objections to garbage collection

15.3.2 What’s the advantage of garbage collection?
--------------------------------------------------

*note Garbage collection: f. frees you from having to keep track of
which part of your program is responsible for the deallocation of which
memory.  This freedom from tedious and error-prone bookkeeping allows
you to concentrate on the problem you are trying to solve, without
introducing additional problems of implementation.

This is particularly important in large-scale or highly modular
programs, especially libraries, because the problems of manual memory
management often dominate interface complexity.  Additionally, garbage
collection can reduce the amount of memory used because the interface
problems of manual memory management are often solved by creating extra
copies of data.

In terms of performance, garbage collection is often faster than manual
memory management.  It can also improve performance indirectly, by
increasing *note locality of reference: 1601. and hence reducing the
size of the *note working set: 16ba, and decreasing *note paging: 15e7.

*note Zorn (1992): 158b.


File: MemoryPoolSystem.info,  Node: Programs with GC are huge and bloated; GC isn’t suitable for small programs or systems,  Next: I can’t use GC because I can’t afford to have my program pause,  Prev: What’s the advantage of garbage collection?,  Up: Common objections to garbage collection

15.3.3 Programs with GC are huge and bloated; GC isn’t suitable for small programs or systems
---------------------------------------------------------------------------------------------

While it is true that the major advantages of *note garbage collection:
f. are only seen in complex systems, there is no reason for garbage
collection to introduce any significant overhead at any scale.  The data
structures associated with garbage collection compare favorably in size
with those required for *note manual memory management: 8.

Some older systems gave garbage collection a bad name in terms of space
or time overhead, but many modern techniques exist that make such
overheads a thing of the past.  Additionally, some garbage collectors
are designed to work best in certain problem domains, such as large
programs; these may perform poorly outside their target environment.

*note Zorn (1992): 158b.


File: MemoryPoolSystem.info,  Node: I can’t use GC because I can’t afford to have my program pause,  Next: Isn’t it much cheaper to use reference counts rather than garbage collection?,  Prev: Programs with GC are huge and bloated; GC isn’t suitable for small programs or systems,  Up: Common objections to garbage collection

15.3.4 I can’t use GC because I can’t afford to have my program pause
---------------------------------------------------------------------

While early garbage collectors had to complete without interruption and
hence would pause observably, many techniques are now available to
ensure that modern collectors can be unobtrusive.

See also
........

*note incremental garbage collection: d, *note parallel garbage
collection: 15ed.


File: MemoryPoolSystem.info,  Node: Isn’t it much cheaper to use reference counts rather than garbage collection?,  Next: Isn’t GC unreliable? I’ve heard that GCs often kill the program,  Prev: I can’t use GC because I can’t afford to have my program pause,  Up: Common objections to garbage collection

15.3.5 Isn’t it much cheaper to use reference counts rather than garbage collection?
------------------------------------------------------------------------------------

No, updating *note reference counts: 15e0. is quite expensive, and they
have a couple of problems:

   * They can’t cope with *note cyclic data structures: 1659.; that is,
     sets of objects that are referred to only by objects in that set,
     but that don’t have a zero reference count.

   * Reference counting gets more expensive if you have to allow for the
     count overflowing.

There are many systems that use reference counts, and avoid the problems
described above by using a conventional *note garbage collector: 20. to
complement it.  This is usually done for real-time benefits.
Unfortunately, experience shows that this is generally less efficient
than implementing a proper real-time garbage collector, except in the
case where most reference counts are one.

*note Wise (1993): 157f.


File: MemoryPoolSystem.info,  Node: Isn’t GC unreliable? I’ve heard that GCs often kill the program,  Next: I’ve heard that GC uses twice as much memory,  Prev: Isn’t it much cheaper to use reference counts rather than garbage collection?,  Up: Common objections to garbage collection

15.3.6 Isn’t GC unreliable? I’ve heard that GCs often kill the program
----------------------------------------------------------------------

*note Garbage collectors: 20. usually have to manipulate vulnerable data
structures and must often use poorly-documented, low-level interfaces.
Additionally, any garbage collection problems may not be detected until
some time later.  These factors combine to make most garbage collection
bugs severe in effect, hard to reproduce, and difficult to work around.

On the other hand, commercial garbage collection code will generally be
heavily tested and widely used, which implies it must be reliable.  It
will be hard to match that reliability in a manual memory manager
written for one program, especially given that *note manual memory
management: 8. doesn’t scale as well as the automatic variety.

In addition, bugs in the compiler or run-time (or application if the
language is as low-level as *note C: 1c.) can corrupt the heap in ways
that only the garbage collector will detect later.  The collector is
blamed because it found the corruption.  This is a classic case of
shooting the messenger.


File: MemoryPoolSystem.info,  Node: I’ve heard that GC uses twice as much memory,  Next: Doesn’t garbage collection make programs slow?,  Prev: Isn’t GC unreliable? I’ve heard that GCs often kill the program,  Up: Common objections to garbage collection

15.3.7 I’ve heard that GC uses twice as much memory
---------------------------------------------------

This may be true of primitive collectors (like the *note two-space
collector: 1634.), but this is not generally true of garbage collection.
The data structures used for garbage collection need be no larger than
those for *note manual memory management: 8.


File: MemoryPoolSystem.info,  Node: Doesn’t garbage collection make programs slow?,  Next: Manual memory management gives me control—it doesn’t pause,  Prev: I’ve heard that GC uses twice as much memory,  Up: Common objections to garbage collection

15.3.8 Doesn’t garbage collection make programs slow?
-----------------------------------------------------

No.  *note Benjamin Zorn (1992): 158b. found that:

     the CPU overhead of *note conservative garbage collection: 349. is
     comparable to that of explicit storage management techniques.  […]
     Conservative garbage collection performs faster than some explicit
     algorithms and slower than others, the relative performance being
     largely dependent on the program.

Note also that the version of the conservative collector used in this
paper is now rather old and the collector has been much improved since
then.


File: MemoryPoolSystem.info,  Node: Manual memory management gives me control—it doesn’t pause,  Prev: Doesn’t garbage collection make programs slow?,  Up: Common objections to garbage collection

15.3.9 Manual memory management gives me control—it doesn’t pause
-----------------------------------------------------------------

It is possible for *note manual memory management: 8. to pause for
considerable periods, either on *note allocation: 15ca. or *note
deallocation: 15d2.  It certainly gives no guarantees about performance,
in general.

With *note automatic memory management: 9, such as *note garbage
collection: f, modern techniques can give guarantees about interactive
pause times, and so on.

See also
........

*note incremental garbage collection: d, *note parallel garbage
collection: 15ed.


File: MemoryPoolSystem.info,  Node: Miscellaneous,  Prev: Common objections to garbage collection,  Up: Frequently Asked Questions

15.4 Miscellaneous
==================

* Menu:

* Why does my disk rattle so much?::
* Where can I find out more about garbage collection?::
* Where can I get a garbage collector?::
* Why does my program use so much memory?::
* I use a library, and my program grows every time I call it. Why?: I use a library and my program grows every time I call it Why?.
* Should I write my own memory allocator to make my program fast?::
* Why can’t I just use local data on the stack or in global variables?::
* Why should I worry about virtual memory? Can’t I just use as much memory as I want?::


File: MemoryPoolSystem.info,  Node: Why does my disk rattle so much?,  Next: Where can I find out more about garbage collection?,  Up: Miscellaneous

15.4.1 Why does my disk rattle so much?
---------------------------------------

When you are using a *note virtual memory: 51. system, the computer may
have to fetch *note pages: 92. of memory from disk before they can be
accessed.  If the total *note working set: 16ba. of your active programs
exceeds the *note physical memory (1): 16b8. available, *note paging:
15e7. will happen continually, your disk will rattle, and performance
will degrade significantly.  The only solutions are to install more
physical memory, run fewer programs at the same time, or tune the memory
requirements of your programs.

The problem is aggravated because virtual memory systems approximate the
theoretical working set with the set of pages on which the working set
lies.  If the actual working set is spread out onto a large number of
pages, then the working page-set is large.

When objects that refer to each other are distant in memory, this is
known as poor *note locality of reference: 1601.  This happens either
because the program’s designer did not worry about this, or the memory
manager used in the program doesn’t permit the designer to do anything
about it.

Note that *note copying garbage collection: e3. can dynamically organize
your data according to the program’s reference patterns and thus
mitigate this problem.

See also
........

*note thrash: 16de.

*note Denning (1968): 150f.


File: MemoryPoolSystem.info,  Node: Where can I find out more about garbage collection?,  Next: Where can I get a garbage collector?,  Prev: Why does my disk rattle so much?,  Up: Miscellaneous

15.4.2 Where can I find out more about garbage collection?
----------------------------------------------------------

Many modern languages have *note garbage collection: f. built in, and
the language documentation should give details.  For some other
languages, garbage collection can be added, for example via the Memory
Pool System, or the Boehm–Demers–Weiser collector.

See also
........

*note garbage collection: f.

*note Jones et al.  (2012): 1538, *note Wilson (1994): 1579.

Memory Pool System(1), Boehm–Demers–Weiser collector(2), GC-LIST FAQ(3).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/

   (2) http://hboehm.info/gc/

   (3) http://iecc.com/gclist/GC-faq.html


File: MemoryPoolSystem.info,  Node: Where can I get a garbage collector?,  Next: Why does my program use so much memory?,  Prev: Where can I find out more about garbage collection?,  Up: Miscellaneous

15.4.3 Where can I get a garbage collector?
-------------------------------------------

The Memory Pool System and the Boehm–Demers–Weiser collector are
suitable for C or C++.  The best way to get a garbage collector,
however, is to program in a language that provides garbage collection
natively.

See also
........

*note garbage collection: f.

Memory Pool System(1), Boehm–Demers–Weiser collector(2).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/

   (2) http://hboehm.info/gc/


File: MemoryPoolSystem.info,  Node: Why does my program use so much memory?,  Next: I use a library and my program grows every time I call it Why?,  Prev: Where can I get a garbage collector?,  Up: Miscellaneous

15.4.4 Why does my program use so much memory?
----------------------------------------------

If you are using *note manual memory management: 8. (for example, *note
malloc: 1a. and *note free (2): 1b. in *note C: 1c.), it is likely that
your program is failing to free memory blocks after it stops using them.
When your code allocates memory on the heap, there is an implied
responsibility to free that memory.  If a function uses heap memory for
returning data, you must decide who takes on that responsibility.  Pay
special attention to the interfaces between functions and modules.
Remember to check what happens to allocated memory in the event of an
error or an exception.

If you are using *note automatic memory management: 9. (almost certainly
*note garbage collection: f.), it is probable that your code is
remembering some blocks that it will never use in future.  This is known
as the difference between *note liveness: 78. and *note reachability:
96.  Consider clearing variables that refer to large blocks or networks
of blocks, when the data structure is no longer required.


File: MemoryPoolSystem.info,  Node: I use a library and my program grows every time I call it Why?,  Next: Should I write my own memory allocator to make my program fast?,  Prev: Why does my program use so much memory?,  Up: Miscellaneous

15.4.5 I use a library, and my program grows every time I call it. Why?
-----------------------------------------------------------------------

If you are using *note manual memory management: 8, it is likely that
the library is allocating data structures on the heap every time it is
used, but that they are not being freed.  Check the interface
documentation for the library; it may expect you to take some action
when you have finished with returned data.  It may be necessary to close
down the library and re-initialize it to recover allocated memory.

Unfortunately, it is all too possible that the library has a memory
management bug.  In this case, unless you have the source code, there is
little you can do except report the problem to the supplier.  It may be
possible to add a garbage collector to your language, and this might
solve your problems.

With a *note garbage collector: 20, sometimes objects are retained
because there is a reference to them from some global data structure.
Although the library might not make any further use of the objects, the
collector must retain the objects because they are still *note
reachable: 96.

If you know that a particular reference will never be used in future, it
can be worthwhile to overwrite it.  This means that the collector will
not retain the referred object because of that reference.  Other
references to the same object will keep it *note alive: 78, so your
program doesn’t need to determine whether the object itself will ever be
accessed in future.  This should be done judiciously, using the garbage
collector’s tools to find what objects are being retained and why.

If your garbage collector is *note generational: e, it is possible that
you are suffering from *note premature tenuring: 1703, which can often
be solved by tuning the collector or using a separate memory area for
the library.


File: MemoryPoolSystem.info,  Node: Should I write my own memory allocator to make my program fast?,  Next: Why can’t I just use local data on the stack or in global variables?,  Prev: I use a library and my program grows every time I call it Why?,  Up: Miscellaneous

15.4.6 Should I write my own memory allocator to make my program fast?
----------------------------------------------------------------------

If you are sure that your program is spending a large proportion of its
time in *note memory management: 15dd, and you know what you’re doing,
then it is certainly possible to improve performance by writing a *note
suballocator: 16b2.  On the other hand, advances in memory management
technology make it hard to keep up with software written by experts.  In
general, improvements to memory management don’t make as much difference
to performance as improvements to the program algorithms.

*note Benjamin Zorn (1992): 158b. found that:

     In four of the programs investigated, the programmer felt compelled
     to avoid using the general-purpose storage allocator by writing
     type-specific allocation routines for the most common object types
     in the program.  […] The general conclusion […] is that programmer
     optimizations in these programs were mostly unnecessary.  […]
     simply using a different algorithm appears to improve the
     performance even more.

and concluded:

     programmers, instead of spending time writing domain-specific
     storage allocators, should consider using other publicly-available
     implementations of storage management algorithms if the one they
     are using performs poorly.


File: MemoryPoolSystem.info,  Node: Why can’t I just use local data on the stack or in global variables?,  Next: Why should I worry about virtual memory? Can’t I just use as much memory as I want?,  Prev: Should I write my own memory allocator to make my program fast?,  Up: Miscellaneous

15.4.7 Why can’t I just use local data on the stack or in global variables?
---------------------------------------------------------------------------

Global, or static, data is fixed size; it cannot grow in response to the
size or complexity of the data set received by a program.
Stack-allocated data doesn’t exist once you leave the function (or
program block) in which it was declared.

If your program’s memory requirements are entirely predictable and fixed
at compile-time, or you can structure your program to rely on stack data
only while it exists, then you can entirely avoid using heap allocation.
Note that, with some compilers, use of large global memory blocks can
bloat the object file size.

It may often seem simpler to allocate a global block that seems
“probably large enough” for any plausible data set, but this
simplification will almost certainly cause trouble sooner or later.

See also
........

*note stack allocation: 15e2, *note heap allocation: 1653, *note static
allocation: 1610.


File: MemoryPoolSystem.info,  Node: Why should I worry about virtual memory? Can’t I just use as much memory as I want?,  Prev: Why can’t I just use local data on the stack or in global variables?,  Up: Miscellaneous

15.4.8 Why should I worry about virtual memory? Can’t I just use as much memory as I want?
------------------------------------------------------------------------------------------

While *note virtual memory: 51. can greatly increase your capacity to
store data, there are three problems typically experienced with it:

   * It does not provide an unlimited amount of memory.  In particular,
     all memory that you actually allocate (as opposed to reserve) has
     to be stored somewhere.  Usually you must have disk space available
     for all pages containing allocated memory.  In a few systems, you
     can subtract the available physical memory from the disk space
     required.  If the memory contains images of program or data files,
     then *note file mapping: 167e, or assigning existing files to
     regions of the virtual address space, can help considerably.

   * In most computers, there is a large difference in speed between
     main memory and disk; running a program with a *note working set:
     16ba. that does not fit in physical memory almost always results in
     unacceptable performance.

   * An additional problem with using unnecessary quantities of memory
     is that poor *note locality of reference: 1601. can result in heavy
     paging.

See also
........

*note thrash: 16de.


File: MemoryPoolSystem.info,  Node: Copyright,  Next: Acknowledgements,  Prev: Frequently Asked Questions,  Up: Top

16 Copyright
************

Copyright © 2001-2020 Ravenbrook Limited(1).

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the
     distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS
IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/


File: MemoryPoolSystem.info,  Node: Acknowledgements,  Next: Index,  Prev: Copyright,  Up: Top

17 Acknowledgements
*******************

The Memory Management Reference is maintained by Ravenbrook Limited(1).

Most of it was originally written by memory management experts in the
Adaptive Memory Management Group at Harlequin Limited(2):

   * Nick Barnes

   * Richard Brooksby

   * David Jones

   * David Lovemore

   * Tony Mann

   * Gavin Matthews

   * Pekka P. Pirinen

   * Richard Tucker

   * P. T. Withington

Gavin Matthews was the original editor of the Memory Management
Reference.

The Adaptive Memory Management Group no longer exists, and Harlequin has
become a part of Global Graphics(3).  However, most of the group’s work
has been aquired by Ravenbrook Limited(4), whose directors are Richard
Brooksby, the group’s chief architect and manager, and Nick Barnes, a
senior group member.

Particular thanks go to Richard Jones for his enormously useful book
*note The Garbage Collection Handbook: 1538, and for his comments on the
Reference.

Many people have *note made valuable suggestions: d8. for the Reference
and contributed glossary entries.  We are grateful for the help of:

   * Judy Anderson

   * Giuseppe Attardi

   * Daniel Barrett

   * Leah Bateman

   * Stephen Bevan

   * Hans Boehm

   * Hans Feldt

   * Lars Hansen

   * Anthony Hosking

   * Paul Jackson

   * Mark S. Johnstone

   * Richard Kistruck

   * Stavros Macrakis

   * Gareth McCaughan

   * David A. Moon

   * Eliot Moss

   * John S. Pieper

   * Kent Pitman

   * Andrew Shires

   * Walter Spector

   * Martin Simmons

   * David Stoutamire

   * Tom Thomson

   * Mark Tillotson

   * JonL White

   * David S. Wise

   * Benjamin Zorn

   * genindex

   ---------- Footnotes ----------

   (1) http://ravenbrook.com/

   (2) https://en.wikipedia.org/wiki/Harlequin_(software_company)

   (3) http://www.globalgraphics.com/

   (4) http://ravenbrook.com/


File: MemoryPoolSystem.info,  Node: Index,  Prev: Acknowledgements,  Up: Top

Index
*****

 [index ]
* Menu:

* abort:                                 General debugging advice.
                                                              (line  47)
* ABQ (C type):                          Interface<3>.        (line   6)
* ABQDepth (C function):                 Interface<3>.        (line  52)
* ABQFinish (C function):                Interface<3>.        (line  22)
* ABQInit (C function):                  Interface<3>.        (line  13)
* ABQIsEmpty (C function):               Interface<3>.        (line  44)
* ABQIsFull (C function):                Interface<3>.        (line  48)
* ABQIterate (C function):               Interface<3>.        (line  67)
* ABQPeek (C function):                  Interface<3>.        (line  37)
* ABQPop (C function):                   Interface<3>.        (line  31)
* ABQPush (C function):                  Interface<3>.        (line  26)
* ABQVisitor (C type):                   Interface<3>.        (line  56)
* absolute address:                      Memory Management Glossary A.
                                                              (line  13)
* AccessSet (C type):                    Concrete types.      (line   6)
* ACT_ON_RANGE (C macro):                Functions<7>.        (line  45)
* ACT_ON_RANGE_HIGH (C macro):           Functions<7>.        (line  48)
* activation frame:                      Memory Management Glossary A.
                                                              (line  15)
* activation record:                     Memory Management Glossary A.
                                                              (line  19)
* activation stack:                      Memory Management Glossary A.
                                                              (line  55)
* active:                                Memory Management Glossary A.
                                                              (line  57)
* Addr (C type):                         Concrete types.      (line  12)
* address:                               Memory Management Glossary A.
                                                              (line  61)
* address range; design:                 Threads<3>.          (line  78)
* address space:                         Memory Management Glossary A.
                                                              (line  83)
* address space layout randomization:    General debugging advice.
                                                              (line 103)
* address space layout randomization <1>: Memory Management Glossary A.
                                                              (line 107)
* address space; predictable layout on FreeBSD: Security issues.
                                                              (line   9)
* address translation cache:             Memory Management Glossary A.
                                                              (line 122)
* address-ordered first fit:             Memory Management Glossary A.
                                                              (line 126)
* aging space:                           Memory Management Glossary A.
                                                              (line 142)
* algebraic data type:                   Memory Management Glossary A.
                                                              (line 152)
* ALGOL:                                 Memory management in various languages.
                                                              (line   6)
* Align (C type):                        Concrete types.      (line  49)
* alignment:                             Describing your objects.
                                                              (line  30)
* alignment <1>:                         Memory Management Glossary A.
                                                              (line 174)
* alignment; object:                     Describing your objects.
                                                              (line  30)
* alive:                                 Memory Management Glossary A.
                                                              (line 209)
* allocate:                              Memory Management Glossary A.
                                                              (line 213)
* allocation:                            Pool introspection.  (line 101)
* allocation frame:                      Memory Management Glossary A.
                                                              (line 254)
* allocation frames; design:             Old design.          (line  12)
* allocation mechanism:                  Memory Management Glossary A.
                                                              (line 265)
* allocation pattern:                    Memory Management Glossary A.
                                                              (line 281)
* allocation point:                      Manual allocation.   (line  67)
* allocation point <1>:                  Memory Management Glossary A.
                                                              (line 288)
* allocation point protocol:             Allocation points.   (line  48)
* allocation point protocol <1>:         Memory Management Glossary A.
                                                              (line 295)
* allocation point protocol; bugs:       Cautions.            (line  55)
* allocation point protocol; cautions:   Example allocating a symbol.
                                                              (line  27)
* allocation point protocol; example:    Allocation point protocol.
                                                              (line 200)
* allocation point protocol; tutorial:   Threads.             (line  47)
* allocation points; implementation:     Example inserting into a doubly linked list.
                                                              (line  70)
* allocation policy:                     Memory Management Glossary A.
                                                              (line 300)
* allocation policy; temporal fit:       MVT Manual Variable Temporal.
                                                              (line   9)
* allocation strategy:                   Memory Management Glossary A.
                                                              (line 323)
* allocation; frame:                     Ramp allocation.     (line  62)
* allocation; manual:                    Allocation<2>.       (line   6)
* allocation; pattern:                   Allocation interface.
                                                              (line 122)
* allocation; ramp pattern:              Allocation patterns. (line  86)
* allocation; segregated-fit:            Location dependency interface.
                                                              (line 170)
* allocation; stack-like:                Ramp allocation.     (line  62)
* allocation; tutorial:                  Threads.             (line  47)
* allocator:                             Memory Management Glossary A.
                                                              (line 337)
* AllocFrame (C type):                   Internal types.      (line   6)
* AllocFrameClass (C type):              Internal types.      (line  11)
* ambiguous reference:                   Memory Management Glossary A.
                                                              (line 351)
* ambiguous root:                        Memory Management Glossary A.
                                                              (line 370)
* AMC pool class:                        Writing a new pool class.
                                                              (line  18)
* AMC pool class; design:                Implementation<21>.  (line  35)
* AMC pool class; hash arrays:           AMC interface.       (line  56)
* AMC pool class; interface:             AMC properties.      (line  56)
* AMC pool class; properties:            AMC Automatic Mostly-Copying.
                                                              (line  25)
* AMCBufferFill (C function):            Old and aging notes below here.
                                                              (line  28)
* AMCFinish (C function):                Old and aging notes below here.
                                                              (line   6)
* amcSegBufferEmpty (C function):        Old and aging notes below here.
                                                              (line  12)
* amcSegFix (C function):                Old and aging notes below here.
                                                              (line  39)
* amcSegReclaim (C function):            Old and aging notes below here.
                                                              (line  71)
* amcSegScan (C function):               Old and aging notes below here.
                                                              (line  65)
* AMCZ pool class:                       Hash arrays.         (line  47)
* AMCZ pool class; interface:            AMCZ properties.     (line  17)
* AMCZ pool class; properties:           AMCZ Automatic Mostly-Copying Zero-rank.
                                                              (line  20)
* AMS pool class:                        AMCZ interface.      (line  41)
* AMS pool class; design:                Old and aging notes below here.
                                                              (line  87)
* AMS pool class; interface:             AMS properties.      (line  56)
* AMS pool class; properties:            AMS Automatic Mark and Sweep.
                                                              (line  22)
* area; scanning:                        Fixing interface.    (line  76)
* arena:                                 Varieties.           (line  47)
* arena <1>:                             Memory Management Glossary A.
                                                              (line 378)
* Arena (C type):                        Arena classes.       (line   6)
* arena class:                           Memory Management Glossary A.
                                                              (line 396)
* arena class; choosing:                 The Scheme interpreter.
                                                              (line  96)
* arena class; client:                   Arenas.              (line  94)
* arena class; virtual memory:           Client arenas.       (line  87)
* arena contraction callbacks; introduction: Arena introspection and debugging.
                                                              (line 145)
* arena extension callbacks; introduction: Arena introspection and debugging.
                                                              (line 145)
* arena; clamped state:                  Arena states.        (line  15)
* arena; creating:                       The Scheme interpreter.
                                                              (line  95)
* arena; debugging:                      Using idle time for collection.
                                                              (line  81)
* arena; design:                         Implementation<15>.  (line  46)
* arena; introspection:                  Using idle time for collection.
                                                              (line  82)
* arena; multiple:                       Arenas.              (line  25)
* arena; parked state:                   Arena states.        (line  25)
* arena; postmortem state:               Arena states.        (line  29)
* arena; properties:                     Virtual memory arenas.
                                                              (line 104)
* arena; states:                         Arena properties.    (line 293)
* arena; unclamped state:                Arena states.        (line   8)
* ArenaDefinalize (C function):          Internal interface.  (line  33)
* ArenaFinalize (C function):            Internal interface.  (line   6)
* ArenaSetTotalLoci (C function):        Loci.                (line  76)
* arguments; keyword:                    General types.       (line  67)
* ASLR:                                  General debugging advice.
                                                              (line 104)
* ASLR <1>:                              Memory Management Glossary A.
                                                              (line 402)
* assertion:                             Result codes.        (line  92)
* assertion <1>:                         Assertions.          (line  19)
* assertion <2>:                         Memory Management Glossary A.
                                                              (line 406)
* assertion; common causes:              Assertion handling.  (line  27)
* asynchronous garbage collector:        Memory Management Glossary A.
                                                              (line 421)
* asynchrony; cautions:                  Allocation.          (line 105)
* ATC:                                   Memory Management Glossary A.
                                                              (line 432)
* atomic object:                         Memory Management Glossary A.
                                                              (line 436)
* atomic updates:                        What next?<2>.       (line  17)
* Attr (C type):                         Concrete types.      (line  62)
* automatic memory management:           Memory Management Glossary A.
                                                              (line 440)
* automatic storage duration:            Memory Management Glossary A.
                                                              (line 470)
* AWL pool class:                        AMS interface.       (line  75)
* AWL pool class; cautions:              Protection faults.   (line  59)
* AWL pool class; dependent object:      AWL properties.      (line  55)
* AWL pool class; design:                Notes<7>.            (line  18)
* AWL pool class; interface:             Caution.             (line  28)
* AWL pool class; properties:            AWL Automatic Weak Linked.
                                                              (line  35)
* AWL pool class; protection faults:     Dependent objects.   (line  91)
* AWLBufferFill (C function):            External.            (line  30)
* AWLDependentObject (C function):       Internal.            (line 219)
* AWLDescribe (C function):              External.            (line  42)
* AWLFinish (C function):                External.            (line  17)
* AWLInit (C function):                  External.            (line   6)
* awlSegBufferEmpty (C function):        Internal.            (line  53)
* awlSegBufferFill (C function):         Internal.            (line  39)
* AWLSegCreate (C function):             Internal.            (line   6)
* awlSegFinish (C function):             Internal.            (line  33)
* awlSegFix (C function):                Internal.            (line 180)
* awlSegGreyen (C function):             Internal.            (line  67)
* awlSegInit (C function):               Internal.            (line  22)
* awlSegReclaim (C function):            Internal.            (line 197)
* awlSegScan (C function):               Internal.            (line  73)
* awlSegWhiten (C function):             Internal.            (line  59)
* backing store:                         Memory Management Glossary B.
                                                              (line  13)
* barrier (1):                           Memory Management Glossary B.
                                                              (line  29)
* barrier (2):                           Memory Management Glossary B.
                                                              (line  52)
* barrier hit:                           Memory Management Glossary B.
                                                              (line  75)
* barrier; handling in GDB:              General debugging advice.
                                                              (line  53)
* base pointer:                          Memory Management Glossary B.
                                                              (line  79)
* BASIC:                                 Memory management in various languages.
                                                              (line  22)
* best fit:                              Memory Management Glossary B.
                                                              (line  99)
* BIBOP:                                 Memory Management Glossary B.
                                                              (line 120)
* big bag of pages:                      Memory Management Glossary B.
                                                              (line 142)
* binary buddies:                        Memory Management Glossary B.
                                                              (line 146)
* bit array:                             Memory Management Glossary B.
                                                              (line 163)
* bit table:                             Memory Management Glossary B.
                                                              (line 167)
* bit tables; design:                    Notes<4>.            (line  15)
* bit vector:                            Memory Management Glossary B.
                                                              (line 171)
* bitmap:                                Memory Management Glossary B.
                                                              (line 175)
* bitmap marking:                        Memory Management Glossary B.
                                                              (line 186)
* bitmapped fit:                         Memory Management Glossary B.
                                                              (line 198)
* bitmask:                               Memory Management Glossary B.
                                                              (line 218)
* bitset:                                Memory Management Glossary B.
                                                              (line 223)
* black:                                 Memory Management Glossary B.
                                                              (line 227)
* black-listing:                         Memory Management Glossary B.
                                                              (line 241)
* blacklisting:                          Memory Management Glossary B.
                                                              (line 238)
* block:                                 Memory Management Glossary B.
                                                              (line 253)
* Bool (C type):                         Concrete types.      (line  85)
* bootstrap; design:                     Limitations of generic implementations.
                                                              (line  35)
* bounds error:                          Memory Management Glossary B.
                                                              (line 264)
* boxed:                                 Memory Management Glossary B.
                                                              (line 268)
* break-table:                           Memory Management Glossary B.
                                                              (line 286)
* brk:                                   Memory Management Glossary B.
                                                              (line 298)
* broken heart:                          Memory Management Glossary B.
                                                              (line 322)
* BT (C type):                           Interface<21>.       (line   6)
* BTCopyInvertRange (C function):        Interface<21>.       (line 191)
* BTCopyOffsetRange (C function):        Interface<21>.       (line 181)
* BTCopyRange (C function):              Interface<21>.       (line 174)
* BTCreate (C function):                 Interface<21>.       (line  31)
* BTDestroy (C function):                Interface<21>.       (line  41)
* BTFindLongResRange (C function):       Interface<21>.       (line 154)
* BTFindLongResRangeHigh (C function):   Interface<21>.       (line 164)
* BTFindResRange (C function):           Functions<7>.        (line 158)
* BTFindResRangeHigh (C function):       Functions<7>.        (line 162)
* BTFindShortResRange (C function):      Interface<21>.       (line 134)
* BTFindShortResRangeHigh (C function):  Interface<21>.       (line 144)
* BTGet (C function):                    Interface<21>.       (line  58)
* BTIsResRange (C function):             Interface<21>.       (line  97)
* BTIsSetRange (C function):             Interface<21>.       (line  90)
* BTRangesSame (C function):             Interface<21>.       (line 104)
* BTRes (C function):                    Interface<21>.       (line  70)
* BTResRange (C function):               Interface<21>.       (line  83)
* BTSet (C function):                    Interface<21>.       (line  64)
* BTSetRange (C function):               Interface<21>.       (line  76)
* BTSize (C function):                   Interface<21>.       (line  48)
* bucket:                                Memory Management Glossary B.
                                                              (line 332)
* buddy system:                          Memory Management Glossary B.
                                                              (line 346)
* buffer:                                Memory Management Glossary B.
                                                              (line 379)
* BufferAP (C function):                 Interface<22>.       (line  77)
* BufferArena (C function):              Interface<22>.       (line  89)
* BufferAttach (C function):             Interface<22>.       (line  45)
* BufferAttachMethod (C type):           Classes<3>.          (line  87)
* BufferCheck (C function):              Interface<22>.       (line  34)
* BufferCommit (C function):             Interface<22>.       (line 125)
* BufferCreate (C function):             Interface<22>.       (line   6)
* BufferDestroy (C function):            Interface<22>.       (line  21)
* BufferDetach (C function):             Interface<22>.       (line  55)
* BufferDetachMethod (C type):           Classes<3>.          (line  97)
* BufferFill (C function):               Interface<22>.       (line 118)
* BufferInitMethod (C type):             Classes<3>.          (line  76)
* BufferIsReady (C function):            Interface<22>.       (line  70)
* BufferIsReset (C function):            Interface<22>.       (line  64)
* BufferMode (C type):                   Concrete types.      (line 138)
* BufferOfAP (C function):               Interface<22>.       (line  81)
* BufferPool (C function):               Interface<22>.       (line  98)
* BufferRankSetMethod (C type):          Classes<3>.          (line 112)
* BufferReserve (C function):            Interface<22>.       (line 102)
* buffers; design:                       References<21>.      (line   9)
* BufferSegMethod (C type):              Classes<3>.          (line 105)
* BufferSetRankSetMethod (C type):       Classes<3>.          (line 120)
* BufferTrip (C function):               Interface<22>.       (line 147)
* bug; allocating with wrong size:       Example underscanning.
                                                              (line 110)
* bug; allocation point protocol:        Cautions.            (line  54)
* bug; underscanning:                    Address space layout randomization.
                                                              (line  82)
* building:                              What next?.          (line  19)
* building <1>:                          Contact us.          (line  28)
* bus error:                             Memory Management Glossary B.
                                                              (line 396)
* byte (1):                              Memory Management Glossary B.
                                                              (line 413)
* byte (2):                              Memory Management Glossary B.
                                                              (line 431)
* byte (3):                              Memory Management Glossary B.
                                                              (line 448)
* byte (4):                              Memory Management Glossary B.
                                                              (line 458)
* Byte (C type):                         Concrete types.      (line 160)
* C:                                     Memory management in various languages.
                                                              (line  39)
* C interface; design:                   Checklist.           (line  12)
* C language formatting; guide:          References<5>.       (line  15)
* C language naming; guide:              Macros<2>.           (line  23)
* C language; formatting guide:          References<5>.       (line  16)
* C language; naming guide:              Macros<2>.           (line  24)
* C#:                                    Memory management in various languages.
                                                              (line 121)
* C++:                                   Memory management in various languages.
                                                              (line 148)
* C89:                                   Memory Management Glossary C.
                                                              (line  13)
* C90:                                   Memory Management Glossary C.
                                                              (line  15)
* C99:                                   Memory Management Glossary C.
                                                              (line  29)
* cache (1):                             Memory Management Glossary C.
                                                              (line  40)
* cache (2):                             Memory Management Glossary C.
                                                              (line  68)
* cache memory:                          Memory Management Glossary C.
                                                              (line  85)
* cache policy:                          Memory Management Glossary C.
                                                              (line  87)
* caching (3):                           Memory Management Glossary C.
                                                              (line 120)
* cactus stack:                          Memory Management Glossary C.
                                                              (line 133)
* card:                                  Memory Management Glossary C.
                                                              (line 149)
* card marking:                          Memory Management Glossary C.
                                                              (line 159)
* CBS (C type):                          External types.      (line   6)
* cell:                                  Memory Management Glossary C.
                                                              (line 179)
* chain; generation:                     Garbage collection.  (line  13)
* CHECKD (C macro):                      Implementation<17>.  (line  70)
* checking; design:                      Diagrams.            (line  24)
* CHECKL (C macro):                      Implementation<17>.  (line  56)
* CHECKS (C macro):                      Implementation<17>.  (line  50)
* CHECKU (C macro):                      Implementation<17>.  (line  63)
* Cheney collector:                      Memory Management Glossary C.
                                                              (line 183)
* Cheney scan:                           Memory Management Glossary C.
                                                              (line 194)
* clamped state:                         Arena states.        (line  15)
* clamped state <1>:                     Memory Management Glossary C.
                                                              (line 198)
* CLASS (C macro):                       Class access.        (line   6)
* ClassOfPoly (C macro):                 Introspection.       (line  27)
* client arena:                          Memory Management Glossary C.
                                                              (line 208)
* client arena class:                    Arenas.              (line  94)
* client message protocol:               References<7>.       (line  12)
* client object:                         Memory Management Glossary C.
                                                              (line 213)
* client pointer:                        Memory Management Glossary C.
                                                              (line 220)
* client program:                        Memory Management Glossary C.
                                                              (line 232)
* Clock (C type):                        Concrete types.      (line 173)
* clock; design:                         Risks.               (line  12)
* closure:                               Memory Management Glossary C.
                                                              (line 234)
* coalesce:                              Memory Management Glossary C.
                                                              (line 270)
* coalescing block structures; design:   Arena’s free land.   (line  25)
* COBOL:                                 Memory management in various languages.
                                                              (line  90)
* cold end:                              Memory Management Glossary C.
                                                              (line 284)
* collect:                               Memory Management Glossary C.
                                                              (line 300)
* collection:                            Root introspection.  (line  68)
* collection <1>:                        Memory Management Glossary C.
                                                              (line 307)
* collection cycle:                      Memory Management Glossary C.
                                                              (line 311)
* collection framework; design:          Common assertions.   (line  13)
* collection; running:                   Arena states.        (line 156)
* collection; scheduling:                Generation chains.   (line 122)
* collector (1):                         Memory Management Glossary C.
                                                              (line 331)
* collector (2):                         Memory Management Glossary C.
                                                              (line 335)
* color:                                 Memory Management Glossary C.
                                                              (line 350)
* colour:                                Memory Management Glossary C.
                                                              (line 353)
* commit limit:                          Memory Management Glossary C.
                                                              (line 359)
* committed (1):                         Memory Management Glossary C.
                                                              (line 366)
* committed (2):                         Memory Management Glossary C.
                                                              (line 370)
* Common Lisp:                           Memory management in various languages.
                                                              (line 107)
* compactifying:                         Memory Management Glossary C.
                                                              (line 376)
* compaction:                            Memory Management Glossary C.
                                                              (line 380)
* Compare (C type):                      Concrete types.      (line 189)
* COMPATFIELD (C macro):                 Checking.            (line  53)
* COMPATFIELDAPPROX (C macro):           Checking.            (line  44)
* COMPATLVALUE (C macro):                Checking.            (line  23)
* COMPATTYPE (C macro):                  Checking.            (line  32)
* compiling:                             What next?.          (line  19)
* compiling <1>:                         Contact us.          (line  28)
* composite object:                      Memory Management Glossary C.
                                                              (line 392)
* comprehensive:                         Memory Management Glossary C.
                                                              (line 406)
* concurrent garbage collection:         Memory Management Glossary C.
                                                              (line 419)
* condemned set:                         Memory Management Glossary C.
                                                              (line 421)
* CONFIG_PLINTH_NONE (C macro):          Plinth.              (line  51)
* CONFIG_PTHREADEXT_SIGRESUME (C macro): Signal and exception handling issues.
                                                              (line  24)
* CONFIG_PTHREADEXT_SIGSUSPEND (C macro): Signal and exception handling issues.
                                                              (line  17)
* CONFIG_VAR_COOL (C macro):             Varieties.           (line  12)
* CONFIG_VAR_HOT (C macro):              Varieties.           (line  25)
* CONFIG_VAR_RASH (C macro):             Varieties.           (line  38)
* configuration; design:                 Implementation<2>.   (line  11)
* connected:                             Memory Management Glossary C.
                                                              (line 448)
* cons (1):                              Memory Management Glossary C.
                                                              (line 460)
* cons (2):                              Memory Management Glossary C.
                                                              (line 466)
* conservative garbage collection:       Memory Management Glossary C.
                                                              (line 470)
* consistency; maintaining:              Allocation.          (line 106)
* constant root:                         Memory Management Glossary C.
                                                              (line 508)
* constructor (1):                       Memory Management Glossary C.
                                                              (line 515)
* constructor (2):                       Memory Management Glossary C.
                                                              (line 522)
* continuation:                          Memory Management Glossary C.
                                                              (line 539)
* contraction callbacks; introduction:   Arena introspection and debugging.
                                                              (line 144)
* control stack:                         Memory Management Glossary C.
                                                              (line 554)
* cool:                                  Memory Management Glossary C.
                                                              (line 583)
* cool variety:                          General debugging advice.
                                                              (line   9)
* cool variety <1>:                      Varieties.           (line  12)
* copying garbage collection:            Memory Management Glossary C.
                                                              (line 588)
* copyright:                             Build infrastructure.
                                                              (line 100)
* core:                                  Memory Management Glossary C.
                                                              (line 619)
* CouldBeA (C macro):                    Conversion.          (line  33)
* Count (C type):                        Concrete types.      (line 207)
* creation space:                        Memory Management Glossary C.
                                                              (line 627)
* critical path:                         References.          (line  12)
* critical path <1>:                     Memory Management Glossary C.
                                                              (line 646)
* crossing map:                          Memory Management Glossary C.
                                                              (line 651)
* cyclic data structure:                 Memory Management Glossary C.
                                                              (line 671)
* dangling pointer:                      Memory Management Glossary D.
                                                              (line  13)
* data stack:                            Memory Management Glossary D.
                                                              (line  34)
* dead:                                  Memory Management Glossary D.
                                                              (line  54)
* deallocate:                            Memory Management Glossary D.
                                                              (line  73)
* debugger:                              General debugging advice.
                                                              (line  47)
* debugging:                             The stretchy vector problem.
                                                              (line 135)
* debugging pool:                        Memory Management Glossary D.
                                                              (line  75)
* debugging; design:                     Coverage.            (line  10)
* debugging; fencepost:                  Debugging pools.     (line  21)
* debugging; free space splatting:       Debugging pools.     (line  30)
* debugging; pool:                       Allocation frames.   (line  81)
* DECLARE_CLASS (C macro):               Class declaration.   (line   6)
* deferred coalescing:                   Memory Management Glossary D.
                                                              (line  83)
* deferred reference counting:           Memory Management Glossary D.
                                                              (line 100)
* DEFINE_CLASS (C macro):                Class definition.    (line   6)
* dependency; location:                  Finalization messages<2>.
                                                              (line  65)
* dependent object:                      Memory Management Glossary D.
                                                              (line 128)
* deprecated interfaces:                 Contribute.          (line   8)
* deprecated interfaces; in version 1.112: Deprecated in version 1 113.
                                                              (line  11)
* deprecated interfaces; in version 1.113: Deprecated in version 1 115.
                                                              (line 267)
* deprecated interfaces; in version 1.115: Deprecated in version 1 118.
                                                              (line 176)
* deprecated interfaces; in version 1.118: Deprecated interfaces.
                                                              (line  16)
* derived pointer:                       Memory Management Glossary D.
                                                              (line 137)
* DescribeMethod (C type):               Common instance methods.
                                                              (line  15)
* destroying:                            Maintaining consistency.
                                                              (line  39)
* destructor (1):                        Memory Management Glossary D.
                                                              (line 141)
* destructor (2):                        Memory Management Glossary D.
                                                              (line 149)
* developer; guide:                      Opportunities for improvement.
                                                              (line  14)
* DGC:                                   Memory Management Glossary D.
                                                              (line 167)
* diagnostic feedback; design:           Software barriers.   (line   7)
* direct method:                         Memory Management Glossary D.
                                                              (line 169)
* dirty bit:                             Memory Management Glossary D.
                                                              (line 191)
* distributed garbage collection:        Memory Management Glossary D.
                                                              (line 200)
* documentation; design:                 References<2>.       (line   5)
* double buddies:                        Memory Management Glossary D.
                                                              (line 215)
* double free:                           Memory Management Glossary D.
                                                              (line 230)
* doubleword:                            Memory Management Glossary D.
                                                              (line 253)
* doubly weak hash table:                Memory Management Glossary D.
                                                              (line 270)
* DRAM:                                  Memory Management Glossary D.
                                                              (line 273)
* Dylan:                                 Memory management in various languages.
                                                              (line 208)
* dynamic allocation:                    Memory Management Glossary D.
                                                              (line 277)
* dynamic extent:                        Memory Management Glossary D.
                                                              (line 281)
* dynamic memory:                        Memory Management Glossary D.
                                                              (line 293)
* dynamic RAM:                           Memory Management Glossary D.
                                                              (line 317)
* ecru:                                  Memory Management Glossary E.
                                                              (line  13)
* edge:                                  Memory Management Glossary E.
                                                              (line  15)
* Emacs Lisp:                            Memory management in various languages.
                                                              (line 235)
* entry table (1):                       Memory Management Glossary E.
                                                              (line  37)
* entry table (2):                       Memory Management Glossary E.
                                                              (line  55)
* environment variable; MPS_TELEMETRY_CONTROL: Telemetry.     (line  11)
* environment variable; MPS_TELEMETRY_CONTROL <1>: Environment variables.
                                                              (line  10)
* environment variable; MPS_TELEMETRY_CONTROL <2>: Telemetry labels.
                                                              (line  59)
* environment variable; MPS_TELEMETRY_CONTROL <3>: Telemetry labels.
                                                              (line  79)
* environment variable; MPS_TELEMETRY_CONTROL <4>: Library module.
                                                              (line 230)
* environment variable; MPS_TELEMETRY_CONTROL <5>: Library module.
                                                              (line 236)
* environment variable; MPS_TELEMETRY_CONTROL <6>: Library module.
                                                              (line 243)
* environment variable; MPS_TELEMETRY_CONTROL <7>: Telemetry<2>.
                                                              (line  10)
* environment variable; MPS_TELEMETRY_CONTROL <8>: Interface changes<8>.
                                                              (line  10)
* environment variable; MPS_TELEMETRY_CONTROL <9>: New features<9>.
                                                              (line  57)
* environment variable; MPS_TELEMETRY_DATABASE: Environment variables.
                                                              (line  38)
* environment variable; MPS_TELEMETRY_DATABASE <1>: Loading the telemetry stream into SQLite.
                                                              (line  22)
* environment variable; MPS_TELEMETRY_FILENAME: Telemetry.    (line  13)
* environment variable; MPS_TELEMETRY_FILENAME <1>: Environment variables.
                                                              (line  28)
* environment variable; MPS_TELEMETRY_FILENAME <2>: I/O module.
                                                              (line  38)
* environment variable; MPS_TELEMETRY_FILENAME <3>: Telemetry<2>.
                                                              (line  12)
* environment variable; MPS_TELEMETRY_FILENAME <4>: New features<9>.
                                                              (line  62)
* Epoch (C type):                        Concrete types.      (line 225)
* error handling; assertion:             Result codes.        (line  91)
* error handling; assertion; assertion handling: Assertions.  (line  19)
* error handling; introduction:          Keyword arguments.   (line 254)
* error handling; varieties:             Common assertions and their causes.
                                                              (line 144)
* EVENT (built-in variable):             Decoding the telemetry stream in Python.
                                                              (line  50)
* event category:                        Example.             (line  81)
* EVENT_CLOCK (C macro):                 Interface<5>.        (line  19)
* EVENT_CLOCK_MAKE (C macro):            Interface<5>.        (line  12)
* EVENT_CLOCK_PRINT (C macro):           Interface<5>.        (line  24)
* EVENT_CLOCK_WRITE (C macro):           Interface<5>.        (line  30)
* EventDesc (built-in class):            Decoding the telemetry stream in Python.
                                                              (line  54)
* EventParam (built-in class):           Decoding the telemetry stream in Python.
                                                              (line  77)
* exact garbage collection:              Memory Management Glossary E.
                                                              (line  75)
* exact reference:                       Memory Management Glossary E.
                                                              (line  86)
* exact root:                            Memory Management Glossary E.
                                                              (line  98)
* exact segregated fit:                  Memory Management Glossary E.
                                                              (line 114)
* exception; handling:                   Thread registration. (line  25)
* execution stack:                       Memory Management Glossary E.
                                                              (line 129)
* execution; environment:                References<3>.       (line   8)
* exit table:                            Memory Management Glossary E.
                                                              (line 133)
* extension callbacks; introduction:     Arena introspection and debugging.
                                                              (line 145)
* extent:                                Memory Management Glossary E.
                                                              (line 145)
* external fragmentation:                Memory Management Glossary E.
                                                              (line 149)
* fail-over allocator; design:           Architecture.        (line  31)
* Failover (C type):                     Types<3>.            (line   6)
* fence post:                            Memory Management Glossary F.
                                                              (line  14)
* fence post error:                      Memory Management Glossary F.
                                                              (line  36)
* fencepost:                             Debugging pools.     (line  21)
* fencepost <1>:                         Memory Management Glossary F.
                                                              (line  13)
* fencepost error:                       Memory Management Glossary F.
                                                              (line  33)
* Fibonacci buddies:                     Memory Management Glossary F.
                                                              (line  56)
* FIFO-ordered first fit:                Memory Management Glossary F.
                                                              (line  74)
* file mapping:                          Memory Management Glossary F.
                                                              (line  88)
* finalization:                          Message queue interface.
                                                              (line  60)
* finalization <1>:                      Memory Management Glossary F.
                                                              (line  92)
* finalization; cautions:                Multiple finalizations.
                                                              (line  17)
* finalization; design:                  Implementation<5>.   (line  24)
* finalization; example:                 Advanced topics.     (line   6)
* finalization; interface:               Cautions<4>.         (line  76)
* finalization; message:                 Finalization interface.
                                                              (line  47)
* finalization; multiple:                Finalization<2>.     (line  85)
* finalized block:                       Memory Management Glossary F.
                                                              (line 122)
* FindDelete (C type):                   Concrete types.      (line 234)
* FinishMethod (C type):                 Common instance methods.
                                                              (line   8)
* first fit:                             Memory Management Glossary F.
                                                              (line 129)
* fix:                                   Memory Management Glossary F.
                                                              (line 161)
* fix function; design:                  References<22>.      (line  11)
* fixed-length queues; design:           Design.              (line  11)
* fixing; interface:                     Scanning interface.  (line 110)
* flip:                                  Memory Management Glossary F.
                                                              (line 168)
* floating garbage:                      Memory Management Glossary F.
                                                              (line 185)
* foreign code:                          Memory Management Glossary F.
                                                              (line 231)
* fork safety:                           Signal and exception handling issues.
                                                              (line  56)
* format:                                Memory Management Glossary F.
                                                              (line 243)
* format method:                         Cautions<2>.         (line  74)
* format method <1>:                     Memory Management Glossary F.
                                                              (line 263)
* format method; forward:                The skip method.     (line  38)
* format method; is-forwarded:           The forward method.  (line 105)
* format method; padding:                The is-forwarded method.
                                                              (line  30)
* format method; scan:                   Alignment.           (line  46)
* format method; skip:                   The scan method.     (line  95)
* format; object:                        Choosing a pool class.
                                                              (line  31)
* format; object <1>:                    Allocation point implementation.
                                                              (line 153)
* formatted object:                      Memory Management Glossary F.
                                                              (line 269)
* Fortran:                               Memory management in various languages.
                                                              (line 267)
* forward method:                        The skip method.     (line  38)
* forward method <1>:                    Memory Management Glossary F.
                                                              (line 275)
* forwarding marker:                     Memory Management Glossary F.
                                                              (line 283)
* forwarding object:                     Memory Management Glossary F.
                                                              (line 286)
* forwarding pointer:                    Memory Management Glossary F.
                                                              (line 288)
* fragmentation:                         Memory Management Glossary F.
                                                              (line 307)
* frame:                                 Memory Management Glossary F.
                                                              (line 316)
* free (1):                              Memory Management Glossary F.
                                                              (line 320)
* free (2):                              Memory Management Glossary F.
                                                              (line 339)
* free (3):                              Memory Management Glossary F.
                                                              (line 342)
* free (4):                              Memory Management Glossary F.
                                                              (line 358)
* free block:                            Memory Management Glossary F.
                                                              (line 360)
* free block chain:                      Memory Management Glossary F.
                                                              (line 377)
* free list:                             Memory Management Glossary F.
                                                              (line 397)
* free list allocator; design:           Internal interface.  (line  42)
* free list; segregated:                 Location dependency interface.
                                                              (line 170)
* free space splatting:                  Debugging pools.     (line  30)
* free store:                            Memory Management Glossary F.
                                                              (line 439)
* free; implementing:                    Segregation of objects.
                                                              (line  54)
* Freelist (C type):                     Types<4>.            (line   6)
* freestanding:                          Memory Management Glossary F.
                                                              (line 418)
* freestanding environment:              Interface<2>.        (line 102)
* freestore:                             Memory Management Glossary F.
                                                              (line 442)
* from space:                            Memory Management Glossary F.
                                                              (line 445)
* fromspace:                             Memory Management Glossary F.
                                                              (line 448)
* Fun (C type):                          Concrete types.      (line 257)
* function pointer:                      Memory Management Glossary F.
                                                              (line 457)
* function record:                       Memory Management Glossary F.
                                                              (line 469)
* garbage:                               Memory Management Glossary G.
                                                              (line  13)
* garbage collection:                    Root introspection.  (line  67)
* garbage collection <1>:                Memory Management Glossary G.
                                                              (line  19)
* garbage collection messages; design:   Notes<6>.            (line  17)
* garbage collection; limiting pause:    Running garbage collections.
                                                              (line  61)
* garbage collection; message:           Garbage collection start messages.
                                                              (line  47)
* garbage collection; running:           Arena states.        (line 157)
* garbage collection; scheduling:        Generation chains.   (line 121)
* garbage collection; start message:     Scheduling of collections.
                                                              (line  38)
* garbage collection; using idle time:   Running garbage collections.
                                                              (line  61)
* garbage collector:                     Memory Management Glossary G.
                                                              (line  84)
* GB:                                    Memory Management Glossary G.
                                                              (line  95)
* GC:                                    Memory Management Glossary G.
                                                              (line  99)
* GCSeg (C type):                        Data Structure.      (line   8)
* General Protection Fault:              Memory Management Glossary G.
                                                              (line 103)
* general types; design:                 References<17>.      (line  17)
* generation:                            Memory Management Glossary G.
                                                              (line 110)
* generation chain:                      Garbage collection.  (line  13)
* generation chain <1>:                  Memory Management Glossary G.
                                                              (line 136)
* generation scavenging:                 Memory Management Glossary G.
                                                              (line 142)
* generation; choosing size:             What next?<3>.       (line  11)
* generational garbage collection:       Memory Management Glossary G.
                                                              (line 146)
* generational hypothesis:               Memory Management Glossary G.
                                                              (line 178)
* generic modules; design:               Interface<3>.        (line  72)
* generic scanner; design:               Scanning<3>.         (line  12)
* gigabyte:                              Memory Management Glossary G.
                                                              (line 192)
* good fit:                              Memory Management Glossary G.
                                                              (line 202)
* GPF:                                   Memory Management Glossary G.
                                                              (line 218)
* grain:                                 Memory Management Glossary G.
                                                              (line 222)
* graph:                                 Memory Management Glossary G.
                                                              (line 237)
* gray:                                  Memory Management Glossary G.
                                                              (line 257)
* gray list:                             Memory Management Glossary G.
                                                              (line 274)
* grey:                                  Memory Management Glossary G.
                                                              (line 260)
* grey list:                             Memory Management Glossary G.
                                                              (line 277)
* handle:                                Memory Management Glossary H.
                                                              (line  13)
* Hardened Runtime:                      Historical platform list.
                                                              (line 126)
* hash table; address-based example:     Finalization.        (line 162)
* hash table; weak example:              Location dependency. (line 247)
* header:                                Memory Management Glossary H.
                                                              (line  41)
* HEADER_FORMAT (built-in variable):     Decoding the telemetry stream in Python.
                                                              (line  20)
* HEADER_SIZE (built-in variable):       Decoding the telemetry stream in Python.
                                                              (line  14)
* HeaderDesc (built-in class):           Decoding the telemetry stream in Python.
                                                              (line  25)
* heap:                                  Memory Management Glossary H.
                                                              (line  45)
* heap allocation:                       Memory Management Glossary H.
                                                              (line  55)
* hexadecimal; transliterating:          References<4>.       (line   9)
* hit:                                   Memory Management Glossary H.
                                                              (line  81)
* hit rate:                              Memory Management Glossary H.
                                                              (line  88)
* hosted:                                Memory Management Glossary H.
                                                              (line  95)
* hosted environment:                    Interface<2>.        (line 102)
* hot:                                   Memory Management Glossary H.
                                                              (line 104)
* hot end:                               Memory Management Glossary H.
                                                              (line 112)
* hot variety:                           Varieties.           (line  25)
* huge page:                             Memory Management Glossary H.
                                                              (line 121)
* I/O module:                            Plinth.              (line  62)
* I/O subsystem; design:                 Implementation<18>.  (line  11)
* idle time; using for garbage collection: Running garbage collections.
                                                              (line  61)
* immediate data:                        Memory Management Glossary I.
                                                              (line  13)
* immune set:                            Memory Management Glossary I.
                                                              (line  25)
* immutable:                             Memory Management Glossary I.
                                                              (line  31)
* immutable object:                      Memory Management Glossary I.
                                                              (line  59)
* in parameter:                          Memory Management Glossary I.
                                                              (line  93)
* in-band header:                        Memory Management Glossary I.
                                                              (line  61)
* in/out parameter:                      Memory Management Glossary I.
                                                              (line 100)
* incremental garbage collection:        Memory Management Glossary I.
                                                              (line 108)
* incremental update:                    Memory Management Glossary I.
                                                              (line 140)
* indefinite extent:                     Memory Management Glossary I.
                                                              (line 179)
* Index (C type):                        Concrete types.      (line 268)
* indexed fit:                           Memory Management Glossary I.
                                                              (line 197)
* indirect method:                       Memory Management Glossary I.
                                                              (line 213)
* infant mortality:                      Memory Management Glossary I.
                                                              (line 237)
* INHERIT_CLASS (C macro):               Single inheritance.  (line   6)
* inline allocation (1):                 Memory Management Glossary I.
                                                              (line 241)
* inline allocation (2):                 Memory Management Glossary I.
                                                              (line 249)
* installing:                            What next?.          (line  18)
* installing <1>:                        Contact us.          (line  27)
* inter-generational pointer:            Memory Management Glossary I.
                                                              (line 255)
* interface; functions:                  Types.               (line  28)
* interface; headers:                    Language.            (line   8)
* interface; identifiers:                Headers.             (line  21)
* interface; introduction:               Reference.           (line   6)
* interface; language:                   Support policy.      (line  27)
* interface; macros:                     Type punning.        (line  31)
* interface; support policy:             Interface conventions.
                                                              (line  11)
* interface; type punning:               Functions.           (line  34)
* interface; types:                      Identifiers.         (line  23)
* interior pointer:                      Memory Management Glossary I.
                                                              (line 281)
* internal fragmentation:                Memory Management Glossary I.
                                                              (line 308)
* invalid page fault:                    Memory Management Glossary I.
                                                              (line 323)
* inverted page table:                   Memory Management Glossary I.
                                                              (line 339)
* inverted page-table:                   Memory Management Glossary I.
                                                              (line 340)
* is-forwarded method:                   The forward method.  (line 105)
* is-forwarded method <1>:               Memory Management Glossary I.
                                                              (line 368)
* IsA (C macro):                         Conversion.          (line   6)
* IsSubclass (C macro):                  Introspection.       (line  44)
* Java:                                  Memory management in various languages.
                                                              (line 289)
* JavaScript:                            Memory management in various languages.
                                                              (line 322)
* kB:                                    Memory Management Glossary K.
                                                              (line  13)
* keyword argument:                      Memory Management Glossary K.
                                                              (line  15)
* keyword arguments; design:             Notes<2>.            (line  27)
* kilobyte:                              Memory Management Glossary K.
                                                              (line  24)
* Land (C type):                         Types<5>.            (line   6)
* LandCreate (C function):               Generic functions.   (line  17)
* LandDelete (C function):               Generic functions.   (line  81)
* LandDeleteSteal (C function):          Generic functions.   (line 106)
* LandDeleteVisitor (C type):            Types<5>.            (line  18)
* LandDescribe (C function):             Generic functions.   (line 225)
* LandFindFirst (C function):            Generic functions.   (line 157)
* LandFindInZones (C function):          Generic functions.   (line 204)
* LandFindLargest (C function):          Generic functions.   (line 189)
* LandFindLast (C function):             Generic functions.   (line 183)
* LandFinish (C function):               Generic functions.   (line  25)
* LandFlush (C function):                Generic functions.   (line 232)
* LandInit (C function):                 Generic functions.   (line   6)
* LandInsert (C function):               Generic functions.   (line  35)
* LandInsertSteal (C function):          Generic functions.   (line  54)
* LandIterate (C function):              Generic functions.   (line 128)
* LandIterateAndDelete (C function):     Generic functions.   (line 139)
* lands; design:                         References<6>.       (line   8)
* LandSize (C function):                 Generic functions.   (line  30)
* LandVisitor (C type):                  Types<5>.            (line  10)
* large object area:                     Memory Management Glossary L.
                                                              (line  13)
* large page:                            Memory Management Glossary L.
                                                              (line  59)
* leaf object:                           Memory Management Glossary L.
                                                              (line  62)
* leak:                                  Memory Management Glossary L.
                                                              (line  83)
* library interface; design:             Attachments.         (line   7)
* library module:                        I/O module.          (line  88)
* library version mechanism; design:     Abstract types.      (line  21)
* license:                               Build infrastructure.
                                                              (line 100)
* license; commercial terms:             Guide.               (line   6)
* life:                                  Memory Management Glossary L.
                                                              (line  87)
* lifetime:                              Memory Management Glossary L.
                                                              (line  91)
* LIFO-ordered first fit:                Memory Management Glossary L.
                                                              (line 105)
* limited-field reference count:         Memory Management Glossary L.
                                                              (line 125)
* linear addressing:                     Memory Management Glossary L.
                                                              (line 149)
* Lisp:                                  Memory management in various languages.
                                                              (line 334)
* Lisp Machine:                          Memory management in various languages.
                                                              (line 369)
* live:                                  Memory Management Glossary L.
                                                              (line 157)
* LO pool class:                         AWL interface.       (line  83)
* LO pool class; design:                 Test.                (line  27)
* LO pool class; interface:              LO properties.       (line  54)
* LO pool class; properties:             LO Leaf Object.      (line  29)
* load:                                  Memory Management Glossary L.
                                                              (line 182)
* locality of reference:                 Memory Management Glossary L.
                                                              (line 203)
* location:                              Memory Management Glossary L.
                                                              (line 229)
* location dependency:                   Finalization messages<2>.
                                                              (line  66)
* location dependency <1>:               Memory Management Glossary L.
                                                              (line 233)
* location dependency; adding:           Creating dependencies.
                                                              (line  31)
* location dependency; creating:         Terminology.         (line  24)
* location dependency; example:          Finalization.        (line 162)
* location dependency; interface:        Thread safety<2>.    (line  12)
* location dependency; testing staleness: Adding dependencies.
                                                              (line  28)
* location dependency; thread safety:    Testing dependencies for staleness.
                                                              (line  82)
* Lock (C type):                         Interface<9>.        (line   6)
* lock free:                             Memory Management Glossary L.
                                                              (line 243)
* LockClaim (C function):                Interface<9>.        (line  25)
* LockClaimGlobal (C function):          Interface<9>.        (line  56)
* LockClaimGlobalRecursive (C function): Interface<9>.        (line  65)
* LockClaimRecursive (C function):       Interface<9>.        (line  34)
* LockFinish (C function):               Interface<9>.        (line  21)
* locking; design:                       Testing<3>.          (line  15)
* LockInit (C function):                 Interface<9>.        (line  16)
* LockInitGlobal (C function):           Interface<9>.        (line  49)
* LockIsHeld (C function):               Interface<9>.        (line  44)
* LockRelease (C function):              Interface<9>.        (line  30)
* LockReleaseGlobal (C function):        Interface<9>.        (line  61)
* LockReleaseGlobalRecursive (C function): Interface<9>.      (line  70)
* LockReleaseRecursive (C function):     Interface<9>.        (line  39)
* LockSetup (C function):                Interface<9>.        (line  75)
* LockSize (C function):                 Interface<9>.        (line  12)
* locus manager; design:                 Implementation<19>.  (line  15)
* LocusCreate (C function):              Loci.                (line   6)
* LocusPrefKind (C type):                Concrete types.      (line 278)
* logical address:                       Memory Management Glossary L.
                                                              (line 250)
* longword:                              Memory Management Glossary L.
                                                              (line 254)
* loSegFix (C function):                 Internal<2>.         (line   6)
* loSegReclaim (C function):             Internal<2>.         (line  22)
* Lua:                                   Memory management in various languages.
                                                              (line 408)
* machine word:                          Memory Management Glossary M.
                                                              (line  13)
* main memory:                           Memory Management Glossary M.
                                                              (line  15)
* malloc:                                Memory Management Glossary M.
                                                              (line  41)
* malloc; implementing:                  Segregation of objects.
                                                              (line  55)
* manual allocation:                     Allocation<2>.       (line   6)
* manual memory management:              Memory Management Glossary M.
                                                              (line  52)
* mapped:                                Memory Management Glossary M.
                                                              (line  90)
* mapping:                               Memory Management Glossary M.
                                                              (line 112)
* mark-and-sweep:                        Memory Management Glossary M.
                                                              (line 166)
* mark-compact:                          Memory Management Glossary M.
                                                              (line 141)
* mark-sweep:                            Memory Management Glossary M.
                                                              (line 163)
* marking:                               Memory Management Glossary M.
                                                              (line 190)
* MB:                                    Memory Management Glossary M.
                                                              (line 216)
* megabyte:                              Memory Management Glossary M.
                                                              (line 218)
* memoization:                           Memory Management Glossary M.
                                                              (line 228)
* memory (1):                            Memory Management Glossary M.
                                                              (line 232)
* memory (2):                            Memory Management Glossary M.
                                                              (line 247)
* memory (3):                            Memory Management Glossary M.
                                                              (line 255)
* memory (4):                            Memory Management Glossary M.
                                                              (line 259)
* memory bandwidth:                      Memory Management Glossary M.
                                                              (line 264)
* memory cache:                          Memory Management Glossary M.
                                                              (line 276)
* memory hierarchy:                      Memory Management Glossary M.
                                                              (line 280)
* memory leak:                           Memory Management Glossary M.
                                                              (line 284)
* memory location:                       Memory Management Glossary M.
                                                              (line 305)
* memory management:                     Memory Management Glossary M.
                                                              (line 314)
* Memory Management Unit:                Memory Management Glossary M.
                                                              (line 377)
* memory manager:                        Memory Management Glossary M.
                                                              (line 379)
* memory mapping:                        Memory Management Glossary M.
                                                              (line 399)
* Memory Pool System; critical path:     References.          (line  11)
* Memory Pool System; overview:          Guide.               (line   6)
* Memory Pool System; performance:       What next?<3>.       (line  12)
* Memory Pool System; supported target platforms: Overview of the Memory Pool System.
                                                              (line  22)
* Memory Pool System; technical introduction: Supported target platforms.
                                                              (line  27)
* Memory Pool System; tutorial:          mpseventsql.         (line  37)
* memory protection:                     Memory Management Glossary M.
                                                              (line 431)
* memory protection; design:             macOS implementation.
                                                              (line  37)
* message:                               Memory Management Glossary M.
                                                              (line 433)
* Message (C type):                      Types<6>.            (line   6)
* message queue:                         Memory Management Glossary M.
                                                              (line 438)
* message type:                          Memory Management Glossary M.
                                                              (line 445)
* message; example:                      Finalization messages.
                                                              (line  18)
* message; finalization:                 Messages.            (line  33)
* message; garbage collection start:     Scheduling of collections.
                                                              (line  37)
* message; interface:                    Message types.       (line  62)
* message; introduction:                 Garbage collection messages.
                                                              (line  97)
* message; queue interface:              Message interface.   (line  91)
* message; types:                        Example interactive chatter.
                                                              (line  75)
* MessageClass (C type):                 Types<6>.            (line  34)
* MessageEmpty (C function):             Functions<3>.        (line  31)
* MessageFinish (C function):            Functions<3>.        (line  13)
* MessageInit (C function):              Functions<3>.        (line   6)
* MessagePost (C function):              Functions<3>.        (line  19)
* messages; design:                      References<7>.       (line  13)
* MessageType (C type):                  Concrete types.      (line 297)
* Method (C macro):                      Methods<3>.          (line   6)
* MFS pool class:                        LO interface.        (line  42)
* MFS pool class; design:                Attachment.          (line   8)
* MFS pool class; interface:             MFS properties.      (line  41)
* MFS pool class; properties:            MFS Manual Fixed Small.
                                                              (line  22)
* misaligned:                            Memory Management Glossary M.
                                                              (line 453)
* miss:                                  Memory Management Glossary M.
                                                              (line 457)
* miss rate:                             Memory Management Glossary M.
                                                              (line 478)
* ML:                                    Memory management in various languages.
                                                              (line 431)
* mmap:                                  Memory Management Glossary M.
                                                              (line 494)
* MMU:                                   Memory Management Glossary M.
                                                              (line 499)
* Modula-3:                              Memory management in various languages.
                                                              (line 465)
* monitor; design:                       References<8>.       (line   8)
* mostly-copying garbage collection:     Memory Management Glossary M.
                                                              (line 520)
* mostly-exact garbage collection:       Memory Management Glossary M.
                                                              (line 538)
* mostly-precise garbage collection:     Memory Management Glossary M.
                                                              (line 542)
* moving garbage collector:              Memory Management Glossary M.
                                                              (line 546)
* moving memory manager:                 Memory Management Glossary M.
                                                              (line 549)
* mps_addr_fmt (C function):             Object format introspection.
                                                              (line   6)
* mps_addr_object (C function):          Arena introspection and debugging.
                                                              (line  96)
* mps_addr_pool (C function):            Pool introspection.  (line  29)
* mps_addr_t (C type):                   General types.       (line   6)
* mps_align_t (C type):                  General types.       (line  18)
* mps_alloc (C function):                Manual allocation.   (line  14)
* mps_alloc_dbg (C function):            Client interface.    (line  36)
* mps_alloc_dbg_v (C function):          Client interface.    (line  39)
* mps_alloc_frame_class_stack (C function): External functions.
                                                              (line  39)
* mps_alloc_pattern_ramp (C function):   Ramp allocation.     (line  32)
* mps_alloc_pattern_ramp_collect_all (C function): Ramp allocation.
                                                              (line  43)
* mps_alloc_pattern_t (C type):          Allocation patterns. (line  13)
* mps_amc_apply (C function):            Deprecated in version 1 118.
                                                              (line 114)
* mps_amc_apply_stepper_t (C type):      Deprecated in version 1 118.
                                                              (line 149)
* mps_ap_addr_in_frame (C function):     External functions.  (line  26)
* mps_ap_alloc_pattern_begin (C function): Allocation patterns.
                                                              (line  17)
* mps_ap_alloc_pattern_end (C function): Allocation patterns. (line  50)
* mps_ap_alloc_pattern_reset (C function): Allocation patterns.
                                                              (line  71)
* mps_ap_create (C function):            Deprecated in version 1 112.
                                                              (line 172)
* mps_ap_create_k (C function):          Allocation points.   (line  17)
* mps_ap_create_v (C function):          Deprecated in version 1 112.
                                                              (line 189)
* mps_ap_destroy (C function):           Allocation points.   (line  39)
* mps_ap_fill (C function):              Allocation point implementation.
                                                              (line 130)
* mps_ap_frame_pop (C function):         Allocation frames.   (line  42)
* mps_ap_frame_push (C function):        Allocation frames.   (line  25)
* mps_ap_frame_select (C function):      External functions.  (line  14)
* mps_ap_frame_select_from_addr (C function): External functions.
                                                              (line  20)
* mps_ap_s (C type):                     Allocation point implementation.
                                                              (line 105)
* mps_ap_set_frame_class (C function):   External functions.  (line  33)
* mps_ap_t (C type):                     Allocation points.   (line  12)
* mps_ap_trip (C function):              Allocation point implementation.
                                                              (line 142)
* MPS_ARCH_A6 (C macro):                 Platform interface.  (line   8)
* MPS_ARCH_I3 (C macro):                 Platform interface.  (line  14)
* MPS_ARCH_I6 (C macro):                 Platform interface.  (line  20)
* mps_area_scan_t (C type):              Area scanners.       (line  19)
* mps_arena_busy (C function):           Arena introspection and debugging.
                                                              (line  20)
* mps_arena_clamp (C function):          Arena states.        (line  90)
* mps_arena_class_cl (C function):       Client arenas.       (line   8)
* mps_arena_class_t (C type):            Arenas.              (line  54)
* mps_arena_class_vm (C function):       Virtual memory arenas.
                                                              (line   8)
* mps_arena_collect (C function):        Running garbage collections.
                                                              (line  18)
* mps_arena_commit_limit (C function):   Arena properties.    (line  21)
* mps_arena_commit_limit_set (C function): Arena properties.  (line  62)
* mps_arena_committed (C function):      Arena properties.    (line  80)
* mps_arena_create (C function):         Deprecated in version 1 112.
                                                              (line   6)
* mps_arena_create_k (C function):       Arenas.              (line  58)
* mps_arena_create_v (C function):       Deprecated in version 1 112.
                                                              (line  32)
* mps_arena_destroy (C function):        Arenas.              (line  77)
* mps_arena_extend (C function):         Client arenas.       (line  74)
* mps_arena_formatted_objects_walk (C function): Deprecated in version 1 118.
                                                              (line  35)
* mps_arena_has_addr (C function):       Arena introspection and debugging.
                                                              (line  59)
* mps_arena_park (C function):           Arena states.        (line 107)
* mps_arena_pause_time (C function):     Arena properties.    (line 133)
* mps_arena_pause_time_set (C function): Arena properties.    (line 142)
* mps_arena_postmortem (C function):     Arena states.        (line 131)
* mps_arena_release (C function):        Arena states.        (line 122)
* mps_arena_reserved (C function):       Arena properties.    (line 199)
* mps_arena_roots_walk (C function):     Root introspection.  (line   6)
* mps_arena_spare (C function):          Arena properties.    (line 221)
* mps_arena_spare_commit_limit (C function): Deprecated in version 1 118.
                                                              (line  16)
* mps_arena_spare_commit_limit_set (C function): Deprecated in version 1 118.
                                                              (line  24)
* mps_arena_spare_committed (C function): Arena properties.   (line 246)
* mps_arena_spare_set (C function):      Arena properties.    (line 276)
* mps_arena_start_collect (C function):  Running garbage collections.
                                                              (line  41)
* mps_arena_step (C function):           Using idle time for collection.
                                                              (line  49)
* mps_arena_t (C type):                  Arenas.              (line  46)
* mps_arg_s (C type):                    Keyword arguments.   (line  44)
* MPS_ARGS_ADD (C macro):                Keyword arguments.   (line 209)
* MPS_ARGS_ADD_FIELD (C macro):          Keyword arguments.   (line 225)
* MPS_ARGS_BEGIN (C macro):              Keyword arguments.   (line 187)
* MPS_ARGS_DONE (C macro):               Deprecated in version 1 113.
                                                              (line   6)
* MPS_ARGS_END (C macro):                Keyword arguments.   (line 245)
* mps_args_none (C macro):               Keyword arguments.   (line  65)
* mps_awl_find_dependent_t (C type):     AWL interface.       (line  68)
* mps_bool_t (C type):                   General types.       (line  26)
* MPS_BUILD_GC (C macro):                Platform interface.  (line  28)
* MPS_BUILD_LL (C macro):                Platform interface.  (line  34)
* MPS_BUILD_MV (C macro):                Platform interface.  (line  40)
* mps_chain_create (C function):         Generation chains.   (line  88)
* mps_chain_destroy (C function):        Generation chains.   (line 109)
* mps_chain_t (C type):                  Generation chains.   (line  51)
* mps_class_amc (C function):            AMC interface.       (line   8)
* mps_class_amcz (C function):           AMCZ interface.      (line   8)
* mps_class_ams (C function):            AMS interface.       (line   8)
* mps_class_ams_debug (C function):      AMS interface.       (line  65)
* mps_class_awl (C function):            AWL interface.       (line   8)
* mps_class_lo (C function):             LO interface.        (line   8)
* mps_class_mfs (C function):            MFS interface.       (line   8)
* mps_class_mvff (C function):           MVFF interface.      (line   8)
* mps_class_mvff_debug (C function):     MVFF interface.      (line  70)
* mps_class_mvt (C function):            MVT interface.       (line   8)
* mps_class_snc (C function):            SNC interface.       (line   8)
* mps_class_t (C type):                  Deprecated in version 1 115.
                                                              (line   6)
* mps_clock (C function):                Library module.      (line   8)
* mps_clock_t (C type):                  General types.       (line  37)
* mps_clocks_per_sec (C function):       Library module.      (line  34)
* mps_collections (C function):          Arena properties.    (line   6)
* mps_commit (C function):               Allocation point protocol.
                                                              (line 160)
* mps_definalize (C function):           Finalization interface.
                                                              (line  27)
* mps_finalize (C function):             Finalization interface.
                                                              (line   6)
* MPS_FIX_CALL (C macro):                Scanning interface.  (line  58)
* MPS_FIX1 (C function):                 Fixing interface.    (line   6)
* MPS_FIX12 (C function):                Fixing interface.    (line  33)
* MPS_FIX2 (C function):                 Fixing interface.    (line  42)
* mps_fmt_A_s (C type):                  Deprecated in version 1 112.
                                                              (line 199)
* mps_fmt_adjust_fencepost_t (C type):   Client interface.    (line  18)
* mps_fmt_auto_header_s (C type):        Deprecated in version 1 112.
                                                              (line 258)
* mps_fmt_B_s (C type):                  Deprecated in version 1 112.
                                                              (line 229)
* mps_fmt_check_fenceposts_t (C type):   Client interface.    (line  30)
* mps_fmt_class_t (C type):              Format methods.      (line   6)
* mps_fmt_create_A (C function):         Deprecated in version 1 112.
                                                              (line 221)
* mps_fmt_create_auto_header (C function): Deprecated in version 1 112.
                                                              (line 279)
* mps_fmt_create_B (C function):         Deprecated in version 1 112.
                                                              (line 250)
* mps_fmt_create_fixed (C function):     Deprecated in version 1 112.
                                                              (line 308)
* mps_fmt_create_k (C function):         Interface.           (line  10)
* mps_fmt_destroy (C function):          Interface.           (line  85)
* mps_fmt_fencepost_wrap (C function):   Client interface.    (line  12)
* mps_fmt_fixed_s (C type):              Deprecated in version 1 112.
                                                              (line 288)
* mps_fmt_fwd_t (C type):                Format methods.      (line  19)
* mps_fmt_isfwd_t (C type):              Format methods.      (line  54)
* mps_fmt_pad_t (C type):                Format methods.      (line  71)
* mps_fmt_put_fencepost_t (C type):      Client interface.    (line  23)
* mps_fmt_scan_t (C type):               Format methods.      (line 101)
* mps_fmt_skip_t (C type):               Format methods.      (line 144)
* mps_fmt_t (C type):                    Interface.           (line   6)
* mps_formatted_objects_stepper_t (C type): Deprecated in version 1 118.
                                                              (line  76)
* mps_frame_class_t (C type):            External types<2>.   (line   9)
* mps_frame_t (C type):                  Allocation frames.   (line  21)
* mps_free (C function):                 Manual allocation.   (line  41)
* mps_fun_t (C type):                    General types.       (line  46)
* mps_gen_param_s (C type):              Generation chains.   (line  57)
* mps_io_create (C function):            I/O module.          (line  20)
* mps_io_destroy (C function):           I/O module.          (line  41)
* mps_io_flush (C function):             I/O module.          (line  70)
* mps_io_receive (C function):           Message send and receive.
                                                              (line  24)
* mps_io_send (C function):              Message send and receive.
                                                              (line   6)
* mps_io_t (C type):                     I/O module.          (line   8)
* mps_io_write (C function):             I/O module.          (line  54)
* MPS_KEY_SPARE_COMMIT_LIMIT (C macro):  Deprecated in version 1 118.
                                                              (line   6)
* mps_key_t (C type):                    Keyword arguments.   (line  72)
* mps_label_t (C type):                  General types.       (line  52)
* mps_ld_add (C function):               Location dependency interface.
                                                              (line  38)
* mps_ld_isstale (C function):           Location dependency interface.
                                                              (line  73)
* mps_ld_isstale_any (C function):       Location dependency interface.
                                                              (line 110)
* mps_ld_merge (C function):             Location dependency interface.
                                                              (line 137)
* mps_ld_reset (C function):             Location dependency interface.
                                                              (line 154)
* mps_ld_s (C type):                     Location dependency interface.
                                                              (line  23)
* mps_ld_t (C type):                     Location dependency interface.
                                                              (line   6)
* mps_lib_assert_fail (C function):      Library module.      (line  42)
* mps_lib_assert_fail_install (C function): Library module.   (line  61)
* mps_lib_assert_fail_t (C type):        Library module.      (line  82)
* mps_lib_FILE (C type):                 Library module.      (line  88)
* mps_lib_fputc (C function):            Library module.      (line  95)
* mps_lib_fputs (C function):            Library module.      (line 113)
* mps_lib_get_EOF (C function):          Library module.      (line 131)
* mps_lib_get_stderr (C function):       Library module.      (line 139)
* mps_lib_get_stdout (C function):       Library module.      (line 149)
* mps_lib_memcmp (C function):           Library module.      (line 159)
* mps_lib_memcpy (C function):           Library module.      (line 180)
* mps_lib_memset (C function):           Library module.      (line 204)
* mps_lib_telemetry_control (C function): Library module.     (line 227)
* mps_message_clock (C function):        Message interface.   (line  21)
* mps_message_discard (C function):      Message interface.   (line  52)
* mps_message_finalization_ref (C function): Finalization messages<2>.
                                                              (line  30)
* mps_message_gc_condemned_size (C function): Garbage collection messages.
                                                              (line  37)
* mps_message_gc_live_size (C function): Garbage collection messages.
                                                              (line  57)
* mps_message_gc_not_condemned_size (C function): Garbage collection messages.
                                                              (line  77)
* mps_message_gc_start_why (C function): Garbage collection start messages.
                                                              (line  26)
* mps_message_get (C function):          Message queue interface.
                                                              (line   6)
* mps_message_poll (C function):         Message queue interface.
                                                              (line  26)
* mps_message_queue_type (C function):   Message queue interface.
                                                              (line  40)
* mps_message_t (C type):                Message interface.   (line   6)
* mps_message_type (C function):         Message interface.   (line  82)
* mps_message_type_disable (C function): Message types.       (line  18)
* mps_message_type_enable (C function):  Message types.       (line  37)
* mps_message_type_finalization (C function): Finalization messages<2>.
                                                              (line   6)
* mps_message_type_gc (C function):      Garbage collection messages.
                                                              (line   6)
* mps_message_type_gc_start (C function): Garbage collection start messages.
                                                              (line   6)
* mps_message_type_t (C type):           Message types.       (line   6)
* mps_mvff_free_size (C function):       Deprecated in version 1 115.
                                                              (line  11)
* mps_mvff_size (C function):            Deprecated in version 1 115.
                                                              (line  21)
* mps_mvt_free_size (C function):        Deprecated in version 1 115.
                                                              (line  32)
* mps_mvt_size (C function):             Deprecated in version 1 115.
                                                              (line  42)
* mps_objects_step_t (C type):           Client interface.    (line  46)
* MPS_OS_FR (C macro):                   Platform interface.  (line  46)
* MPS_OS_LI (C macro):                   Platform interface.  (line  51)
* MPS_OS_W3 (C macro):                   Platform interface.  (line  56)
* MPS_OS_XC (C macro):                   Platform interface.  (line  61)
* mps_peak_close (C function):           Peaks.               (line  32)
* mps_peak_create (C function):          Peaks.               (line   6)
* mps_peak_describe_pool (C function):   Peaks.               (line  13)
* mps_peak_destroy (C function):         Peaks.               (line  46)
* MPS_PF_ALIGN (C macro):                Platform interface.  (line  66)
* MPS_PF_FRI3GC (C macro):               Platform interface.  (line  71)
* MPS_PF_FRI3LL (C macro):               Platform interface.  (line  77)
* MPS_PF_FRI6GC (C macro):               Platform interface.  (line  83)
* MPS_PF_FRI6LL (C macro):               Platform interface.  (line  89)
* MPS_PF_LIA6GC (C macro):               Platform interface.  (line  95)
* MPS_PF_LIA6LL (C macro):               Platform interface.  (line 101)
* MPS_PF_LII3GC (C macro):               Platform interface.  (line 107)
* MPS_PF_LII6GC (C macro):               Platform interface.  (line 113)
* MPS_PF_LII6LL (C macro):               Platform interface.  (line 119)
* MPS_PF_STRING (C macro):               Platform interface.  (line 125)
* MPS_PF_W3I3MV (C macro):               Platform interface.  (line 130)
* MPS_PF_W3I6MV (C macro):               Platform interface.  (line 137)
* MPS_PF_XCA6LL (C macro):               Platform interface.  (line 144)
* MPS_PF_XCI3GC (C macro):               Platform interface.  (line 150)
* MPS_PF_XCI3LL (C macro):               Platform interface.  (line 156)
* MPS_PF_XCI6GC (C macro):               Platform interface.  (line 162)
* MPS_PF_XCI6LL (C macro):               Platform interface.  (line 168)
* mps_pool_check_fenceposts (C function): Debugging pools.    (line 111)
* mps_pool_check_free_space (C function): Debugging pools.    (line 121)
* mps_pool_class_t (C type):             Pool classes.        (line  14)
* mps_pool_create (C function):          Deprecated in version 1 112.
                                                              (line  42)
* mps_pool_create_k (C function):        Pools.               (line  18)
* mps_pool_create_v (C function):        Deprecated in version 1 112.
                                                              (line 161)
* mps_pool_debug_option_s (C type):      Debugging pools.     (line  70)
* mps_pool_destroy (C function):         Pools.               (line  40)
* mps_pool_free_size (C function):       Pool introspection.  (line  18)
* mps_pool_t (C type):                   Pools.               (line  10)
* mps_pool_total_size (C function):      Pool introspection.  (line   6)
* mps_pool_walk (C function):            Pool introspection.  (line  70)
* mps_rank_ambig (C function):           Ranks.               (line  11)
* mps_rank_exact (C function):           Ranks.               (line  15)
* mps_rank_t (C type):                   Ranks.               (line   6)
* mps_rank_weak (C function):            Ranks.               (line  19)
* mps_reg_scan_t (C type):               Deprecated in version 1 115.
                                                              (line 214)
* MPS_RES_COMMIT_LIMIT (C macro):        Result codes.        (line   6)
* MPS_RES_FAIL (C macro):                Result codes.        (line  17)
* MPS_RES_IO (C macro):                  Result codes.        (line  22)
* MPS_RES_LIMIT (C macro):               Result codes.        (line  27)
* MPS_RES_MEMORY (C macro):              Result codes.        (line  33)
* MPS_RES_OK (C macro):                  Result codes.        (line  52)
* MPS_RES_PARAM (C macro):               Result codes.        (line  63)
* MPS_RES_RESOURCE (C macro):            Result codes.        (line  69)
* mps_res_t (C type):                    Error handing.       (line  28)
* MPS_RES_UNIMPL (C macro):              Result codes.        (line  83)
* mps_reserve (C function):              Allocation point protocol.
                                                              (line 102)
* MPS_RESERVE_BLOCK (C macro):           Allocation point protocol.
                                                              (line 148)
* MPS_RM_CONST (C macro):                Root modes.          (line  24)
* MPS_RM_PROT (C macro):                 Root modes.          (line  44)
* MPS_RM_PROT_INNER (C macro):           Root modes.          (line  65)
* mps_rm_t (C type):                     Root modes.          (line  16)
* mps_root_create (C function):          Root interface.      (line  13)
* mps_root_create_area (C function):     Root interface.      (line 249)
* mps_root_create_area_tagged (C function): Root interface.   (line 286)
* mps_root_create_fmt (C function):      Root interface.      (line  69)
* mps_root_create_reg (C function):      Deprecated in version 1 115.
                                                              (line  53)
* mps_root_create_table (C function):    Deprecated in version 1 115.
                                                              (line  96)
* mps_root_create_table_masked (C function): Deprecated in version 1 115.
                                                              (line 199)
* mps_root_create_table_tagged (C function): Deprecated in version 1 115.
                                                              (line 148)
* mps_root_create_thread (C function):   Root interface.      (line 102)
* mps_root_create_thread_scanned (C function): Root interface.
                                                              (line 207)
* mps_root_create_thread_tagged (C function): Root interface. (line 121)
* mps_root_destroy (C function):         Root interface.      (line 352)
* mps_root_scan_t (C type):              Root interface.      (line  48)
* mps_root_t (C type):                   Root interface.      (line   6)
* mps_roots_stepper_t (C type):          Root introspection.  (line  47)
* mps_sac_alloc (C function):            Allocation interface.
                                                              (line   6)
* MPS_SAC_ALLOC_FAST (C macro):          Allocation interface.
                                                              (line  68)
* MPS_SAC_CLASS_LIMIT (C macro):         Cache interface.     (line  10)
* mps_sac_class_s (C type):              Cache interface.     (line  20)
* mps_sac_create (C function):           Cache interface.     (line  52)
* mps_sac_destroy (C function):          Cache interface.     (line 126)
* mps_sac_flush (C function):            Cache interface.     (line 138)
* mps_sac_free (C function):             Allocation interface.
                                                              (line  81)
* MPS_SAC_FREE_FAST (C macro):           Allocation interface.
                                                              (line 117)
* mps_sac_t (C type):                    Cache interface.     (line   6)
* mps_scan_area (C function):            Area scanners.       (line  51)
* mps_scan_area_masked (C function):     Area scanners.       (line  87)
* mps_scan_area_tagged (C function):     Area scanners.       (line 105)
* mps_scan_area_tagged_or_zero (C function): Area scanners.   (line 128)
* MPS_SCAN_BEGIN (C macro):              Scanning interface.  (line  19)
* MPS_SCAN_END (C macro):                Scanning interface.  (line  37)
* mps_scan_tag_s (C type):               Area scanners.       (line  68)
* mps_scan_tag_t (C type):               Area scanners.       (line  60)
* mps_ss_t (C type):                     Scanning interface.  (line   6)
* mps_stack_scan_ambig (C var):          Deprecated in version 1 115.
                                                              (line 249)
* MPS_T_ULONGEST (C macro):              Platform interface.  (line 174)
* MPS_T_WORD (C macro):                  Platform interface.  (line 182)
* MPS_TELEMETRY_CONTROL:                 Telemetry.           (line  11)
* MPS_TELEMETRY_CONTROL <1>:             Telemetry labels.    (line  59)
* MPS_TELEMETRY_CONTROL <2>:             Telemetry labels.    (line  79)
* MPS_TELEMETRY_CONTROL <3>:             Library module.      (line 230)
* MPS_TELEMETRY_CONTROL <4>:             Library module.      (line 236)
* MPS_TELEMETRY_CONTROL <5>:             Library module.      (line 243)
* MPS_TELEMETRY_CONTROL <6>:             Telemetry<2>.        (line  10)
* MPS_TELEMETRY_CONTROL <7>:             Interface changes<8>.
                                                              (line  10)
* MPS_TELEMETRY_CONTROL <8>:             New features<9>.     (line  57)
* MPS_TELEMETRY_DATABASE:                Loading the telemetry stream into SQLite.
                                                              (line  22)
* MPS_TELEMETRY_FILENAME:                Telemetry.           (line  13)
* MPS_TELEMETRY_FILENAME <1>:            I/O module.          (line  38)
* MPS_TELEMETRY_FILENAME <2>:            Telemetry<2>.        (line  12)
* MPS_TELEMETRY_FILENAME <3>:            New features<9>.     (line  62)
* mps_telemetry_flush (C function):      Telemetry interface. (line   6)
* mps_telemetry_get (C function):        Telemetry interface. (line  24)
* mps_telemetry_intern (C function):     Telemetry labels.    (line  40)
* mps_telemetry_label (C function):      Telemetry labels.    (line  63)
* mps_telemetry_reset (C function):      Telemetry interface. (line  35)
* mps_telemetry_set (C function):        Telemetry interface. (line  28)
* mps_thr_t (C type):                    Thread interface.    (line   6)
* mps_thread_dereg (C function):         Thread interface.    (line  43)
* mps_thread_reg (C function):           Thread interface.    (line  20)
* mps_transform_add_oldnew (C function): Interface<2>.        (line  34)
* mps_transform_apply (C function):      Interface<2>.        (line  59)
* mps_transform_create (C function):     Interface<2>.        (line  13)
* mps_transform_destroy (C function):    Interface<2>.        (line  95)
* mps_transform_t (C type):              Interface<2>.        (line   8)
* MPS_WORD_SHIFT (C macro):              Platform interface.  (line 191)
* mps_word_t (C type):                   General types.       (line  58)
* MPS_WORD_WIDTH (C macro):              Platform interface.  (line 199)
* mpseventcnv command line option; -f:   Decoding the telemetry stream.
                                                              (line  15)
* mpseventcnv command line option; -h:   Decoding the telemetry stream.
                                                              (line  20)
* mpseventsql command line option; -d:   Loading the telemetry stream into SQLite.
                                                              (line  29)
* mpseventsql command line option; -f:   Loading the telemetry stream into SQLite.
                                                              (line  33)
* mpseventsql command line option; -i:   Loading the telemetry stream into SQLite.
                                                              (line  12)
* mpseventsql command line option; -o:   Loading the telemetry stream into SQLite.
                                                              (line  17)
* mpseventsql command line option; -p:   Loading the telemetry stream into SQLite.
                                                              (line  48)
* mpseventsql command line option; -r:   Loading the telemetry stream into SQLite.
                                                              (line  57)
* mpseventsql command line option; -t:   Loading the telemetry stream into SQLite.
                                                              (line  53)
* mpseventsql command line option; -v:   Loading the telemetry stream into SQLite.
                                                              (line  39)
* mpseventtxt command line option; -h:   Making the telemetry stream readable.
                                                              (line  14)
* mpseventtxt command line option; -l:   Making the telemetry stream readable.
                                                              (line   9)
* MRG pool class; design:                Implementation<23>.  (line  26)
* MRGCheck (C function):                 Functions<10>.       (line   6)
* MRGDeregister (C function):            Functions<10>.       (line  38)
* MRGDescribe (C function):              Functions<10>.       (line 122)
* MRGFinish (C function):                Functions<10>.       (line  68)
* MRGInit (C function):                  Functions<10>.       (line  57)
* mrgRefSegScan (C function):            Functions<10>.       (line  73)
* MRGRegister (C function):              Functions<10>.       (line  15)
* MustBeA (C macro):                     Conversion.          (line  11)
* MustBeA_CRITICAL (C macro):            Conversion.          (line  26)
* mutable:                               Memory Management Glossary M.
                                                              (line 562)
* mutator:                               Memory Management Glossary M.
                                                              (line 569)
* mutator context; design:               Methods.             (line 121)
* MutatorContext (C type):               Interface<10>.       (line  21)
* MutatorContextCanStepInstruction (C function): Interface<10>.
                                                              (line  51)
* MutatorContextCheck (C function):      Interface<10>.       (line  29)
* MutatorContextInitFault (C function):  Interface<10>.       (line  35)
* MutatorContextInitThread (C function): Interface<10>.       (line  43)
* MutatorContextScan (C function):       Interface<10>.       (line  72)
* MutatorContextSP (C function):         Interface<10>.       (line  79)
* MutatorContextStepInstruction (C function): Interface<10>.  (line  59)
* MutatorContextVar (C type):            Interface<10>.       (line   6)
* MVFF pool class:                       MFS interface.       (line  37)
* MVFF pool class; design:               Text.                (line  14)
* MVFF pool class; interface:            MVFF properties.     (line  43)
* MVFF pool class; properties:           MVFF Manual Variable First Fit.
                                                              (line  35)
* MVT pool class:                        MVFF interface.      (line  82)
* MVT pool class; design:                Notes<8>.            (line  13)
* MVT pool class; interface:             MVT properties.      (line  43)
* MVT pool class; properties:            Temporal fit.        (line  33)
* MVT pool class; temporal fit:          MVT Manual Variable Temporal.
                                                              (line   9)
* nailboard; design:                     References<9>.       (line  11)
* nailing:                               Memory Management Glossary N.
                                                              (line  13)
* natural alignment:                     Memory Management Glossary N.
                                                              (line  15)
* nepotism:                              Memory Management Glossary N.
                                                              (line  34)
* new space:                             Memory Management Glossary N.
                                                              (line  79)
* newspace:                              Memory Management Glossary N.
                                                              (line  82)
* next fit:                              Memory Management Glossary N.
                                                              (line  53)
* NextMethod (C macro):                  Methods<3>.          (line  15)
* node:                                  Memory Management Glossary N.
                                                              (line  85)
* non-moving garbage collector:          Memory Management Glossary N.
                                                              (line  99)
* non-moving memory manager:             Memory Management Glossary N.
                                                              (line 100)
* nursery generation:                    Memory Management Glossary N.
                                                              (line 110)
* nursery space:                         Memory Management Glossary N.
                                                              (line 114)
* object:                                Memory Management Glossary O.
                                                              (line  13)
* object format:                         Choosing a pool class.
                                                              (line  31)
* object format <1>:                     Memory Management Glossary O.
                                                              (line  27)
* object format; cautions:               In-band headers.     (line  54)
* object format; format method:          Cautions<2>.         (line  73)
* object format; headers:                Interface.           (line  93)
* object format; in-band headers:        Interface.           (line  94)
* object format; interface:              Object formats.      (line  30)
* object format; introduction:           Allocation point implementation.
                                                              (line 154)
* object format; introspection:          Format methods.      (line 170)
* object format; scan method:            Object format introspection.
                                                              (line  38)
* object pointer:                        Memory Management Glossary O.
                                                              (line  37)
* off-white:                             Memory Management Glossary O.
                                                              (line  46)
* old space:                             Memory Management Glossary O.
                                                              (line  64)
* oldspace:                              Memory Management Glossary O.
                                                              (line  65)
* one-bit reference count:               Memory Management Glossary O.
                                                              (line  68)
* opaque type:                           Memory Management Glossary O.
                                                              (line 111)
* out parameter:                         Memory Management Glossary O.
                                                              (line 122)
* out-of-band header:                    Memory Management Glossary O.
                                                              (line 132)
* overcommit:                            Memory Management Glossary O.
                                                              (line 141)
* overwriting error:                     Memory Management Glossary O.
                                                              (line 157)
* padding:                               Memory Management Glossary P.
                                                              (line  13)
* padding method:                        The is-forwarded method.
                                                              (line  30)
* padding method <1>:                    Memory Management Glossary P.
                                                              (line  20)
* padding object:                        Memory Management Glossary P.
                                                              (line  26)
* page:                                  Memory Management Glossary P.
                                                              (line  32)
* page fault:                            Memory Management Glossary P.
                                                              (line  41)
* page marking:                          Memory Management Glossary P.
                                                              (line  61)
* page protection:                       Memory Management Glossary P.
                                                              (line  64)
* page table:                            Memory Management Glossary P.
                                                              (line  72)
* paged in:                              Memory Management Glossary P.
                                                              (line 101)
* paged out:                             Memory Management Glossary P.
                                                              (line 116)
* PageSize (C function):                 Interface<19>.       (line  13)
* paging:                                Memory Management Glossary P.
                                                              (line 131)
* palimpsest:                            Memory Management Glossary P.
                                                              (line 148)
* parallel garbage collection:           Memory Management Glossary P.
                                                              (line 164)
* parked state:                          Arena states.        (line  25)
* parked state <1>:                      Memory Management Glossary P.
                                                              (line 186)
* Pascal:                                Memory management in various languages.
                                                              (line 475)
* path; critical:                        References.          (line  12)
* pause; limiting:                       Running garbage collections.
                                                              (line  60)
* perfect fit:                           Memory Management Glossary P.
                                                              (line 196)
* performance:                           What next?<3>.       (line  12)
* Perl:                                  Memory management in various languages.
                                                              (line 494)
* phantom reachable:                     Memory Management Glossary P.
                                                              (line 210)
* phantom reference:                     Memory Management Glossary P.
                                                              (line 237)
* phantomly reachable:                   Memory Management Glossary P.
                                                              (line 211)
* physical address:                      Memory Management Glossary P.
                                                              (line 255)
* physical address space:                Memory Management Glossary P.
                                                              (line 269)
* physical memory (1):                   Memory Management Glossary P.
                                                              (line 276)
* physical memory (2):                   Memory Management Glossary P.
                                                              (line 295)
* physical storage:                      Memory Management Glossary P.
                                                              (line 307)
* pig in the python:                     Memory Management Glossary P.
                                                              (line 311)
* pig in the snake:                      Memory Management Glossary P.
                                                              (line 341)
* pinning:                               Memory Management Glossary P.
                                                              (line 345)
* placement policy:                      Memory Management Glossary P.
                                                              (line 355)
* platform:                              Memory Management Glossary P.
                                                              (line 359)
* platform; code:                        Platforms<2>.        (line   6)
* platform; historical codes:            Platform interface.  (line 207)
* platform; historical list:             Historical platform codes.
                                                              (line  99)
* platform; interface:                   Platform codes.      (line  66)
* platform; limitations:                 Historical platform list.
                                                              (line 127)
* platforms; supported:                  Overview of the Memory Pool System.
                                                              (line  22)
* plinth:                                Memory Management Glossary P.
                                                              (line 365)
* plinth; I/O module:                    Plinth.              (line  62)
* plinth; introduction:                  Interface<2>.        (line 102)
* plinth; library module:                I/O module.          (line  89)
* pointer:                               Memory Management Glossary P.
                                                              (line 372)
* Pointer (C type):                      Abstract types.      (line  17)
* PolicyAlloc (C function):              Assignment of zones. (line   6)
* PolicyPoll (C function):               Trace progress.      (line   6)
* PolicyPollAgain (C function):          Trace progress.      (line  11)
* PolicyShouldCollectWorld (C function): Deciding whether to collect the world.
                                                              (line   6)
* PolicyStartTrace (C function):         Starting a trace.    (line   6)
* pool:                                  Memory Management Glossary P.
                                                              (line 393)
* pool class:                            Pools.               (line  74)
* pool class <1>:                        Memory Management Glossary P.
                                                              (line 400)
* pool class; AMC:                       Writing a new pool class.
                                                              (line  17)
* pool class; AMC design:                Implementation<21>.  (line  34)
* pool class; AMCZ:                      Hash arrays.         (line  46)
* pool class; AMS:                       AMCZ interface.      (line  40)
* pool class; AMS design:                Old and aging notes below here.
                                                              (line  86)
* pool class; AWL:                       AMS interface.       (line  74)
* pool class; AWL design:                Notes<7>.            (line  17)
* pool class; choosing:                  Choosing an arena class.
                                                              (line  75)
* pool class; choosing <1>:              Pool reference.      (line   6)
* pool class; LO:                        AWL interface.       (line  82)
* pool class; LO design:                 Test.                (line  26)
* pool class; MFS:                       LO interface.        (line  41)
* pool class; MFS design:                Attachment.          (line   7)
* pool class; MRG design:                Implementation<23>.  (line  25)
* pool class; MVFF:                      MFS interface.       (line  36)
* pool class; MVFF design:               Text.                (line  13)
* pool class; MVT:                       MVFF interface.      (line  81)
* pool class; MVT design:                Notes<8>.            (line  12)
* pool class; SNC:                       MVT interface.       (line  99)
* pool class; table of properties:       Choosing a manual pool class.
                                                              (line  17)
* pool class; writing:                   Pool class properties.
                                                              (line 143)
* pool classes; design:                  References<10>.      (line   9)
* pool; creating:                        The padding method.  (line  63)
* pool; creating <1>:                    Arena extension callbacks.
                                                              (line  77)
* pool; debugging:                       Allocation frames.   (line  80)
* pool; introspection:                   Pool classes.        (line  17)
* PoolAllocMethod (C type):              Methods.             (line  53)
* PoolBufferClassMethod (C type):        Methods.             (line  81)
* PoolBufferEmptyMethod (C type):        Methods.             (line 101)
* PoolBufferFillMethod (C type):         Methods.             (line  88)
* PoolFrameHasAddrMethod (C type):       Internal types.      (line  41)
* PoolFramePopMethod (C type):           Internal types.      (line  22)
* PoolFramePushMethod (C type):          Internal types.      (line  16)
* PoolFrameSelectFromAddrMethod (C type): Internal types.     (line  34)
* PoolFrameSelectMethod (C type):        Internal types.      (line  28)
* PoolFreeMethod (C type):               Methods.             (line  67)
* PoolInitMethod (C type):               Methods.             (line  44)
* PoolSetFrameClassMethod (C type):      Internal types.      (line  48)
* PoolSizeMethod (C type):               Methods.             (line 111)
* PoolVarargsMethod (C type):            Methods.             (line  36)
* porting; plinth:                       Interface<2>.        (line 101)
* POSIX protection interface; design:    Implementations<3>.  (line  60)
* POSIX thread extensions; design:       References<23>.      (line  16)
* POSIX; protection interface design:    Implementations<3>.  (line  61)
* postmortem debugging:                  General debugging advice.
                                                              (line  84)
* postmortem state:                      General debugging advice.
                                                              (line  84)
* postmortem state <1>:                  Arena states.        (line  29)
* postmortem state <2>:                  Memory Management Glossary P.
                                                              (line 406)
* PostScript:                            Memory management in various languages.
                                                              (line 515)
* precise garbage collection:            Memory Management Glossary P.
                                                              (line 418)
* precise reference:                     Memory Management Glossary P.
                                                              (line 422)
* precise root:                          Memory Management Glossary P.
                                                              (line 426)
* premature free:                        Memory Management Glossary P.
                                                              (line 430)
* premature promotion:                   Memory Management Glossary P.
                                                              (line 450)
* premature tenuring:                    Memory Management Glossary P.
                                                              (line 452)
* primary storage:                       Memory Management Glossary P.
                                                              (line 479)
* Prolog:                                Memory management in various languages.
                                                              (line 534)
* promotion:                             Memory Management Glossary P.
                                                              (line 483)
* protectable root:                      Memory Management Glossary P.
                                                              (line 501)
* protected:                             Memory Management Glossary P.
                                                              (line 507)
* protection:                            Memory Management Glossary P.
                                                              (line 514)
* protection exception:                  Memory Management Glossary P.
                                                              (line 541)
* protection fault:                      Memory Management Glossary P.
                                                              (line 545)
* protection violation:                  Memory Management Glossary P.
                                                              (line 564)
* ProtGranularity (C function):          Interface<11>.       (line  13)
* protocol inheritance; design:          Details.             (line  14)
* ProtSet (C function):                  Interface<11>.       (line  19)
* ProtSetup (C function):                Interface<11>.       (line   6)
* ProtSync (C function):                 Interface<11>.       (line  36)
* PThreadext (C type):                   Interface<28>.       (line   6)
* PThreadextCheck (C function):          Interface<28>.       (line  27)
* PThreadextFinish (C function):         Interface<28>.       (line  52)
* PThreadextInit (C function):           Interface<28>.       (line  21)
* PThreadextResume (C function):         Interface<28>.       (line  43)
* PThreadextStruct (C type):             Implementation<28>.  (line   6)
* PThreadextSuspend (C function):        Interface<28>.       (line  33)
* punning; type:                         Functions.           (line  34)
* Python:                                Memory management in various languages.
                                                              (line 548)
* quadword:                              Memory Management Glossary Q.
                                                              (line  13)
* RAM:                                   Memory Management Glossary R.
                                                              (line  13)
* ramp allocation:                       Allocation patterns. (line  86)
* ramp allocation <1>:                   Memory Management Glossary R.
                                                              (line  29)
* random access memory:                  Memory Management Glossary R.
                                                              (line  27)
* Range (C type):                        Interface<12>.       (line   6)
* RangeBase (C function):                Interface<12>.       (line  36)
* RangeContains (C function):            Interface<12>.       (line  63)
* RangeCopy (C function):                Interface<12>.       (line  19)
* RangeFinish (C function):              Interface<12>.       (line  29)
* RangeInit (C function):                Interface<12>.       (line  13)
* RangeInitSize (C function):            Interface<12>.       (line  23)
* RangeIsAligned (C function):           Interface<12>.       (line  75)
* RangeIsEmpty (C function):             Interface<12>.       (line  69)
* RangeLimit (C function):               Interface<12>.       (line  41)
* RangeSetBase (C function):             Interface<12>.       (line  46)
* RangeSetLimit (C function):            Interface<12>.       (line  52)
* RangeSize (C function):                Interface<12>.       (line  58)
* RangesNest (C function):               Interface<12>.       (line  88)
* RangesOverlap (C function):            Interface<12>.       (line  81)
* rank:                                  Memory Management Glossary R.
                                                              (line  37)
* Rank (C type):                         Concrete types.      (line 316)
* RankSet (C type):                      Concrete types.      (line 359)
* rash:                                  Memory Management Glossary R.
                                                              (line  44)
* rash variety:                          Varieties.           (line  38)
* Ravenbrook Limited:                    Guide.               (line   6)
* raw:                                   Memory Management Glossary R.
                                                              (line  51)
* reachable:                             Memory Management Glossary R.
                                                              (line  54)
* read barrier:                          Memory Management Glossary R.
                                                              (line  95)
* read fault:                            Memory Management Glossary R.
                                                              (line 111)
* read-only memory:                      Memory Management Glossary R.
                                                              (line 126)
* ReadonlyAddr (C type):                 Concrete types.      (line 364)
* real memory (1):                       Memory Management Glossary R.
                                                              (line 128)
* real memory (2):                       Memory Management Glossary R.
                                                              (line 140)
* reclaim:                               Memory Management Glossary R.
                                                              (line 144)
* recycle:                               Memory Management Glossary R.
                                                              (line 155)
* Ref (C type):                          Concrete types.      (line 370)
* reference:                             Memory Management Glossary R.
                                                              (line 168)
* reference counting:                    Memory Management Glossary R.
                                                              (line 194)
* reference object:                      Memory Management Glossary R.
                                                              (line 274)
* RefSet (C type):                       Concrete types.      (line 378)
* region inference:                      Memory Management Glossary R.
                                                              (line 313)
* register:                              Memory Management Glossary R.
                                                              (line 329)
* register set partitioning:             Memory Management Glossary R.
                                                              (line 347)
* relocation:                            Memory Management Glossary R.
                                                              (line 373)
* remembered set:                        Memory Management Glossary R.
                                                              (line 393)
* remote reference:                      Memory Management Glossary R.
                                                              (line 411)
* replicating garbage collector:         Memory Management Glossary R.
                                                              (line 424)
* Res (C type):                          Concrete types.      (line 383)
* reserved:                              Memory Management Glossary R.
                                                              (line 444)
* resident:                              Memory Management Glossary R.
                                                              (line 469)
* resident set:                          Memory Management Glossary R.
                                                              (line 483)
* result code:                           Keyword arguments.   (line 253)
* result code <1>:                       Memory Management Glossary R.
                                                              (line 489)
* resurrection:                          Memory Management Glossary R.
                                                              (line 496)
* retention:                             Memory Management Glossary R.
                                                              (line 510)
* review; checklist:                     Suffixes.            (line  26)
* Ring (C type):                         Description.         (line   6)
* ring structure; design:                Interface<12>.       (line  92)
* RING_ELT (C macro):                    Element access.      (line  16)
* RING_FOR (C macro):                    Iteration.           (line   6)
* RingAppend (C function):               Append / Remove.     (line   6)
* RingCheck (C function):                Checking<2>.         (line   6)
* RingCheckSingle (C function):          Checking<2>.         (line  11)
* RingFinish (C function):               Init / Finish.       (line  12)
* RingInit (C function):                 Init / Finish.       (line   6)
* RingInsert (C function):               Append / Remove.     (line  12)
* RingIsSingle (C function):             Checking<2>.         (line  17)
* RingLength (C function):               Checking<2>.         (line  22)
* RingNext (C function):                 Element access.      (line   6)
* RingPrev (C function):                 Element access.      (line  11)
* RingRemove (C function):               Append / Remove.     (line  18)
* ROM:                                   Memory Management Glossary R.
                                                              (line 518)
* root:                                  Memory Management Glossary R.
                                                              (line 533)
* root description:                      Memory Management Glossary R.
                                                              (line 550)
* root manager; design:                  References<24>.      (line  11)
* root mode:                             Memory Management Glossary R.
                                                              (line 556)
* root set:                              Memory Management Glossary R.
                                                              (line 563)
* root; cautions:                        Registering roots.   (line  70)
* root; creating:                        Creating the pool.   (line  34)
* root; interface:                       Root modes.          (line  73)
* root; introduction:                    Thread interface.    (line  60)
* root; introspection:                   Root interface.      (line 357)
* root; mode:                            Ranks.               (line  22)
* root; rank:                            Thread roots.        (line  36)
* root; registering:                     Roots<2>.            (line  21)
* root; thread:                          Cautions<3>.         (line  29)
* RootMode (C type):                     Concrete types.      (line 449)
* RootVar (C type):                      Concrete types.      (line 484)
* sbrk:                                  Memory Management Glossary S.
                                                              (line  13)
* scalar data type:                      Memory Management Glossary S.
                                                              (line  22)
* scan:                                  Memory Management Glossary S.
                                                              (line  48)
* scan method:                           Alignment.           (line  46)
* scan method <1>:                       Memory Management Glossary S.
                                                              (line  58)
* scan state:                            Memory Management Glossary S.
                                                              (line  65)
* scanning; ambiguous reference:         Critical path.       (line  42)
* scanning; area scanners:               Fixing interface.    (line  77)
* scanning; critical path:               Tagged references.   (line  45)
* scanning; example:                     Unfixed references.  (line  23)
* scanning; fixing:                      Scanning interface.  (line 111)
* scanning; interface:                   Example Scheme objects.
                                                              (line  70)
* scanning; introduction:                Object format introspection.
                                                              (line  39)
* scanning; protocol:                    Scanning.            (line  28)
* scanning; tagged reference:            Scanning protocol.   (line  42)
* scanning; unfixed reference:           Ambiguous references.
                                                              (line  20)
* scavenging garbage collection:         Memory Management Glossary S.
                                                              (line  72)
* Scheme:                                Memory management in various languages.
                                                              (line 572)
* Scheme; address-based hash table:      Finalization.        (line 162)
* Scheme; allocation:                    Threads.             (line  46)
* Scheme; finalization:                  Advanced topics.     (line   6)
* Scheme; forward method:                The skip method.     (line  37)
* Scheme; global symbol table:           Weak hash tables.    (line 253)
* Scheme; interactive chatter:           Finalization messages.
                                                              (line  17)
* Scheme; is-forwarded method:           The forward method.  (line 104)
* Scheme; location dependency:           Finalization.        (line 161)
* Scheme; object alignment:              Describing your objects.
                                                              (line  30)
* Scheme; object format:                 Choosing a pool class.
                                                              (line  30)
* Scheme; padding method:                The is-forwarded method.
                                                              (line  29)
* Scheme; pool:                          The padding method.  (line  62)
* Scheme; ports:                         Advanced topics.     (line   6)
* Scheme; root:                          Creating the pool.   (line  33)
* Scheme; scan method:                   Alignment.           (line  45)
* Scheme; scanning:                      Unfixed references.  (line  22)
* Scheme; segregation:                   Global symbol table. (line 100)
* Scheme; skip method:                   The scan method.     (line  94)
* Scheme; telemetry:                     Telemetry utilities. (line  25)
* Scheme; thread:                        Roots.               (line 193)
* Scheme; thread root:                   Thread roots.        (line  18)
* Scheme; toy interpreter:               Garbage collecting a language with the Memory Pool System.
                                                              (line  20)
* Scheme; weak hash table:               Location dependency. (line 246)
* SDRAM:                                 Memory Management Glossary S.
                                                              (line  76)
* security issues:                       Deprecated in version 1 112.
                                                              (line 315)
* security issues; address disclosure:   Predictable address space layout on FreeBSD.
                                                              (line  26)
* security issues; predictable address space layout on FreeBSD: Security issues.
                                                              (line   9)
* security issues; telemetry:            Address disclosure.  (line  27)
* Seg (C type):                          Data Structure.      (line   6)
* SegAccessMethod (C type):              Garbage collection<2>.
                                                              (line   6)
* SegBlackenMethod (C type):             Garbage collection<2>.
                                                              (line  49)
* SegBufferEmptyMethod (C type):         Allocation<6>.       (line  16)
* SegBufferFillMethod (C type):          Allocation<6>.       (line   6)
* SegFixMethod (C type):                 Garbage collection<2>.
                                                              (line  76)
* SegFlipMethod (C type):                Garbage collection<2>.
                                                              (line 133)
* SegGreyenMethod (C type):              Garbage collection<2>.
                                                              (line  36)
* segmentation violation:                Memory Management Glossary S.
                                                              (line  85)
* segmented addressing:                  Memory Management Glossary S.
                                                              (line  99)
* segments; design:                      Partial scans.       (line  62)
* SegMerge (C function):                 Splitting and merging.
                                                              (line  41)
* SegMergeMethod (C type):               Splitting and merging<2>.
                                                              (line  28)
* SegReclaimMethod (C type):             Garbage collection<2>.
                                                              (line 103)
* segregated allocation cache:           Location dependency interface.
                                                              (line 170)
* segregated allocation cache <1>:       Memory Management Glossary S.
                                                              (line 128)
* segregated allocation cache; allocation: Cache interface.   (line 163)
* segregated allocation cache; creating: Segregated allocation caches.
                                                              (line  69)
* segregated fit:                        Memory Management Glossary S.
                                                              (line 134)
* segregated free list:                  Location dependency interface.
                                                              (line 169)
* segregated free list <1>:              Memory Management Glossary S.
                                                              (line 160)
* segregated free-list:                  Memory Management Glossary S.
                                                              (line 163)
* SegScanMethod (C type):                Garbage collection<2>.
                                                              (line  60)
* SegSplit (C function):                 Splitting and merging.
                                                              (line  10)
* SegSplitMethod (C type):               Splitting and merging<2>.
                                                              (line   6)
* SegWalkMethod (C type):                Garbage collection<2>.
                                                              (line 114)
* SegWhitenMethod (C type):              Garbage collection<2>.
                                                              (line  22)
* semi-conservative garbage collection:  Memory Management Glossary S.
                                                              (line 183)
* semi-space:                            Memory Management Glossary S.
                                                              (line 203)
* semi-space collector:                  Memory Management Glossary S.
                                                              (line 225)
* sequential fit:                        Memory Management Glossary S.
                                                              (line 227)
* sequential store buffer:               Memory Management Glossary S.
                                                              (line 255)
* Serial (C type):                       Concrete types.      (line 489)
* SetClassOfPoly (C macro):              Introspection.       (line  34)
* shared memory:                         Memory Management Glossary S.
                                                              (line 265)
* shield; design:                        Defects.             (line  14)
* ShieldHold (C function):               Collector access to the unprotectable.
                                                              (line  20)
* ShieldLower (C function):              Mutator access.      (line  16)
* ShieldRaise (C function):              Mutator access.      (line  11)
* ShieldRelease (C function):            Collector access to the unprotectable.
                                                              (line  24)
* Shift (C type):                        Concrete types.      (line 501)
* Sig (C type):                          Concrete types.      (line 515)
* signal; handling:                      Thread registration. (line  25)
* signal; handling in GDB:               General debugging advice.
                                                              (line  53)
* signatures:                            References<11>.      (line  11)
* simple object:                         Memory Management Glossary S.
                                                              (line 270)
* simple segregated storage:             Memory Management Glossary S.
                                                              (line 282)
* Simula:                                Memory management in various languages.
                                                              (line 594)
* size:                                  Memory Management Glossary S.
                                                              (line 294)
* Size (C type):                         Concrete types.      (line 522)
* size class:                            Memory Management Glossary S.
                                                              (line 300)
* skip method:                           The scan method.     (line  95)
* skip method <1>:                       Memory Management Glossary S.
                                                              (line 310)
* Smalltalk:                             Memory management in various languages.
                                                              (line 611)
* smart pointer:                         Memory Management Glossary S.
                                                              (line 316)
* snap-out:                              Memory Management Glossary S.
                                                              (line 338)
* snapshot at the beginning:             Memory Management Glossary S.
                                                              (line 362)
* SNC pool class:                        MVT interface.       (line 100)
* SNC pool class; interface:             SNC properties.      (line  48)
* SNC pool class; properties:            SNC Stack No Checking.
                                                              (line  23)
* soft reference:                        Memory Management Glossary S.
                                                              (line 404)
* softly reachable:                      Memory Management Glossary S.
                                                              (line 422)
* space leak:                            Memory Management Glossary S.
                                                              (line 448)
* spaghetti stack:                       Memory Management Glossary S.
                                                              (line 471)
* spare commit limit:                    Memory Management Glossary S.
                                                              (line 452)
* spare committed memory:                Memory Management Glossary S.
                                                              (line 459)
* splat:                                 Memory Management Glossary S.
                                                              (line 475)
* splay trees; design:                   Implementations<4>.  (line  18)
* SplayFindFirst (C function):           Functions<6>.        (line 113)
* SplayFindLast (C function):            Functions<6>.        (line 125)
* SplayNodeRefresh (C function):         Functions<6>.        (line 132)
* SplayNodeUpdate (C function):          Functions<6>.        (line 143)
* SplayTestNodeFunction (C type):        Types<8>.            (line  14)
* SplayTestTreeFunction (C type):        Types<8>.            (line  25)
* SplayTree (C type):                    Types<8>.            (line   6)
* SplayTreeCheck (C function):           Functions<6>.        (line  16)
* SplayTreeDelete (C function):          Functions<6>.        (line  57)
* SplayTreeDescribe (C function):        Functions<6>.        (line 103)
* SplayTreeFind (C function):            Functions<6>.        (line  68)
* SplayTreeFinish (C function):          Functions<6>.        (line  37)
* SplayTreeFirst (C function):           Functions<6>.        (line  90)
* SplayTreeInit (C function):            Functions<6>.        (line  22)
* SplayTreeInsert (C function):          Functions<6>.        (line  46)
* SplayTreeNeighbours (C function):      Functions<6>.        (line  77)
* SplayTreeNext (C function):            Functions<6>.        (line  96)
* SplayUpdateNodeFunction (C type):      Types<8>.            (line  40)
* split:                                 Memory Management Glossary S.
                                                              (line 482)
* SRAM:                                  Memory Management Glossary S.
                                                              (line 500)
* SSB:                                   Memory Management Glossary S.
                                                              (line 502)
* stack:                                 Memory Management Glossary S.
                                                              (line 506)
* stack allocation:                      Memory Management Glossary S.
                                                              (line 538)
* stack and register scanning; design:   References<13>.      (line  13)
* stack frame:                           Memory Management Glossary S.
                                                              (line 571)
* stack probe; design:                   References<12>.      (line  11)
* stack record:                          Memory Management Glossary S.
                                                              (line 597)
* STACK_CONTEXT_BEGIN (C macro):         Interface<16>.       (line  34)
* STACK_CONTEXT_END (C macro):           Interface<16>.       (line  55)
* STACK_CONTEXT_SAVE (C macro):          Interface<16>.       (line  23)
* stack; allocation:                     Ramp allocation.     (line  61)
* StackContext (C type):                 Interface<16>.       (line   6)
* StackProbe (C function):               Interface<15>.       (line   6)
* StackScan (C function):                Interface<16>.       (line  10)
* staleness; testing:                    Adding dependencies. (line  27)
* static allocation:                     Memory Management Glossary S.
                                                              (line 599)
* static memory (1):                     Memory Management Glossary S.
                                                              (line 626)
* static memory (2):                     Memory Management Glossary S.
                                                              (line 643)
* static object:                         Memory Management Glossary S.
                                                              (line 657)
* static RAM:                            Memory Management Glossary S.
                                                              (line 661)
* static storage duration:               Memory Management Glossary S.
                                                              (line 665)
* STATISTIC (C macro):                   Statistics.          (line  27)
* STATISTIC_DECL (C macro):              Statistics.          (line  19)
* STATISTIC_WRITE (C macro):             Statistics.          (line  43)
* stepper function:                      Memory Management Glossary S.
                                                              (line 691)
* sticky reference count:                Memory Management Glossary S.
                                                              (line 698)
* stop-and-copy collection:              Memory Management Glossary S.
                                                              (line 702)
* storage:                               Memory Management Glossary S.
                                                              (line 715)
* storage hierarchy:                     Memory Management Glossary S.
                                                              (line 719)
* storage level:                         Memory Management Glossary S.
                                                              (line 745)
* storage management:                    Memory Management Glossary S.
                                                              (line 756)
* store (1):                             Memory Management Glossary S.
                                                              (line 758)
* store (2):                             Memory Management Glossary S.
                                                              (line 773)
* strategy; design:                      Splitting and merging<2>.
                                                              (line  96)
* stretchy vector:                       Memory Management Glossary S.
                                                              (line 777)
* stretchy vectors:                      What next?<2>.       (line  18)
* strict segregated fit:                 Memory Management Glossary S.
                                                              (line 790)
* strong reference:                      Memory Management Glossary S.
                                                              (line 808)
* strong root:                           Memory Management Glossary S.
                                                              (line 826)
* strong tri-color invariant:            Memory Management Glossary S.
                                                              (line 837)
* strong tri-colour invariant:           Memory Management Glossary S.
                                                              (line 840)
* strong tricolor invariant:             Memory Management Glossary S.
                                                              (line 842)
* strong tricolour invariant:            Memory Management Glossary S.
                                                              (line 844)
* strongly reachable:                    Memory Management Glossary S.
                                                              (line 871)
* structure signatures; design:          References<11>.      (line  12)
* suballocator:                          Memory Management Glossary S.
                                                              (line 886)
* subgraph:                              Memory Management Glossary S.
                                                              (line 907)
* SuperclassPoly (C macro):              Introspection.       (line  20)
* superpage:                             Memory Management Glossary S.
                                                              (line 912)
* sure reference:                        Memory Management Glossary S.
                                                              (line 916)
* swap space:                            Memory Management Glossary S.
                                                              (line 920)
* swapped in:                            Memory Management Glossary S.
                                                              (line 931)
* swapped out:                           Memory Management Glossary S.
                                                              (line 946)
* swapping:                              Memory Management Glossary S.
                                                              (line 961)
* sweeping:                              Memory Management Glossary S.
                                                              (line 975)
* synchronous garbage collector:         Memory Management Glossary S.
                                                              (line 990)
* tabling:                               Memory Management Glossary T.
                                                              (line  13)
* tag:                                   Memory Management Glossary T.
                                                              (line  15)
* tagged architecture:                   Memory Management Glossary T.
                                                              (line  60)
* tagged reference:                      Memory Management Glossary T.
                                                              (line  75)
* TB (1):                                Memory Management Glossary T.
                                                              (line  83)
* TB (2):                                Memory Management Glossary T.
                                                              (line  87)
* tearing down:                          Maintaining consistency.
                                                              (line  39)
* telemetry filter:                      Memory Management Glossary T.
                                                              (line  91)
* telemetry label:                       Memory Management Glossary T.
                                                              (line  98)
* telemetry stream:                      Memory Management Glossary T.
                                                              (line 106)
* telemetry system:                      Memory Management Glossary T.
                                                              (line 113)
* telemetry; customizing:                Telemetry labels.    (line  81)
* telemetry; decoding event stream:      Environment variables.
                                                              (line  44)
* telemetry; decoding in Python:         Loading the telemetry stream into SQLite.
                                                              (line  62)
* telemetry; design:                     References<25>.      (line   8)
* telemetry; environment variables:      Event categories.    (line  35)
* telemetry; event categories:           Example.             (line  82)
* telemetry; events:                     Decoding the telemetry stream in Python.
                                                              (line 100)
* telemetry; example:                    Telemetry utilities. (line  26)
* telemetry; I/O module:                 Plinth.              (line  62)
* telemetry; interface:                  Telemetry events.    (line  12)
* telemetry; labels:                     Telemetry interface. (line  41)
* telemetry; loading into SQLite:        Making the telemetry stream readable.
                                                              (line  29)
* telemetry; making event stream readable: Decoding the telemetry stream.
                                                              (line  39)
* telemetry; utilities:                  Telemetry.           (line  46)
* tenuring:                              Memory Management Glossary T.
                                                              (line 118)
* terabyte:                              Memory Management Glossary T.
                                                              (line 122)
* termination:                           Memory Management Glossary T.
                                                              (line 132)
* tests; design:                         References<14>.      (line  18)
* testthr_create (C function):           Interface<17>.       (line  14)
* testthr_join (C function):             Interface<17>.       (line  20)
* testthr_routine_t (C type):            Interface<17>.       (line  10)
* testthr_t (C type):                    Interface<17>.       (line   6)
* thrash:                                Memory Management Glossary T.
                                                              (line 136)
* thread:                                Area scanners.       (line 144)
* thread <1>:                            Memory Management Glossary T.
                                                              (line 158)
* Thread (C type):                       Interface<18>.       (line   6)
* thread manager; design:                References<16>.      (line   9)
* thread safety:                         Threads<2>.          (line   6)
* thread safety; design:                 macOS implementation<2>.
                                                              (line  30)
* thread; exception handling:            Thread registration. (line  24)
* thread; handling in GDB:               General debugging advice.
                                                              (line  67)
* thread; interface:                     Fork safety.         (line  28)
* thread; registering:                   Roots.               (line 194)
* thread; registration:                  Thread safety.       (line  15)
* thread; signal handling:               Thread registration. (line  25)
* ThreadArena (C function):              Interface<18>.       (line  24)
* ThreadCheck (C function):              Interface<18>.       (line  11)
* ThreadCheckSimple (C function):        Interface<18>.       (line  16)
* ThreadDeregister (C function):         Interface<18>.       (line  38)
* ThreadRegister (C function):           Interface<18>.       (line  30)
* ThreadRingResume (C function):         Interface<18>.       (line  49)
* ThreadRingSuspend (C function):        Interface<18>.       (line  43)
* ThreadRingThread (C function):         Interface<18>.       (line  54)
* threads; testing:                      References<15>.      (line   9)
* ThreadScan (C function):               Interface<18>.       (line  59)
* threatened set:                        Memory Management Glossary T.
                                                              (line 175)
* tidying up:                            Maintaining consistency.
                                                              (line  38)
* TLB:                                   Memory Management Glossary T.
                                                              (line 179)
* to space:                              Memory Management Glossary T.
                                                              (line 183)
* tospace:                               Memory Management Glossary T.
                                                              (line 186)
* trace:                                 Memory Management Glossary T.
                                                              (line 194)
* TraceId (C type):                      Concrete types.      (line 546)
* tracer; design:                        Allocation replayer tool.
                                                              (line   8)
* TraceSet (C type):                     Concrete types.      (line 553)
* TraceStartWhy (C type):                Concrete types.      (line 565)
* TraceState (C type):                   Concrete types.      (line 599)
* tracing garbage collection:            Memory Management Glossary T.
                                                              (line 202)
* TractOfAddr (C function):              Tracts.              (line  48)
* transform:                             Memory Management Glossary T.
                                                              (line 216)
* transform; interface:                  Cautions<5>.         (line  26)
* transform; introduction:               Weak references.     (line  75)
* transforms; design:                    Fork safety<3>.      (line  36)
* translation buffer:                    Memory Management Glossary T.
                                                              (line 222)
* translation lookaside buffer:          Memory Management Glossary T.
                                                              (line 225)
* transparent alias:                     Memory Management Glossary T.
                                                              (line 244)
* transparent type:                      Memory Management Glossary T.
                                                              (line 247)
* transport:                             Memory Management Glossary T.
                                                              (line 256)
* transport snap-out:                    Memory Management Glossary T.
                                                              (line 270)
* treadmill:                             Memory Management Glossary T.
                                                              (line 272)
* Tree (C type):                         Types<7>.            (line   6)
* TreeCheck (C function):                Functions<5>.        (line   6)
* TreeCompareFunction (C type):          Types<7>.            (line  30)
* TreeDescribeFunction (C type):         Types<7>.            (line  43)
* TreeKey (C type):                      Types<7>.            (line  15)
* TreeKeyFunction (C type):              Types<7>.            (line  21)
* tri-color invariant:                   Memory Management Glossary T.
                                                              (line 294)
* tri-color marking:                     Memory Management Glossary T.
                                                              (line 313)
* tri-colour invariant:                  Memory Management Glossary T.
                                                              (line 297)
* tri-colour marking:                    Memory Management Glossary T.
                                                              (line 316)
* tricolor invariant:                    Memory Management Glossary T.
                                                              (line 299)
* tricolor marking:                      Memory Management Glossary T.
                                                              (line 318)
* tricolour invariant:                   Memory Management Glossary T.
                                                              (line 301)
* tricolour marking:                     Memory Management Glossary T.
                                                              (line 320)
* two space collector:                   Memory Management Glossary T.
                                                              (line 370)
* two-space collector:                   Memory Management Glossary T.
                                                              (line 367)
* type punning:                          Functions.           (line  33)
* type punning <1>:                      Memory Management Glossary T.
                                                              (line 405)
* type-accurate garbage collection:      Memory Management Glossary T.
                                                              (line 403)
* ULongest (C type):                     Concrete types.      (line 626)
* unaligned:                             Memory Management Glossary U.
                                                              (line  13)
* unboxed:                               Memory Management Glossary U.
                                                              (line  34)
* unclamped state:                       Arena states.        (line   8)
* unclamped state <1>:                   Memory Management Glossary U.
                                                              (line  49)
* undead:                                Memory Management Glossary U.
                                                              (line  58)
* underscanning:                         Address space layout randomization.
                                                              (line  83)
* unmapped:                              Memory Management Glossary U.
                                                              (line  69)
* unprotected:                           Memory Management Glossary U.
                                                              (line  81)
* unreachable:                           Memory Management Glossary U.
                                                              (line  88)
* unsure reference:                      Memory Management Glossary U.
                                                              (line 107)
* unwrapped:                             Memory Management Glossary U.
                                                              (line 109)
* use after free:                        Memory Management Glossary U.
                                                              (line 131)
* value object:                          Memory Management Glossary V.
                                                              (line  13)
* variety:                               Common assertions and their causes.
                                                              (line 143)
* variety <1>:                           Memory Management Glossary V.
                                                              (line  52)
* variety; cool:                         General debugging advice.
                                                              (line   9)
* variety; cool <1>:                     Varieties.           (line  12)
* variety; hot:                          Varieties.           (line  25)
* variety; rash:                         Varieties.           (line  38)
* vector data type:                      Memory Management Glossary V.
                                                              (line  58)
* virtual address:                       Memory Management Glossary V.
                                                              (line  80)
* virtual address space:                 Memory Management Glossary V.
                                                              (line  94)
* virtual mapping; design:               Implementation<14>.  (line  54)
* virtual memory:                        Memory Management Glossary V.
                                                              (line 106)
* virtual memory arena:                  Memory Management Glossary V.
                                                              (line 153)
* virtual memory arena class:            Client arenas.       (line  86)
* virtual memory arena; design:          Roots<3>.            (line  10)
* visitor function:                      Memory Management Glossary V.
                                                              (line 157)
* VM (1):                                Memory Management Glossary V.
                                                              (line 161)
* VM (2):                                Memory Management Glossary V.
                                                              (line 165)
* VM (C type):                           Interface<19>.       (line   6)
* VM arena; design:                      Roots<3>.            (line   9)
* VMBase (C function):                   Interface<19>.       (line  62)
* VMCopy (C function):                   Interface<19>.       (line  84)
* VMFinish (C function):                 Interface<19>.       (line  43)
* VMInit (C function):                   Interface<19>.       (line  33)
* VMLimit (C function):                  Interface<19>.       (line  67)
* VMMap (C function):                    Interface<19>.       (line  48)
* VMMapped (C function):                 Interface<19>.       (line  79)
* VMParamFromArgs (C function):          Interface<19>.       (line  24)
* VMReserved (C function):               Interface<19>.       (line  72)
* VMUnmap (C function):                  Interface<19>.       (line  56)
* walk; design:                          Testing<5>.          (line  23)
* weak hash table:                       Memory Management Glossary W.
                                                              (line  33)
* weak reference (1):                    Memory Management Glossary W.
                                                              (line  38)
* weak reference (2):                    Memory Management Glossary W.
                                                              (line  63)
* weak reference; example:               Location dependency. (line 247)
* weak references:                       Customizing the telemetry system.
                                                              (line  21)
* weak root:                             Memory Management Glossary W.
                                                              (line  79)
* weak tri-color invariant:              Memory Management Glossary W.
                                                              (line  90)
* weak tri-colour invariant:             Memory Management Glossary W.
                                                              (line  93)
* weak tricolor invariant:               Memory Management Glossary W.
                                                              (line  95)
* weak tricolour invariant:              Memory Management Glossary W.
                                                              (line  97)
* weak-key hash table:                   Memory Management Glossary W.
                                                              (line  13)
* weak-value hash table:                 Memory Management Glossary W.
                                                              (line  22)
* weakly reachable:                      Memory Management Glossary W.
                                                              (line 121)
* weighted buddies:                      Memory Management Glossary W.
                                                              (line 145)
* weighted reference counting:           Memory Management Glossary W.
                                                              (line 164)
* white:                                 Memory Management Glossary W.
                                                              (line 187)
* word:                                  Memory Management Glossary W.
                                                              (line 197)
* Word (C type):                         Concrete types.      (line 634)
* Work (C type):                         Concrete types.      (line 653)
* working set:                           Memory Management Glossary W.
                                                              (line 225)
* worst fit:                             Memory Management Glossary W.
                                                              (line 243)
* wrapped:                               Memory Management Glossary W.
                                                              (line 260)
* wrapper:                               Memory Management Glossary W.
                                                              (line 273)
* write barrier:                         Memory Management Glossary W.
                                                              (line 301)
* write barrier; design:                 References<18>.      (line  14)
* write fault:                           Memory Management Glossary W.
                                                              (line 319)
* WriteF (C function):                   Design<11>.          (line  16)
* WriteF function; design:               References<19>.      (line   8)
* ZCT:                                   Memory Management Glossary Z.
                                                              (line  13)
* zero count table:                      Memory Management Glossary Z.
                                                              (line  15)
* ZoneSet (C type):                      Concrete types.      (line 663)

