This is MemoryPoolSystem.info, produced by makeinfo version 7.1.1 from
MemoryPoolSystem.texi.

     Memory Pool System 1.118.0, Feb 11, 2025

     Ravenbrook Limited

     Copyright © 2025, Ravenbrook Limited

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* MemoryPoolSystem: (MemoryPoolSystem.info). One line description of project.
END-INFO-DIR-ENTRY


   Generated by Sphinx 8.1.3.


File: MemoryPoolSystem.info,  Node: Security issues,  Prev: Deprecated interfaces,  Up: Reference

2.26 Security issues
====================

This chapter describes security issues that may be present when using
the MPS.

* Menu:

* Predictable address space layout on FreeBSD::
* Address disclosure::
* Telemetry: Telemetry<2>.


File: MemoryPoolSystem.info,  Node: Predictable address space layout on FreeBSD,  Next: Address disclosure,  Up: Security issues

2.26.1 Predictable address space layout on FreeBSD
--------------------------------------------------

The MPS acquires *note address space: 54. using the operating system’s
*note virtual memory: 51. interface (specifically, ‘mmap()’ on FreeBSD).
As of version 10, FreeBSD does not randomize the allocated regions of
address space, which means that the *note addresses: 126. of *note
blocks: 185. allocated by the MPS are predictable: a *note client
program: d0. that makes an identical series of calls to the MPS gets an
identical series of addresses back.

This means that if a program using the MPS has a buffer overflow, the
overflow is more easily exploitable by an attacker than if the program
had used ‘malloc()’ (which has some randomization of the allocated
addresses), because it is easier for an attacker to determine the
address of allocated structures.

There is currently no workaround for this issue.  If this affects you,
please *note contact us: d8.

Other supported platforms are unaffected by this issue: Linux and macOS
randomize the addresses allocated by ‘mmap()’, and Windows randomizes
the addresses allocated by ‘VirtualAlloc()’.


File: MemoryPoolSystem.info,  Node: Address disclosure,  Next: Telemetry<2>,  Prev: Predictable address space layout on FreeBSD,  Up: Security issues

2.26.2 Address disclosure
-------------------------

The MPS supports *note semi-conservative garbage collection: 348. in
which some memory locations are *note scanned: 65. as *note ambiguous
references: 9f.  This may make it possible for a program to discover the
*note address: 126. of an *note object: 1ab, even if the programming
language has no feature for obtaining the address of an object.
Discovering the addresses of objects makes it easier to exploit buffer
overflow bugs.

The attack proceeds as follows: create a *note weak reference (1): c. to
the object of interest (for example, via a *note weak-key hash table:
fb.); guess a value for the address of the object; and arrange for that
value to be scanned as an ambiguous reference (for example, by ensuring
that it appears in *note registers: 26. or on the *note control stack:
27. of a *note thread: 99.).  If the guess was correct, the MPS keeps
the object *note alive: 78.; if incorrect, the object may *note die: 49.
The attacker can then determine which of these was the case by examining
the weak reference to see if it has been *note splatted: 245.

The attack was pointed out by Dionysus Blazakis in 2012(1) with respect
to JavaScript implementations, but it affects all *note conservative:
349. and *note semi-conservative: 348. garbage collectors.

   ---------- Footnotes ----------

   (1) https://github.com/justdionysus/gcwoah


File: MemoryPoolSystem.info,  Node: Telemetry<2>,  Prev: Address disclosure,  Up: Security issues

2.26.3 Telemetry
----------------

In its *note hot: 162. and *note cool: c8. varieties, the MPS contains a
*note telemetry system: 15b. which can be configured to record a stream
of events for later analysis and debugging.  When using the default
*note plinth: 160, the behaviour of the telemetry system is under the
control of the environment variable *note MPS_TELEMETRY_CONTROL: 288,
and the *note telemetry stream: ba. is written to the file named by the
environment variable *note MPS_TELEMETRY_FILENAME: 289.

This means that an attacker who can set arbitrary environment variables
when running a program that uses the MPS can cause that program to write
a telemetry stream to an arbitrary file.  This behaviour might be
unexpected, and might enable a data overwriting attack, or a
denial-of-service attack, since telemetry streams are typically very
large.

If this is an issue for your program, then you can modify or replace the
*note I/O module: 2b8. in the *note plinth: 160. so that it meets your
requirements, or distribute the *note rash: 163. variety of the MPS,
which omits the *note telemetry system: 15b. entirely, and use the other
varieties only for development and testing.


File: MemoryPoolSystem.info,  Node: Pool reference,  Next: Design,  Prev: Reference,  Up: Top

3 Pool reference
****************

* Menu:

* Choosing a pool class: Choosing a pool class<2>.
* Pool class properties::
* Writing a new pool class::
* AMC (Automatic Mostly-Copying): AMC Automatic Mostly-Copying.
* AMCZ (Automatic Mostly-Copying Zero-rank): AMCZ Automatic Mostly-Copying Zero-rank.
* AMS (Automatic Mark and Sweep): AMS Automatic Mark and Sweep.
* AWL (Automatic Weak Linked): AWL Automatic Weak Linked.
* LO (Leaf Object): LO Leaf Object.
* MFS (Manual Fixed Small): MFS Manual Fixed Small.
* MVFF (Manual Variable First Fit): MVFF Manual Variable First Fit.
* MVT (Manual Variable Temporal): MVT Manual Variable Temporal.
* SNC (Stack No Checking): SNC Stack No Checking.


File: MemoryPoolSystem.info,  Node: Choosing a pool class<2>,  Next: Pool class properties,  Up: Pool reference

3.1 Choosing a pool class
=========================

This section contains a simple procedure for choosing a *note pool
class: 10. based on the properties of the data you plan to store in it.
The MPS works well if you can segregate your data into a variety of
pools, choosing the most appropriate pool class for each.

     Note: Pool classes can differ in many ways not considered here:
     speed, vulnerability to fragmentation, control overhead, and so on.
     This procedure gives you a decent recommendation, but an expert in
     the MPS might be able to make a better recommendation.  And if no
     pool class in the open source MPS exactly matches your needs, then
     it is possible to develop new pool classes.  See *note Writing a
     new pool class: 34f.

First, do you need the MPS to *note automatically: 9. *note reclaim: 4a.
*note unreachable: 21. blocks?  If so, you need an automatically managed
(garbage collected) pool class and you should consult *note Choosing an
automatic pool class: 350. below.  Otherwise, you need a manually
managed pool class and you should consult *note Choosing a manual pool
class: 351. below.

* Menu:

* Choosing an automatic pool class::
* Choosing a manual pool class::


File: MemoryPoolSystem.info,  Node: Choosing an automatic pool class,  Next: Choosing a manual pool class,  Up: Choosing a pool class<2>

3.1.1 Choosing an automatic pool class
--------------------------------------

Answer these questions about your data:

  1. Is it acceptable for the MPS to *note move: 1ad. blocks in memory
     and to place *note barriers (1): 60. on blocks?  (For example, it
     might not be acceptable to move a block if it has been passed to
     *note foreign code: 10b. that remembered its location.)

  2. Do your blocks contain *note references: 24. to blocks stored in
     automatically managed pools (including references to other blocks
     in the same pool, if it’s automatically managed)?  And if so, are
     these references *note exact: 61. or *note weak: c.?

Second, look up your answers in this table to find the recommended pool
class to use:

Movable & protectable?     References?     Use this pool class
                                           
-------------------------------------------------------------------
                                           
yes                        none            *note AMCZ (Automatic Mostly-Copying Zero-rank): 89.
                                           
                                           
yes                        exact           *note AMC (Automatic Mostly-Copying): 62.
                                           
                                           
yes                        weak            *note AWL (Automatic Weak Linked): fe.
                                           
                                           
no                         none            *note LO (Leaf Object): 353.
                                           
                                           
no                         exact           *note AMS (Automatic Mark and Sweep): 16c.
                                           
                                           
no                         weak            nothing suitable
                                           


File: MemoryPoolSystem.info,  Node: Choosing a manual pool class,  Prev: Choosing an automatic pool class,  Up: Choosing a pool class<2>

3.1.2 Choosing a manual pool class
----------------------------------

Answer these questions about your data:

  1. Are the blocks fixed in size?  If so, use *note MFS (Manual Fixed
     Small): 355.

  2. Are the lifetimes of blocks predictable?  If so, use *note MVT
     (Manual Variable Temporal): 1bc, and arrange that objects that are
     predicted to die at about the same time are allocated from the same
     *note allocation point: 63.

  3. Otherwise, use *note MVFF (Manual Variable First Fit): 10c.


File: MemoryPoolSystem.info,  Node: Pool class properties,  Next: Writing a new pool class,  Prev: Choosing a pool class<2>,  Up: Pool reference

3.2 Pool class properties
=========================

This table summarizes the properties of each *note pool class: 10.
provided by the open source MPS. For “block” properties, “yes” means
that the property holds for 'all' blocks allocated from the pool.  An
entry “—” indicates that a property makes no sense for a pool class: for
example, if blocks in a pool may not contain *note references: 24, it
makes no sense to ask whether they may contain *note weak references
(1): c.

Property   *note AMC: 62.*note AMCZ: 89.*note AMS: 16c.*note AWL: fe.*note LO: 353.*note MFS: 355.*note MVFF: 10c.*note MVT: 1bc.*note SNC: 27b.
                                                           
-----------------------------------------------------------------
                                                           
Supports   no    no    no    no    no    yes   yes   no    no
*note mps_alloc(): ad.?                                    

Supports   no    no    no    no    no    yes   yes   yes   no
*note mps_free(): 1f.?                                     

Supports   yes   yes   yes   yes   yes   no    yes   yes   yes
allocation                                                 
points?

Manages    no    no    no    no    no    no    no    no    yes
memory                                                     
using
allocation
frames?

Supports   no    no    no    no    no    yes   yes   no    no
segregated                                                 
allocation
caches?

Timing     auto  auto  auto  auto  auto  —     —     —     —
of                                                         
collections?
(1)

May        yes   no    yes   yes   no    no    no    no    yes
contain                                                    
references?
(2)

May        yes   —     yes   yes   —     —     —     —     yes
contain                                                    
exact
references?
(3)

May        no    —     no    no    —     —     —     —     no
contain                                                    
ambiguous
references?
(4)

May        no    —     no    yes   —     —     —     —     no
contain                                                    
weak
references?
(5)

Allocationsvar   var   var   var   var   fixed var   var   var
fixed or                                                   
variable
in size?

Alignment? conf  conf  conf  conf  conf  (7)   (8)   (9)   conf
(6)                                                        

Dependent  no    —     no    yes   —     —     —     —     no
objects?                                                   
(10)

May use    no    —     no    no    —     —     —     —     no
remote                                                     
references?
(11)

Blocks     yes   yes   yes   yes   yes   no    no    no    no
are                                                        
automatically
managed?
(12)

Blocks     yes   yes   no    no    no    —     —     —     —
are                                                        
promoted
between
generations

Blocks     no    no    no    no    no    yes   yes   yes   yes
are                                                        
manually
managed?
(13)

Blocks     yes   no    yes   yes   no    no    no    no    yes
are                                                        
scanned?
(14)

Blocks     no    no    yes   yes   yes   —     —     —     yes
support                                                    
base
pointers
only?
(15)

Blocks     yes   yes   no    no    no    —     —     —     no
support                                                    
internal
pointers?
(16)

Blocks     yes   no    yes   yes   yes   no    no    no    yes
may be                                                     
protected
by
barriers?

Blocks     yes   yes   no    no    no    no    no    no    no
may                                                        
move?

Blocks     yes   yes   yes   yes   yes   no    no    no    no
may be                                                     
finalized?

Blocks     yes   yes   yes   yes   yes   no    no    no    yes
must be                                                    
formatted?
(17)

Blocks     yes   yes   yes   yes   yes   —     —     —     no
may use                                                    
*note in-band headers: 1d1.?

     Note: 
   ---------- Footnotes ----------

   (1) “Timing of collections” is “auto” if *note garbage collection: f.
is under the control of the MPS, which decides when collection should
take place and performs it *note automatically: 9. and *note
incrementally: d.

   (2) The references in question are references to blocks in *note
automatically managed: 9. *note pools: 18.

   (3) Pools “may contain *note ambiguous: 9f. / *note exact: 61. /
*note weak: c. references” if the references that the client program
fixes during scanning may include references of the indicated *note
rank: 9e.

   (4) Pools “may contain *note ambiguous: 9f. / *note exact: 61. /
*note weak: c. references” if the references that the client program
fixes during scanning may include references of the indicated *note
rank: 9e.

   (5) Pools “may contain *note ambiguous: 9f. / *note exact: 61. /
*note weak: c. references” if the references that the client program
fixes during scanning may include references of the indicated *note
rank: 9e.

   (6) “Alignment” is “conf” if the client program may specify *note
alignment: 68. for each pool.

   (7) The alignment of blocks allocated from *note MFS (Manual Fixed
Small): 355. pools is the platform’s *note natural alignment: 70, *note
MPS_PF_ALIGN: 6f.

   (8) *note MVT (Manual Variable Temporal): 1bc. and *note MVFF (Manual
Variable First Fit): 10c. pools have configurable alignment, but it may
not be smaller than ‘sizeof(void *)’.

   (9) *note MVT (Manual Variable Temporal): 1bc. and *note MVFF (Manual
Variable First Fit): 10c. pools have configurable alignment, but it may
not be smaller than ‘sizeof(void *)’.

   (10) In pools with this property, each object may specify an *note
dependent object: ff. which the client program guarantees will be
accessible during the scanning of the first object.  This may be used in
the implementation of *note weak hash tables: 357.

   (11) “Remote references” are references that are stored outside the
block to which they logically belong (for example, in some kind of
auxiliary table).  A pool containing remote references cannot rely on a
*note write barrier: 214. to detect changed references.

   (12) Blocks are “automatically managed” if they may be automatically
discarded when the MPS determines that they are unreachable; they are
“manually managed” if they can be discarded when the *note client
program: d0. requests it.  Note that these properties are not mutually
exclusive, although the MPS does not provide a pool class that satisfies
both.

   (13) Blocks are “automatically managed” if they may be automatically
discarded when the MPS determines that they are unreachable; they are
“manually managed” if they can be discarded when the *note client
program: d0. requests it.  Note that these properties are not mutually
exclusive, although the MPS does not provide a pool class that satisfies
both.

   (14) Blocks “are scanned” if the MPS *note scans: 65. them for
references; blocks “must be formatted” if they are described to the MPS
by an *note object format: 39.  At present, the MPS only knows how to
scan blocks using the *note scan method: 73. from an object format, but
the MPS design does not preclude pools that scan unformatted blocks.

   (15) A block “supports internal pointers” if a pointer to any
location within the block is considered to be a reference to the block.
It “supports base pointers only” if only a pointer to the base of the
block (or, if the block belongs to an object format with *note in-band
headers: 1d1, a pointer just past the end of the header) is considered
to be a reference to the block.

Pools that support internal pointers can be switched to base pointers
only, by setting the optional keyword argument ‘MPS_KEY_INTERIOR’ to
‘FALSE’ when calling *note mps_pool_create_k(): 166.

   (16) A block “supports internal pointers” if a pointer to any
location within the block is considered to be a reference to the block.
It “supports base pointers only” if only a pointer to the base of the
block (or, if the block belongs to an object format with *note in-band
headers: 1d1, a pointer just past the end of the header) is considered
to be a reference to the block.

Pools that support internal pointers can be switched to base pointers
only, by setting the optional keyword argument ‘MPS_KEY_INTERIOR’ to
‘FALSE’ when calling *note mps_pool_create_k(): 166.

   (17) Blocks “are scanned” if the MPS *note scans: 65. them for
references; blocks “must be formatted” if they are described to the MPS
by an *note object format: 39.  At present, the MPS only knows how to
scan blocks using the *note scan method: 73. from an object format, but
the MPS design does not preclude pools that scan unformatted blocks.


File: MemoryPoolSystem.info,  Node: Writing a new pool class,  Next: AMC Automatic Mostly-Copying,  Prev: Pool class properties,  Up: Pool reference

3.3 Writing a new pool class
============================

If none of the pool classes supplied with the MPS are quite right for
your application, don’t despair: the MPS is designed to be extensible
with new pool classes, and designed so that the properties of pools are
as orthogonal as possible.  So if you need a pool containing objects
that are scannable but unformatted, or movable objects which are
manually managed, or a pool all of whose objects are roots, there is no
technical reason why it should not be possible to write it.

If you’d be interested in our developing new pool classes for your
requirements, or if you’ve started writing a new pool class yourself,
*note we’d love to hear from you: d8.


File: MemoryPoolSystem.info,  Node: AMC Automatic Mostly-Copying,  Next: AMCZ Automatic Mostly-Copying Zero-rank,  Prev: Writing a new pool class,  Up: Pool reference

3.4 AMC (Automatic Mostly-Copying)
==================================

'AMC' is a general-purpose *note automatically managed: 9. *note pool
class: 10.  This is the most mature pool class in the MPS, intended for
the majority of objects in the client program.  Use this pool class
unless you need a particular feature that it doesn’t provide.

“Mostly Copying” means that it uses *note copying garbage collection:
e3. except for blocks that are *note pinned: 1e5. by *note ambiguous
references: 9f.

It uses *note generational garbage collection: e.  That is, it exploits
assumptions about object lifetimes and inter-connection variously
referred to as “the *note generational hypothesis: 35b.”.  In
particular, the following tendencies will be efficiently exploited by an
AMC pool:

   - most objects die young;

   - objects that don’t die young will live a long time.

* Menu:

* AMC properties::
* AMC interface::
* Hash arrays::


File: MemoryPoolSystem.info,  Node: AMC properties,  Next: AMC interface,  Up: AMC Automatic Mostly-Copying

3.4.1 AMC properties
--------------------

   * Does not support allocation via *note mps_alloc(): ad. or
     deallocation via *note mps_free(): 1f.

   * Supports allocation via *note allocation points: 63.  If an
     allocation point is created in an AMC pool, the call to *note
     mps_ap_create_k(): af. takes no keyword arguments.

   * Supports *note allocation frames: 27d. but does not use them to
     improve the efficiency of stack-like allocation.

   * Does not support *note segregated allocation caches: 1b2.

   * Garbage collections are scheduled automatically.  See *note
     Scheduling of collections: 226.

   * Uses *note generational garbage collection: e.: blocks are promoted
     from generation to generation in the pool’s chain.

   * Blocks may contain *note exact references: 61. to blocks in the
     same or other pools (but may not contain *note ambiguous
     references: 9f. or *note weak references (1): c, and may not use
     *note remote references: 35d.).

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable.

   * Blocks do not have *note dependent objects: ff.

   * Blocks that are not *note reachable: 96. from a *note root: 97. are
     automatically *note reclaimed: 4a.

   * Blocks are *note scanned: 65.

   * Blocks may be referenced by *note interior pointers: 1ac. (unless
     ‘MPS_KEY_INTERIOR’ is set to ‘FALSE’, in which case only *note base
     pointers: 1aa, or *note client pointers: 1d4. if the blocks have
     *note in-band headers: 1d1, are supported).

   * Blocks may be protected by *note barriers (1): 60.

   * Blocks may *note move: 5d.

   * Blocks may be registered for *note finalization: b.

   * Blocks must belong to an *note object format: 39. which provides
     *note scan: 73, *note skip: 81, *note forward: 85, *note
     is-forwarded: 8c, and *note padding: 90. methods.

   * Blocks may have *note in-band headers: 1d1.


File: MemoryPoolSystem.info,  Node: AMC interface,  Next: Hash arrays,  Prev: AMC properties,  Up: AMC Automatic Mostly-Copying

3.4.2 AMC interface
-------------------

     #include "mpscamc.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_amc (void)

     Return the *note pool class: 10. for an AMC (Automatic
     Mostly-Copying) *note pool: 18.

     When creating an AMC pool, *note mps_pool_create_k(): 166. requires
     one *note keyword argument: 53.:

        * ‘MPS_KEY_FORMAT’ (type *note mps_fmt_t: 141.) specifies the
          *note object format: 39. for the objects allocated in the
          pool.  The format must provide a *note scan method: 73, a
          *note skip method: 81, a *note forward method: 85, an *note
          is-forwarded method: 8c. and a *note padding method: 90.

     It accepts three optional keyword arguments:

        * ‘MPS_KEY_CHAIN’ (type *note mps_chain_t: 13a.) specifies the
          *note generation chain: e2. for the pool.  If not specified,
          the pool will use the arena’s default chain.

        * ‘MPS_KEY_INTERIOR’ (type *note mps_bool_t: 129, default
          ‘TRUE’) specifies whether *note ambiguous: 9f. *note interior
          pointers: 1ac. to blocks in the pool keep objects alive.  If
          this is ‘FALSE’, then only *note client pointers: 1d4. keep
          objects alive.

        * ‘MPS_KEY_EXTEND_BY’ (type ‘size_t’, default 4096) is the
          minimum *note size: 183. of the memory segments that the pool
          requests from the *note arena: 16.  Larger segments reduce the
          per-segment overhead, but increase *note fragmentation: 17e.
          and *note retention: 17f.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_FORMAT, fmt);
              res = mps_pool_create_k(&pool, arena, mps_class_amc(), args);
          } MPS_ARGS_END(args);

     When creating an *note allocation point: 63. on an AMC pool, *note
     mps_ap_create_k(): af. accepts one optional keyword argument:

        * ‘MPS_KEY_AP_HASH_ARRAYS’ (type *note mps_bool_t: 129,
          defaulting to false) specifies (if true) that blocks allocated
          from the allocation point do not contribute to the 'new size'
          of the *note nursery space: 35f. for the purposes of deciding
          whether to start a collection of that generation.  See *note
          Hash arrays: 360.


File: MemoryPoolSystem.info,  Node: Hash arrays,  Prev: AMC interface,  Up: AMC Automatic Mostly-Copying

3.4.3 Hash arrays
-----------------

The *note location dependency: 19a. feature of the MPS allows the *note
client program: d0. to implement address-based hash tables in pools like
AMC that use a *note moving memory manager: 1ad, re-hashing the tables
when the addresses they contain might have moved.

However, when a frequently-used hash table grows large enough, the
following sequence of events may take place:

  1. The hash table discovers that its location dependency is stale.

  2. A new array is allocated to contain the re-hashed keys.

  3. The new array is large enough to push the 'new size' of the *note
     nursery space: 35f. (that is, the amount of newly allocated memory
     since the last collection in the first *note generation: e1. in the
     *note generation chain: e2. for the pool containing the array)
     close to its capacity.

  4. A small amount of additional allocation causes the new size of the
     nursery generation to exceed its capacity, which causes the MPS to
     start a new collection of that generation.  This in turn causes the
     hash table to become stale again.

When the hash table reaches this critical size, the client program may
find that a large fraction of its time is being spent re-hashing the
table.

In order to avoid this happening, the MPS provides a mechanism for
specifying that the newly allocated array does not contribute to the new
size of the nursery space: this cuts off the vicious cycle at step 3.

To enable this mechanism, use the optional ‘MPS_KEY_AP_HASH_ARRAYS’
keyword argument when creating an allocation point with *note
mps_ap_create_k(): af.  This interface is documented in the AMC
Interface section of the *note AMC (Automatic Mostly-Copying): 62.
documentation above.

See *note Scheduling of collections: 226. for an explanation of the 'new
size' of a generation, and how the MPS uses this to determine when to
start a collection of that generation.


File: MemoryPoolSystem.info,  Node: AMCZ Automatic Mostly-Copying Zero-rank,  Next: AMS Automatic Mark and Sweep,  Prev: AMC Automatic Mostly-Copying,  Up: Pool reference

3.5 AMCZ (Automatic Mostly-Copying Zero-rank)
=============================================

'AMCZ' is a general-purpose *note automatically managed: 9. *note pool
class: 10. for *note leaf objects: 107. (“zero-rank” objects that
contain no references).

It is otherwise identical to *note AMC (Automatic Mostly-Copying): 62.

AMCZ is intended for “simple” objects like numbers, characters, and
strings.  Segregating these objects into one or more AMCZ pools avoids
the cost of scanning them that would be incurred if they were
interleaved in a pool with objects containing references.  It may also
simplify the scanning of the objects that are left behind.

See *note Segregation of objects: 104. for an example.

* Menu:

* AMCZ properties::
* AMCZ interface::


File: MemoryPoolSystem.info,  Node: AMCZ properties,  Next: AMCZ interface,  Up: AMCZ Automatic Mostly-Copying Zero-rank

3.5.1 AMCZ properties
---------------------

AMCZ is identical to *note AMC (Automatic Mostly-Copying): 62, except
that:

   * Blocks may not contain *note references: 24. to blocks in
     automatically managed pools.

   * Blocks are not *note scanned: 65.  A consequence of this is that
     the pool’s *note object format: 39. need not provide a *note scan
     method: 73.

   * Blocks are not protected by *note barriers (1): 60.


File: MemoryPoolSystem.info,  Node: AMCZ interface,  Prev: AMCZ properties,  Up: AMCZ Automatic Mostly-Copying Zero-rank

3.5.2 AMCZ interface
--------------------

     #include "mpscamc.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_amcz (void)

     Return the *note pool class: 10. for an AMCZ (Automatic
     Mostly-Copying Zero-rank) *note pool: 18.

     When creating an AMCZ pool, *note mps_pool_create_k(): 166.
     requires one *note keyword argument: 53.:

        * ‘MPS_KEY_FORMAT’ (type *note mps_fmt_t: 141.) specifies the
          *note object format: 39. for the objects allocated in the
          pool.  The format must provide a *note skip method: 81, a
          *note forward method: 85, an *note is-forwarded method: 8c.
          and a *note padding method: 90.

     It accepts two optional keyword arguments:

        * ‘MPS_KEY_CHAIN’ (type *note mps_chain_t: 13a.) specifies the
          *note generation chain: e2. for the pool.  If not specified,
          the pool will use the arena’s default chain.

        * ‘MPS_KEY_INTERIOR’ (type *note mps_bool_t: 129, default
          ‘TRUE’) specifies whether *note ambiguous: 9f. *note interior
          pointers: 1ac. to blocks in the pool keep objects alive.  If
          this is ‘FALSE’, then only *note client pointers: 1d4. keep
          objects alive.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_FORMAT, fmt);
              res = mps_pool_create_k(&pool, arena, mps_class_amcz(), args);
          } MPS_ARGS_END(args);


File: MemoryPoolSystem.info,  Node: AMS Automatic Mark and Sweep,  Next: AWL Automatic Weak Linked,  Prev: AMCZ Automatic Mostly-Copying Zero-rank,  Up: Pool reference

3.6 AMS (Automatic Mark and Sweep)
==================================

'AMS' is an *note automatically managed: 9. but *note non-moving: 5e.
*note pool class: 10.  It should be used instead of *note AMC (Automatic
Mostly-Copying): 62. for blocks that need to be automatically managed,
but cannot be moved.

     Note: AMS is likely to be useful as a step in integrating a program
     with the MPS. It allows you to work on scanning (and investigate
     errors resulting from underscanning) without having to deal with
     objects moving as well.  When you are confident that scanning is
     correct, you can switch to *note AMC (Automatic Mostly-Copying):
     62.

     AMS is not currently suitable for production use.  However, it
     could be developed into a solid mark-and-sweep pool.  If you have a
     use case that needs this, *note contact us: d8.

* Menu:

* AMS properties::
* AMS interface::


File: MemoryPoolSystem.info,  Node: AMS properties,  Next: AMS interface,  Up: AMS Automatic Mark and Sweep

3.6.1 AMS properties
--------------------

   * Does not support allocation via *note mps_alloc(): ad. or
     deallocation via *note mps_free(): 1f.

   * Supports allocation via *note allocation points: 63.  If an
     allocation point is created in an AMS pool, the call to *note
     mps_ap_create_k(): af. takes one optional keyword argument,
     ‘MPS_KEY_RANK’.

   * Supports *note allocation frames: 27d. but does not use them to
     improve the efficiency of stack-like allocation.

   * Does not support *note segregated allocation caches: 1b2.

   * Garbage collections are scheduled automatically.  See *note
     Scheduling of collections: 226.

   * Does not use *note generational garbage collection: e, so blocks
     are never promoted out of the generation in which they are
     allocated.

   * Blocks may contain *note exact references: 61. to blocks in the
     same or other pools, or *note ambiguous references: 9f. (unless the
     ‘MPS_KEY_AMS_SUPPORT_AMBIGUOUS’ keyword argument is set to ‘FALSE’
     when creating the pool).  Blocks may not contain *note weak
     references (1): c, and may not use *note remote references: 35d.

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable.

   * Blocks do not have *note dependent objects: ff.

   * Blocks that are not *note reachable: 96. from a *note root: 97. are
     automatically *note reclaimed: 4a.

   * Blocks are *note scanned: 65.

   * Blocks may only be referenced by *note base pointers: 1aa. (unless
     they have *note in-band headers: 1d1.).

   * Blocks are not protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may be registered for *note finalization: b.

   * Blocks must belong to an *note object format: 39. which provides
     *note scan: 73. and *note skip: 81. methods.

   * Blocks may have *note in-band headers: 1d1.


File: MemoryPoolSystem.info,  Node: AMS interface,  Prev: AMS properties,  Up: AMS Automatic Mark and Sweep

3.6.2 AMS interface
-------------------

     #include "mpscams.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_ams (void)

     Return the *note pool class: 10. for an AMS (Automatic Mark &
     Sweep) *note pool: 18.

     When creating an AMS pool, *note mps_pool_create_k(): 166. requires
     one *note keyword argument: 53.:

        * ‘MPS_KEY_FORMAT’ (type *note mps_fmt_t: 141.) specifies the
          *note object format: 39. for the objects allocated in the
          pool.  The format must provide a *note scan method: 73. and a
          *note skip method: 81.

     It accepts three optional keyword arguments:

        * ‘MPS_KEY_CHAIN’ (type *note mps_chain_t: 13a.) specifies the
          *note generation chain: e2. for the pool.  If not specified,
          the pool will use the arena’s default chain.

        * ‘MPS_KEY_GEN’ (type ‘unsigned’) specifies the *note
          generation: e1. in the chain into which new objects will be
          allocated.  If you pass your own chain, then this defaults to
          ‘0’, but if you didn’t (and so use the arena’s default chain),
          then an appropriate generation is used.

          Note that AWL does not use generational garbage collection, so
          blocks remain in this generation and are not promoted.

        * ‘MPS_KEY_AMS_SUPPORT_AMBIGUOUS’ (type *note mps_bool_t: 129,
          default ‘TRUE’) specifies whether references to blocks in the
          pool may be ambiguous.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_FORMAT, fmt);
              res = mps_pool_create_k(&pool, arena, mps_class_ams(), args);
          } MPS_ARGS_END(args);

     When creating an *note allocation point: 63. on an AMS pool, *note
     mps_ap_create_k(): af. accepts one optional keyword argument:

        * ‘MPS_KEY_RANK’ (type *note mps_rank_t: 146, default *note
          mps_rank_exact(): 9d.) specifies the *note rank: 9e. of
          references in objects allocated on this allocation point.  It
          must be *note mps_rank_exact(): 9d. (if the objects allocated
          on this allocation point will contain *note exact references:
          61.), or *note mps_rank_ambig(): 20a. (if the objects may
          contain *note ambiguous references: 9f.).

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_RANK, mps_rank_ambig());
              res = mps_ap_create_k(&ap, ams_pool, args);
          } MPS_ARGS_END(args);

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_ams_debug (void)

     A *note debugging: 10d. version of the AMS pool class.

     When creating a debugging AMS pool, *note mps_pool_create_k(): 166.
     accepts the following keyword arguments: ‘MPS_KEY_FORMAT’,
     ‘MPS_KEY_CHAIN’, ‘MPS_KEY_GEN’, and ‘MPS_KEY_AMS_SUPPORT_AMBIGUOUS’
     are as described above, and ‘MPS_KEY_POOL_DEBUG_OPTIONS’ specifies
     the debugging options.  See *note mps_pool_debug_option_s: 143.


File: MemoryPoolSystem.info,  Node: AWL Automatic Weak Linked,  Next: LO Leaf Object,  Prev: AMS Automatic Mark and Sweep,  Up: Pool reference

3.7 AWL (Automatic Weak Linked)
===============================

'AWL' is an *note automatically managed: 9. *note non-moving: 5e. *note
pool class: 10. that may contain *note weak references (1): c.

The purpose of this pool class is to allow the client to implement *note
weak-key: fb, *note weak-value: fc, and *note doubly weak hash tables:
fd.

In a weak-key hash table, the keys are weakly referenced, so their
presence in the table will not prevent the key object from being garbage
collected.  Once the key is no longer *note reachable: 96, weak
references to it may get *note splatted: 245. (that is, replaced with
null pointers).  Once that has happened, the client program can’t get at
the value corresponding to the key any more, so the implementation is
free to splat the value slot as well.

AWL allows the implementation to splat the value slot at the same time
that the weak key slot is splatted.  (Or the other way around for
weak-value tables.)  See *note Dependent objects: 100.

See *note Weak hash tables: f9. in the *note Advanced topics: e6.
section of the user guide for a detailed example of using this pool
class.

     Note: AWL is the only pool in the open source MPS that allows its
     formatted objects to contain weak references.  It was designed to
     support the weak hash tables in Open Dylan(1), and may be awkward
     to use for other use cases.  If you need more general handling of
     weak references, *note contact us: d8.

* Menu:

* AWL properties::
* Dependent objects::
* Protection faults::
* Caution::
* AWL interface::

   ---------- Footnotes ----------

   (1) http://opendylan.org/


File: MemoryPoolSystem.info,  Node: AWL properties,  Next: Dependent objects,  Up: AWL Automatic Weak Linked

3.7.1 AWL properties
--------------------

   * Does not support allocation via *note mps_alloc(): ad. or
     deallocation via *note mps_free(): 1f.

   * Supports allocation via *note allocation points: 63.  If an
     allocation point is created in an AWL pool, the call to *note
     mps_ap_create_k(): af. accepts one optional keyword argument,
     ‘MPS_KEY_RANK’.

   * Supports *note allocation frames: 27d. but does not use them to
     improve the efficiency of stack-like allocation.

   * Does not support *note segregated allocation caches: 1b2.

   * Garbage collections are scheduled automatically.  See *note
     Scheduling of collections: 226.

   * Does not use *note generational garbage collection: e, so blocks
     are never promoted out of the generation in which they are
     allocated.

   * Blocks may contain *note exact references: 61. or *note weak
     references (1): c. to blocks in the same or other pools (but may
     not contain *note ambiguous references: 9f, and may not use *note
     remote references: 35d.).

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable.

   * Blocks may have *note dependent objects: ff.

   * Blocks that are not *note reachable: 96. from a *note root: 97. are
     automatically *note reclaimed: 4a.

   * Blocks are *note scanned: 65.

   * Blocks may only be referenced by *note base pointers: 1aa. (unless
     they have *note in-band headers: 1d1.).

   * Blocks may be protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may be registered for *note finalization: b.

   * Blocks must belong to an *note object format: 39. which provides
     *note scan: 73. and *note skip: 81. methods.

   * Blocks may have *note in-band headers: 1d1.


File: MemoryPoolSystem.info,  Node: Dependent objects,  Next: Protection faults,  Prev: AWL properties,  Up: AWL Automatic Weak Linked

3.7.2 Dependent objects
-----------------------

In order to support prompt deletion of values in a *note weak-key hash
table: fb. when the key is *note splatted: 245. (and prompt deletion of
keys in a *note weak-value hash table: fc.), an AWL pool allows each
object to have a 'dependent object'.  (This is where the “Linked” in the
name of the pool class comes from.)

The dependent object is specified by the ‘MPS_KEY_AWL_FIND_DEPENDENT’
keyword argument to *note mps_pool_create_k(): 166. when creating an AWL
pool.  This is a function of type *note mps_awl_find_dependent_t: 36e.
that takes the address of an object in the pool and returns the address
of its dependent object (or a null pointer if there is no corresponding
dependent object).

When *note scanning: 65. an object in an AWL pool, the MPS ensures that
the dependent object is not protected.  This means that the *note scan
method: 73. in the pool’s *note object format: 39. can read or write the
dependent object.

If an object contains a reference to its dependent object, you should
*note fix: b4. that reference, and be aware that if it is a weak
reference then it may be splatted when the dependent object dies.

The way you would normally use this feature in a weak hash table would
be to put the table’s keys in one object, and its values in another.
(This would be necessary in any case, because the MPS does not support a
mixture of *note exact references: 61. and *note weak references (1): c.
in the same object.)  The dependent object for the keys objects is the
values object, and vice versa (if necessary).  The scan method looks out
for the splatting of a reference, and when this is detected, it splats
the corresponding reference in the dependent object.

For example:

     obj_t obj_deleted;              /* deleted entry in hash table */

     typedef struct weak_array_s {
         struct weak_array_s *dependent;
         size_t length;              /* tagged as "length * 2 + 1" */
         obj_t slot[1];
     } weak_array_s, *weak_array_t;

     typedef weak_table_s {
         type_s type;                /* TYPE_WEAK_TABLE */
         weak_array_t keys, values;
     } weak_table_s, *weak_table_t;

     mps_addr_t weak_array_find_dependent(mps_addr_t addr)
     {
         weak_array_t a = addr;
         return a->dependent;
     }

     mps_res_t weak_array_scan(mps_ss_t ss, mps_addr_t base, mps_addr_t limit)
     {
         MPS_SCAN_BEGIN(ss) {
             while (base < limit) {
                 mps_addr_t p;
                 weak_array_t a = base;
                 size_t i, length = a->length >> 1; /* untag */
                 p = a->dependent;
                 MPS_FIX12(ss, &p);
                 a->dependent = p;
                 for (i = 0; i < length; ++i) {
                     p = a->slot[i];
                     if (MPS_FIX1(ss, p)) {
                         mps_res_t res = MPS_FIX2(ss, &p);
                         if (res != MPS_RES_OK) return res;
                         if (p == NULL && a->dependent) {
                             /* key/value was splatted: splat value/key too */
                             a->dependent->slot[i] = obj_deleted;
                             a->slot[i] = obj_deleted;
                         } else {
                             a->slot[i] = p;
                         }
                     }
                 }
                 base += offsetof(weak_array_s, slot) + a->length * sizeof a->slot[0];
             }
         } MPS_SCAN_END(ss);
         return MPS_RES_OK;
     }

     Note: The ‘length’ field of the ‘weak_array_s’ structure contains
     the value ‘length * 2 + 1’ so that it cannot be mistaken for a
     pointer.  See *note Caution: 101. below.


File: MemoryPoolSystem.info,  Node: Protection faults,  Next: Caution,  Prev: Dependent objects,  Up: AWL Automatic Weak Linked

3.7.3 Protection faults
-----------------------

AWL has another special power: it enables better handing of *note
protection faults: 1d7. on 'weak objects' (objects containing *note weak
references (1): c.).

To explain the benefit we first need to describe the problem.  The MPS
uses a *note read barrier: 1d6. to perform *note incremental garbage
collection: d.  When the client program tries to read an object
containing *note weak references (1): c, the MPS may have *note
protected: 1fd. it so that the MPS can process the object before the
client gets to see it.

The problem is that the client program may try to access a weak object
at a point in the *note collection cycle: 1a2. when the MPS cannot yet
determine the status of the objects that the weak object refers to.
What the MPS does in this situation is assume that all the referenced
objects are going to live.  This assumption is correct but conservative;
it may result in objects that are weakly referenced staying alive for
longer than they need to.  In the worst case this can result in a very
large amount of memory being used by objects that are no longer needed.

In order to combat this problem the MPS sometimes does the following:
Instead of processing the entire weak object and unprotecting it, so
that the client program can access the object, the MPS may emulate the
processor instruction.  When this happens, the MPS doesn’t process the
entire weak object; it only processes the exact location that was being
accessed (typically a single word).  It emulates the processor
instruction, and it keeps the object protected.  This happens invisibly
from the client program’s perspective: it’s exactly as if the
instruction executed as normal.

Naturally this emulation business is delicate and involves staring at
the most badly written parts of low-level processor architecture manuals
for days.

Emulation of accesses to protected objects happens when all of the
following are true:

  1. The object is a weak object allocated in an AWL pool.

  2. The MPS is running on Linux/IA-32 or Windows/IA-32.  Extending this
     list to new (reasonable) operating systems should be tolerable (for
     example, macOS/IA-32).  Extending this to new processor
     architectures requires more work.

  3. The processor instruction that is accessing the object is of a
     suitable simple form.  The MPS doesn’t contain an emulator for all
     possible instructions that might access memory, so currently it
     only recognizes and emulates a simple ‘MOV’ from memory to a
     register or vice-versa.

*note Contact us: d8. if you need emulation of access to weak references
for new operating systems, processor architectures, or memory access
instructions.


File: MemoryPoolSystem.info,  Node: Caution,  Next: AWL interface,  Prev: Protection faults,  Up: AWL Automatic Weak Linked

3.7.4 Caution
-------------

Because of the instruction emulation described in *note Protection
faults: 36f. above, AWL places the following restriction on the format
of objects allocated in it:

   * Each slot in an object must either be a valid word-aligned
     reference, or else the bottom bits of the word must be non-zero so
     that it does not look like an aligned pointer.

     “Aligned pointer” means a word whose numeric value (that is, its
     value when treated as an unsigned integer) is a multiple of the
     size of a pointer.  If you’re using a 64-bit architecture, that
     means that an aligned pointer is a multiple of 8 and its bottom
     three bits are zero.

     The bottom line is that references from an object in an AWL pool
     must be untagged and aligned, and integers must be tagged with a
     non-zero tag.

Normally one would cope with this restriction by allocating the table
metadata in a pool belonging to another pool class, and only allocating
the arrays of keys and values in an AWL pool.  See *note the example:
100. above.


File: MemoryPoolSystem.info,  Node: AWL interface,  Prev: Caution,  Up: AWL Automatic Weak Linked

3.7.5 AWL interface
-------------------

     #include "mpscawl.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_awl (void)

     Return the *note pool class: 10. for an AWL (Automatic Weak Linked)
     *note pool: 18.

     When creating an AWL pool, *note mps_pool_create_k(): 166. requires
     one *note keyword argument: 53.:

        * ‘MPS_KEY_FORMAT’ (type *note mps_fmt_t: 141.) specifies the
          *note object format: 39. for the objects allocated in the
          pool.  The format must provide a *note scan method: 73. and a
          *note skip method: 81.

     It accepts three optional keyword arguments:

        * ‘MPS_KEY_AWL_FIND_DEPENDENT’ (type *note
          mps_awl_find_dependent_t: 36e.) is a function that specifies
          how to find the *note dependent object: ff. for an object in
          the pool.  This defaults to a function that always returns
          ‘NULL’ (meaning that there is no dependent object).

        * ‘MPS_KEY_CHAIN’ (type *note mps_chain_t: 13a.) specifies the
          *note generation chain: e2. for the pool.  If not specified,
          the pool will use the arena’s default chain.

        * ‘MPS_KEY_GEN’ (type ‘unsigned’) specifies the *note
          generation: e1. in the chain into which new objects will be
          allocated.  If you pass your own chain, then this defaults to
          ‘0’, but if you didn’t (and so use the arena’s default chain),
          then an appropriate generation is used.

          Note that AWL does not use generational garbage collection, so
          blocks remain in this generation and are not promoted.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_FORMAT, fmt);
              MPS_ARGS_ADD(args, MPS_KEY_AWL_FIND_DEPENDENT, find_dependent);
              res = mps_pool_create_k(&pool, arena, mps_class_awl(), args);
          } MPS_ARGS_END(args);

     When creating an *note allocation point: 63. on an AWL pool, *note
     mps_ap_create_k(): af. accepts one optional keyword argument:

        * ‘MPS_KEY_RANK’ (type *note mps_rank_t: 146, default *note
          mps_rank_exact(): 9d.) specifies the *note rank: 9e. of
          references in objects allocated on this allocation point.  It
          must be *note mps_rank_exact(): 9d. (if the objects allocated
          on this allocation point will contain *note exact references:
          61.), or *note mps_rank_weak(): 20c. (if the objects will
          contain *note weak references (1): c.).

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_RANK, mps_rank_weak());
              res = mps_ap_create_k(&ap, awl_pool, args);
          } MPS_ARGS_END(args);

 -- C Type: typedef *note mps_addr_t: 11d.
          (*mps_awl_find_dependent_t)(*note mps_addr_t: 11d. addr)

     The type of functions that find the *note dependent object: ff. for
     an object in an AWL pool.

     ‘addr’ is the address of an object in an AWL pool.

     Returns the address of the corresponding dependent object, or a
     null pointer if there is none.

     The dependent object need not be in memory managed by the MPS, but
     if it is, then it must be in a *note non-moving: 5e. pool in the
     same arena as ‘addr’.


File: MemoryPoolSystem.info,  Node: LO Leaf Object,  Next: MFS Manual Fixed Small,  Prev: AWL Automatic Weak Linked,  Up: Pool reference

3.8 LO (Leaf Object)
====================

'LO' is an *note automatically managed: 9. *note pool class: 10. for
*note leaf objects: 107. (objects that contain no references).  It does
not move or protect its objects.

This pool class is intended for unstructured data that needs to be
accessed by *note foreign code: 10b.  It’s ideal for allocating a buffer
that needs to be passed to an operating system I/O function.

     Note: A thread that reads or writes from blocks allocated in this
     pool need not be *note registered with the arena: 1f9. so long as
     the *note liveness: 78. of the block is independent of that thread.

     This means that you can launch a thread to read or write a buffer
     allocated in this pool, without having to register the thread, so
     long as you ensure that the buffer remains alive until the thread
     has finished (for example, by keeping a reference to the buffer in
     a *note root: 97. or a *note scanned: 65. object).

If LO is used to allocate large numbers of small objects, the garbage
collection performance will degrade.  For leaf objects that can move and
be protected, it is better to use *note AMCZ (Automatic Mostly-Copying
Zero-rank): 89. instead.

* Menu:

* LO properties::
* LO interface::


File: MemoryPoolSystem.info,  Node: LO properties,  Next: LO interface,  Up: LO Leaf Object

3.8.1 LO properties
-------------------

   * Does not support allocation via *note mps_alloc(): ad. or
     deallocation via *note mps_free(): 1f.

   * Supports allocation via *note allocation points: 63.  If an
     allocation point is created in a LO pool, the call to *note
     mps_ap_create_k(): af. takes no keyword arguments.

   * Supports *note allocation frames: 27d. but does not use them to
     improve the efficiency of stack-like allocation.

   * Does not support *note segregated allocation caches: 1b2.

   * Garbage collections are scheduled automatically.  See *note
     Scheduling of collections: 226.

   * Does not use *note generational garbage collection: e, so blocks
     are never promoted out of the generation in which they are
     allocated.

   * Blocks may not contain *note references: 24. to blocks in
     automatically managed pools.

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable.

   * Blocks do not have *note dependent objects: ff.

   * Blocks that are not *note reachable: 96. from a *note root: 97. are
     automatically *note reclaimed: 4a.

   * Blocks are not *note scanned: 65.  A consequence of this is that
     the pool’s *note object format: 39. need not provide a *note scan
     method: 73.

   * Blocks may only be referenced by *note base pointers: 1aa. (unless
     they have *note in-band headers: 1d1.).

   * Blocks are not protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may be registered for *note finalization: b.

   * Blocks must belong to an *note object format: 39. which provides
     *note scan: 73. and *note skip: 81. methods.

   * Blocks may have *note in-band headers: 1d1.


File: MemoryPoolSystem.info,  Node: LO interface,  Prev: LO properties,  Up: LO Leaf Object

3.8.2 LO interface
------------------

     #include "mpsclo.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_lo (void)

     Return the *note pool class: 10. for an LO (Leaf Object) *note
     pool: 18.

     When creating an LO pool, *note mps_pool_create_k(): 166. requires
     one *note keyword argument: 53.:

        * ‘MPS_KEY_FORMAT’ (type *note mps_fmt_t: 141.) specifies the
          *note object format: 39. for the objects allocated in the
          pool.  The format must provide a *note skip method: 81.

     It accepts two optional keyword arguments:

        * ‘MPS_KEY_CHAIN’ (type *note mps_chain_t: 13a.) specifies the
          *note generation chain: e2. for the pool.  If not specified,
          the pool will use the arena’s default chain.

        * ‘MPS_KEY_GEN’ (type ‘unsigned’) specifies the *note
          generation: e1. in the chain into which new objects will be
          allocated.  If you pass your own chain, then this defaults to
          ‘0’, but if you didn’t (and so use the arena’s default chain),
          then an appropriate generation is used.

          Note that LO does not use generational garbage collection, so
          blocks remain in this generation and are not promoted.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_FORMAT, fmt);
              res = mps_pool_create_k(&pool, arena, mps_class_lo(), args);
          } MPS_ARGS_END(args);


File: MemoryPoolSystem.info,  Node: MFS Manual Fixed Small,  Next: MVFF Manual Variable First Fit,  Prev: LO Leaf Object,  Up: Pool reference

3.9 MFS (Manual Fixed Small)
============================

'MFS' is an *note manually managed: 8. *note pool class: 10. for small
objects of fixed size.

Unlike other manual pool classes, it is not subject to *note internal
fragmentation: 379.: if the population remains bounded, the memory usage
remains bounded too.  On the other hand, unlike *note MVT (Manual
Variable Temporal): 1bc. and *note MVFF (Manual Variable First Fit):
10c. it does not return unused memory to the arena for reuse by other
pools.

The implementation is very simple: unlike most other *note pool classes:
10. which store their control structures separately from the allocated
blocks, MFS maintains a stack of free blocks using a pointer in the free
block.  *note mps_alloc(): ad. pops this stack and *note mps_free(): 1f.
pushes it.

* Menu:

* MFS properties::
* MFS interface::


File: MemoryPoolSystem.info,  Node: MFS properties,  Next: MFS interface,  Up: MFS Manual Fixed Small

3.9.1 MFS properties
--------------------

   * Supports allocation via *note mps_alloc(): ad. and deallocation via
     *note mps_free(): 1f.

   * Does not support allocation via *note allocation points: 63.

   * Does not support *note allocation frames: 27d.

   * Supports *note segregated allocation caches: 1b2. (but using one
     would be pointless, since all blocks are the same size).

   * There are no garbage collections in this pool.

   * Blocks may not contain *note references: 24. to blocks in
     automatically managed pools (unless these are registered as *note
     roots: 97.).

   * Allocations are fixed in size.

   * The *note alignment: 68. of blocks is not configurable: it is the
     *note natural alignment: 70. of the platform (see *note
     MPS_PF_ALIGN: 6f.).

   * Blocks do not have *note dependent objects: ff.

   * Blocks are not automatically *note reclaimed: 4a.

   * Blocks are not *note scanned: 65.

   * Blocks are not protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may not be registered for *note finalization: b.

   * Blocks must not belong to an *note object format: 39.


File: MemoryPoolSystem.info,  Node: MFS interface,  Prev: MFS properties,  Up: MFS Manual Fixed Small

3.9.2 MFS interface
-------------------

     #include "mpscmfs.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_mfs (void)

     Return the *note pool class: 10. for an MFS (Manual Fixed Small)
     *note pool: 18.

     When creating an MFS pool, *note mps_pool_create_k(): 166. requires
     one *note keyword argument: 53.:

        * ‘MPS_KEY_MFS_UNIT_SIZE’ (type ‘size_t’) is the *note size:
          183. of blocks that will be allocated from this pool, in *note
          bytes (1): 17c.  It must be at least one *note word: 37c.

     In addition, *note mps_pool_create_k(): 166. accepts one optional
     keyword argument:

        * ‘MPS_KEY_EXTEND_BY’ (type ‘size_t’, default 65536) is the
          *note size: 183. of extent that the pool will request from the
          *note arena: 16.  For efficiency, this should be much larger
          than ‘MPS_KEY_MFS_UNIT_SIZE’, so that many blocks fit into
          each extent.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_MFS_UNIT_SIZE, 1024);
              MPS_ARGS_ADD(args, MPS_KEY_EXTEND_BY, 1024 * 1024);
              res = mps_pool_create_k(&pool, arena, mps_class_mfs(), args);
          } MPS_ARGS_END(args);


File: MemoryPoolSystem.info,  Node: MVFF Manual Variable First Fit,  Next: MVT Manual Variable Temporal,  Prev: MFS Manual Fixed Small,  Up: Pool reference

3.10 MVFF (Manual Variable First Fit)
=====================================

'MVFF' *note manually manages: 8. variable-sized, unformatted objects.
It uses the *note first fit: 37f. *note allocation policy: 380. for
blocks allocated via *note mps_alloc(): ad.

*note Johnstone (1997): 381. found that in his test cases:

     No version of *note best fit: 382. had more than 5% actual *note
     fragmentation: 383.  This is also true for all versions of first
     fit that used an *note address-ordered free list: 384, and the two
     versions of first fit that used a *note FIFO free list: 385.  This
     strongly suggests that the basic best-fit algorithm and the
     first-fit algorithm with an address-ordered free list are very
     robust algorithms.

The MVFF pool class also supports buffered allocation (that is,
allocation via *note allocation points: 63.), and in this case, the
allocation policy is different: the buffers are filled according to the
*note worst fit: 386. policy, and allocation always proceeds upwards
from the base.

Buffered and unbuffered allocation can be used at the same time, but the
first allocation point must be created before any call to *note
mps_alloc(): ad.

It is usually not advisable to use buffered and unbuffered allocation on
the same pool, because the worst-fit policy of buffer filling will grab
all the large blocks, leading to severe fragmentation.  If you need both
forms of allocation, use two separate pools.

* Menu:

* MVFF properties::
* MVFF interface::


File: MemoryPoolSystem.info,  Node: MVFF properties,  Next: MVFF interface,  Up: MVFF Manual Variable First Fit

3.10.1 MVFF properties
----------------------

   * Supports allocation via *note mps_alloc(): ad.

   * Supports allocation via *note allocation points: 63.  If an
     allocation point is created in an MVFF pool, the call to *note
     mps_ap_create_k(): af. takes no keyword arguments.

   * Supports deallocation via *note mps_free(): 1f.

   * Supports *note allocation frames: 27d. but does not use them to
     improve the efficiency of stack-like allocation.

   * Supports *note segregated allocation caches: 1b2.

   * There are no garbage collections in this pool.

   * Blocks may not contain *note references: 24. to blocks in
     automatically managed pools (unless these are registered as *note
     roots: 97.).

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable, but may not be
     smaller than ‘sizeof(void *)’.

   * Blocks do not have *note dependent objects: ff.

   * Blocks are not automatically *note reclaimed: 4a.

   * Blocks are not *note scanned: 65.

   * Blocks are not protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may not be registered for *note finalization: b.

   * Blocks must not belong to an *note object format: 39.


File: MemoryPoolSystem.info,  Node: MVFF interface,  Prev: MVFF properties,  Up: MVFF Manual Variable First Fit

3.10.2 MVFF interface
---------------------

     #include "mpscmvff.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_mvff (void)

     Return the *note pool class: 10. for an MVFF (Manual Variable First
     Fit) *note pool: 18.

     When creating an MVFF pool, *note mps_pool_create_k(): 166. accepts
     seven optional *note keyword arguments: 53.:

        * ‘MPS_KEY_EXTEND_BY’ (type ‘size_t’, default 65536) is the
          *note size: 183. of block that the pool will request from the
          *note arena: 16.

        * ‘MPS_KEY_MEAN_SIZE’ (type ‘size_t’, default 32) is the
          predicted mean size of blocks that will be allocated from the
          pool.  This is a 'hint' to the MPS: the pool will be less
          efficient if this is wrong, but nothing will break.

        * ‘MPS_KEY_ALIGN’ (type *note mps_align_t: 128, default is *note
          MPS_PF_ALIGN: 6f.) is the *note alignment: 68. of the
          addresses allocated (and freed) in the pool.  The minimum
          alignment supported by pools of this class is ‘sizeof(void *)’
          and the maximum is the arena grain size (see
          ‘MPS_KEY_ARENA_GRAIN_SIZE’).

        * ‘MPS_KEY_SPARE’ (type ‘double’, default 0.75) is the maximum
          proportion of memory that the pool will keep spare for future
          allocations.  If the proportion of memory that’s free exceeds
          this, then the pool will return some of it to the arena for
          use by other pools.

        * ‘MPS_KEY_MVFF_ARENA_HIGH’ (type *note mps_bool_t: 129, default
          false) determines whether new blocks are acquired at high
          addresses (if true), or at low addresses (if false).

        * ‘MPS_KEY_MVFF_SLOT_HIGH’ (1) (type *note mps_bool_t: 129,
          default false) determines whether to search for the highest
          addressed free area (if true) or lowest (if false) when
          allocating using *note mps_alloc(): ad.

        * ‘MPS_KEY_MVFF_FIRST_FIT’ (2) (type *note mps_bool_t: 129,
          default true) determines whether to allocate from the highest
          address in a found free area (if true) or lowest (if false)
          when allocating using *note mps_alloc(): ad.

     The defaults yield a simple first-fit allocator.  Specify
     ‘MPS_KEY_MVFF_ARENA_HIGH’ and ‘MPS_KEY_MVFF_SLOT_HIGH’ true, and
     ‘MPS_KEY_MVFF_FIRST_FIT’ false to get a first-fit allocator that
     works from the top of memory downwards.  Other combinations may be
     useful in special circumstances.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_EXTEND_BY, 1024 * 1024);
              MPS_ARGS_ADD(args, MPS_KEY_MEAN_SIZE, 32);
              MPS_ARGS_ADD(args, MPS_KEY_ALIGN, 8);
              MPS_ARGS_ADD(args, MPS_KEY_MVFF_ARENA_HIGH, 1);
              MPS_ARGS_ADD(args, MPS_KEY_MVFF_SLOT_HIGH, 1);
              MPS_ARGS_ADD(args, MPS_KEY_MVFF_FIRST_FIT, 0);
              res = mps_pool_create_k(&pool, arena, mps_class_mvff(), args);
          } MPS_ARGS_END(args);

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_mvff_debug (void)

     A *note debugging: 10d. version of the MVFF pool class.

     When creating a debugging MVFF pool, *note mps_pool_create_k():
     166. accepts eight optional *note keyword arguments: 53.:
     ‘MPS_KEY_EXTEND_BY’, ‘MPS_KEY_MEAN_SIZE’, ‘MPS_KEY_ALIGN’,
     ‘MPS_KEY_SPARE’, ‘MPS_KEY_MVFF_ARENA_HIGH’,
     ‘MPS_KEY_MVFF_SLOT_HIGH’, and ‘MPS_KEY_MVFF_FIRST_FIT’ are as
     described above, and ‘MPS_KEY_POOL_DEBUG_OPTIONS’ specifies the
     debugging options.  See *note mps_pool_debug_option_s: 143.

   ---------- Footnotes ----------

   (1) Allocation points are not affected by ‘MPS_KEY_MVFF_SLOT_HIGH’ or
‘MPS_KEY_MVFF_FIRST_FIT’.  They use a worst-fit policy in order to
maximise the number of in-line allocations.

   (2) Allocation points are not affected by ‘MPS_KEY_MVFF_SLOT_HIGH’ or
‘MPS_KEY_MVFF_FIRST_FIT’.  They use a worst-fit policy in order to
maximise the number of in-line allocations.


File: MemoryPoolSystem.info,  Node: MVT Manual Variable Temporal,  Next: SNC Stack No Checking,  Prev: MVFF Manual Variable First Fit,  Up: Pool reference

3.11 MVT (Manual Variable Temporal)
===================================

'MVT' *note manually manages: 8. variable-sized, unformatted objects.
It uses the 'temporal fit' *note allocation policy: 380.

* Menu:

* Temporal fit::
* MVT properties::
* MVT interface::


File: MemoryPoolSystem.info,  Node: Temporal fit,  Next: MVT properties,  Up: MVT Manual Variable Temporal

3.11.1 Temporal fit
-------------------

Temporal fit attempts to place consecutive allocations next to each
other.  It relies on delaying re-use as long as possible to permit freed
blocks to *note coalesce: 38c, thus maximizing the number of consecutive
allocations that can be co-located.  Temporal fit permits a very fast
allocator and a deallocator competitive in speed with all other known
policies.

Temporal fit is intended to take advantage of knowledge of object *note
lifetimes: b5.: either 'a priori' knowledge, or knowledge acquired by
profiling.  The best performance will be achieved by allocating objects
with similar expected death times together.

A simple policy can be implemented to take advantage of MVT. Object size
is typically well-correlated with object life-expectancy, and birth time
plus lifetime gives death time, so allocating objects of similar size
sequentially from the same pool instance should result in objects
allocated close to each other dying at about the same time.

An application that has several classes of objects of widely differing
life expectancy will best be served by creating a different MVT pool
instance for each life-expectancy class.  A more sophisticated policy
can use either the programmer’s knowledge of the expected lifetime of an
object, or any characteristic of objects that correlates with lifetime,
to choose an appropriate pool to allocate in.

Allocating objects with unknown or very different death times together
will pessimize the space performance of MVT.


File: MemoryPoolSystem.info,  Node: MVT properties,  Next: MVT interface,  Prev: Temporal fit,  Up: MVT Manual Variable Temporal

3.11.2 MVT properties
---------------------

   * Does not support allocation via *note mps_alloc(): ad.

   * Supports allocation via *note allocation points: 63. only.  If an
     allocation point is created in an MVT pool, the call to *note
     mps_ap_create_k(): af. takes no keyword arguments.

   * Supports deallocation via *note mps_free(): 1f.

   * Supports *note allocation frames: 27d. but does not use them to
     improve the efficiency of stack-like allocation.

   * Does not support *note segregated allocation caches: 1b2.

   * There are no garbage collections in this pool.

   * Blocks may not contain *note references: 24. to blocks in
     automatically managed pools (unless these are registered as *note
     roots: 97.).

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable, but may not be
     smaller than ‘sizeof(void *)’.

   * Blocks do not have *note dependent objects: ff.

   * Blocks are not automatically *note reclaimed: 4a.

   * Blocks are not *note scanned: 65.

   * Blocks are not protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may not be registered for *note finalization: b.

   * Blocks must not belong to an *note object format: 39.


File: MemoryPoolSystem.info,  Node: MVT interface,  Prev: MVT properties,  Up: MVT Manual Variable Temporal

3.11.3 MVT interface
--------------------

     #include "mpscmvt.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_mvt (void)

     Return the *note pool class: 10. for an MVT (Manual Variable
     Temporal) *note pool: 18.

     When creating an MVT pool, *note mps_pool_create_k(): 166. accepts
     six optional *note keyword arguments: 53.:

        * ‘MPS_KEY_ALIGN’ (type *note mps_align_t: 128, default is *note
          MPS_PF_ALIGN: 6f.) is the *note alignment: 68. of the
          addresses allocated (and freed) in the pool.  The minimum
          alignment supported by pools of this class is ‘sizeof(void *)’
          and the maximum is the arena grain size (see
          ‘MPS_KEY_ARENA_GRAIN_SIZE’).

        * ‘MPS_KEY_MIN_SIZE’ (type ‘size_t’, default is *note
          MPS_PF_ALIGN: 6f.) is the predicted minimum size of blocks
          that will be allocated from the pool.

        * ‘MPS_KEY_MEAN_SIZE’ (type ‘size_t’, default 32) is the
          predicted mean size of blocks that will be allocated from the
          pool.

        * ‘MPS_KEY_MAX_SIZE’ (type ‘size_t’, default 8192) is the
          predicted maximum size of blocks that will be allocated from
          the pool.  Partial freeing is not supported for blocks larger
          than this; doing so will result in the storage of the block
          never being reused.

     The three ‘SIZE’ arguments above are 'hints' to the MPS: the pool
     will be less efficient if they are wrong, but the only thing that
     will break is the partial freeing of large blocks.

        * ‘MPS_KEY_MVT_RESERVE_DEPTH’ (type *note mps_word_t: 6d,
          default 1024) is the expected hysteresis of the population of
          the pool.  When blocks are freed, the pool will retain
          sufficient storage to allocate this many blocks of the mean
          size for near term allocations (rather than immediately making
          that storage available to other pools).

          If a pool has a stable population, or one which only grows
          over the lifetime of the pool, or one which grows steadily and
          then shrinks steadily, use a reserve depth of 0.

          It is always safe to use a reserve depth of 0, but if the
          population typically fluctuates in a range (for example, the
          client program repeatedly creates and destroys a subset of
          blocks in a loop), it is more efficient for the pool to retain
          enough storage to satisfy that fluctuation.  For example, if a
          pool has an object population that typically fluctuates
          between 8,000 and 10,000, use a reserve depth of 2,000.

          The reserve will not normally be available to other pools for
          allocation, even when it is not used by the pool.  If this is
          undesirable, a reserve depth of 0 may be used for a pool whose
          object population does vary, at a slight cost in efficiency.
          The reserve does not guarantee any particular amount of
          allocation.

        * ‘MPS_KEY_MVT_FRAG_LIMIT’ (type ‘double’, default 0.3) may
          range from 0.0 to 1.0 (inclusive).  It sets an upper limit on
          the space overhead of an MVT pool, in case block death times
          and allocations do not correlate well.  If the free space
          managed by the pool as a ratio of all the space managed by the
          pool exceeds the fragmentation limit, the pool falls back to a
          first fit allocation policy, exploiting space more efficiently
          at a cost in time efficiency.  A fragmentation limit of 0.0
          would cause the pool to operate as a first-fit pool, at a
          significant cost in time efficiency: therefore this is not
          permitted.

          A fragmentation limit of 1.0 causes the pool to always use
          temporal fit (unless resources are exhausted).  If the objects
          allocated in the pool have similar lifetime expectancies, this
          mode will have the best time- and space-efficiency.  If the
          objects have widely varying lifetime expectancies, this mode
          will be time-efficient, but may be space-inefficient.  An
          intermediate setting can be used to limit the
          space-inefficiency of temporal fit due to varying object life
          expectancies.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_MIN_SIZE, 4);
              MPS_ARGS_ADD(args, MPS_KEY_MEAN_SIZE, 32);
              MPS_ARGS_ADD(args, MPS_KEY_MAX_SIZE, 1024);
              MPS_ARGS_ADD(args, MPS_KEY_MVT_RESERVE_DEPTH, 256);
              MPS_ARGS_ADD(args, MPS_KEY_MVT_FRAG_LIMIT, 0.5);
              res = mps_pool_create_k(&pool, arena, mps_class_mvt(), args);
          } MPS_ARGS_END(args);


File: MemoryPoolSystem.info,  Node: SNC Stack No Checking,  Prev: MVT Manual Variable Temporal,  Up: Pool reference

3.12 SNC (Stack No Checking)
============================

'SNC' is a *note manually managed: 8. *note pool class: 10. that
supports a stack-like protocol for allocation and deallocation using
*note allocation frames: 27d. on *note allocation points: 63.  See *note
Allocation frames: 27a.

If *note mps_ap_frame_pop(): 16d. is used on an allocation point in an
SNC pool (after a corresponding call to *note mps_ap_frame_push():
16e.), then the objects affected by the pop are assumed to be dead, and
are reclaimed by the collector without checking whether there are any
references to them.

This pool class is intended to be used to implement stack languages like
Forth and PostScript, where some objects are allocated in stack frames
and are known to be dead when the stack is popped, because the language
can ensure that objects that are kept alive when the stack is popped are
copied to the heap.

* Menu:

* SNC properties::
* SNC interface::


File: MemoryPoolSystem.info,  Node: SNC properties,  Next: SNC interface,  Up: SNC Stack No Checking

3.12.1 SNC properties
---------------------

   * Does not support allocation via *note mps_alloc(): ad.

   * Supports allocation via *note allocation points: 63. only.  If an
     allocation point is created in an SNC pool, the call to *note
     mps_ap_create_k(): af. accepts one optional keyword argument,
     ‘MPS_KEY_RANK’.

   * Does not support deallocation via *note mps_free(): 1f.

   * Supports *note allocation frames: 27d.

   * Does not support *note segregated allocation caches: 1b2.

   * Blocks may contain *note exact references: 61. to blocks in the
     same or other pools (but may not contain *note ambiguous
     references: 9f. or *note weak references (1): c, and may not use
     *note remote references: 35d.).

   * There are no garbage collections in this pool.

   * Allocations may be variable in size.

   * The *note alignment: 68. of blocks is configurable.

   * Blocks do not have *note dependent objects: ff.

   * Blocks are not automatically *note reclaimed: 4a.

   * Blocks are *note scanned: 65.

   * Blocks may only be referenced by *note base pointers: 1aa.

   * Blocks are not protected by *note barriers (1): 60.

   * Blocks do not *note move: 5d.

   * Blocks may not be registered for *note finalization: b.

   * Blocks must belong to an *note object format: 39. which provides
     *note scan: 73, *note skip: 81, and *note padding: 90. methods.

   * Blocks must not have *note in-band headers: 1d1.


File: MemoryPoolSystem.info,  Node: SNC interface,  Prev: SNC properties,  Up: SNC Stack No Checking

3.12.2 SNC interface
--------------------

     #include "mpscsnc.h"

 -- C Function: *note mps_pool_class_t: 1b4. mps_class_snc (void)

     Return the *note pool class: 10. for an SNC (Stack No Check) *note
     pool: 18.

     When creating an SNC pool, *note mps_pool_create_k(): 166. requires
     one *note keyword argument: 53.:

        * ‘MPS_KEY_FORMAT’ (type *note mps_fmt_t: 141.) specifies the
          *note object format: 39. for the objects allocated in the
          pool.  The format must provide a *note scan method: 73, a
          *note skip method: 81, and a *note padding method: 90.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_FORMAT, fmt);
              res = mps_pool_create_k(&pool, arena, mps_class_snc(), args);
          } MPS_ARGS_END(args);

     When creating an *note allocation point: 63. on an SNC pool, *note
     mps_ap_create_k(): af. accepts one optional keyword argument:

        * ‘MPS_KEY_RANK’ (type *note mps_rank_t: 146, default *note
          mps_rank_exact(): 9d.) specifies the *note rank: 9e. of
          references in objects allocated on this allocation point.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_RANK, mps_rank_exact());
              res = mps_ap_create_k(&ap, awl_pool, args);
          } MPS_ARGS_END(args);


File: MemoryPoolSystem.info,  Node: Design,  Next: Old design,  Prev: Pool reference,  Up: Top

4 Design
********

     Warning: The documents in this section are included from the
     working designs in the MPS source tree.  They are intended for
     developers of the MPS. They vary a great deal in detail depending
     on the risks associated with the things they describe.

* Menu:

* Fixed-length queues::
* Generic modules::
* Bootstrapping::
* Coalescing block structures::
* Fast high-resolution clock::
* MPS Configuration::
* The critical path through the MPS::
* Documentation::
* Execution environment::
* Fail-over allocator::
* Finalization: Finalization<3>.
* Free list allocator::
* New developer guide::
* Transliterating the alphabet into hexadecimal::
* C Style – formatting::
* C Style – naming::
* Review checklist::
* C interface design::
* Keyword arguments in the MPS::
* Lands::
* Lock module::
* Client message protocol::
* Monitor::
* Nailboards for ambiguously referenced segments::
* Pool classes: Pool classes<2>.
* Mutator context::
* Memory protection::
* POSIX implementation of protection module::
* Ranges of addresses::
* Ring data structure::
* Shield::
* Signatures in the MPS::
* Stack probe::
* Splay trees::
* Stack and register scanning::
* Tests::
* Multi-threaded testing::
* Thread manager::
* Thread safety in the MPS::
* Transforms: Transforms<2>.
* General MPS types::
* Library version mechanism::
* Virtual mapping::
* Walking formatted objects::
* Write barrier::
* The WriteF function::


File: MemoryPoolSystem.info,  Node: Fixed-length queues,  Next: Generic modules,  Up: Design

4.1 Fixed-length queues
=======================

* Menu:

* Introduction: Introduction<2>.
* Requirements::
* Interface: Interface<3>.


File: MemoryPoolSystem.info,  Node: Introduction<2>,  Next: Requirements,  Up: Fixed-length queues

4.1.1 Introduction
------------------

*note .intro;: 39a. This is the design of the ABQ module, which
implements a fixed-length queue of small objects.

*note .readership;: 39b. This document is intended for any MM developer.

*note .name;: 39c. The name ABQ originally stood for “Available Block
Queue” as the module is used by the MVT pool.


File: MemoryPoolSystem.info,  Node: Requirements,  Next: Interface<3>,  Prev: Introduction<2>,  Up: Fixed-length queues

4.1.2 Requirements
------------------

*note .req.push;: 39e. Clients can efficiently push new elements onto
the queue.

*note .req.pop;: 39f. Clients can efficiently pop elements from the
queue.

*note .req.empty;: 3a0. Clients can efficiently test whether the queue
is empty.

*note .req.abstract;: 3a1. The ABQ module does not know anything about
the elements in the queue other than their size.

*note .req.delete;: 3a2. Clients can delete elements from the queue.
(Note: not necessarily efficiently.)

*note .req.iterate;: 3a3. Clients can iterate over elements in the
queue.


File: MemoryPoolSystem.info,  Node: Interface<3>,  Prev: Requirements,  Up: Fixed-length queues

4.1.3 Interface
---------------

 -- C Type: typedef ABQStruct *ABQ

*note ABQ: 3a5. is the type of a queue.  It is an alias for ‘ABQStruct
*’.  ‘ABQStruct’ is defined in the header so that it can be inlined in
client structures: clients must not depend on its implementation
details.

 -- C Function: void ABQInit (Arena arena, ABQ abq, void *owner, Count
          elements, Size elementSize)

Initialize the queue ‘abq’.  The parameter ‘arena’ is the arena whose
control pool should be used to allocate the memory for the queue;
‘owner’ is passed to ‘MeterInit()’ for the statistics; ‘elements’ is the
maximum number of elements that can be stored in the queue; and
‘elementSize’ is the size of each element.

 -- C Function: void ABQFinish (Arena arena, ABQ abq)

Finish ‘abq’ and free all resources associated with it.

 -- C Function: *note Bool: 3a9. ABQPush (ABQ abq, void *element)

If the queue is full, leave it unchanged and return ‘FALSE’.  Otherwise,
push ‘element’ on to the queue and return ‘TRUE’.

 -- C Function: *note Bool: 3a9. ABQPop (ABQ abq, void *elementReturn)

If the queue is empty, return ‘FALSE’.  Otherwise, copy the first
element on the queue into the memory pointed to by ‘elementReturn’,
remove the element from the queue, and return ‘TRUE’.

 -- C Function: *note Bool: 3a9. ABQPeek (ABQ abq, void *elementReturn)

If the queue is empty, return ‘FALSE’.  Otherwise, copy the first
element on the queue into the memory pointed to by ‘elementReturn’ and
return ‘TRUE’.  (This is the same as *note ABQPop(): 3aa. except that
the queue is unchanged.)

 -- C Function: *note Bool: 3a9. ABQIsEmpty (ABQ abq)

If the queue is empty, return ‘TRUE’, otherwise return ‘FALSE’.

 -- C Function: *note Bool: 3a9. ABQIsFull (ABQ abq)

If the queue is full, return ‘TRUE’, otherwise return ‘FALSE’.

 -- C Function: *note Count: 3af. ABQDepth (ABQ abq)

Return the number of elements in the queue.

 -- C Type: typedef *note Bool: 3a9. (*ABQVisitor)(*note Bool: 3a9.
          *deleteReturn, void *element, void *closure)

A callback function for *note ABQIterate(): 3b1.  The parameter
‘element’ is an element in the queue, and ‘closure’ is the value
originally passed to *note ABQIterate(): 3b1.  This function must set
‘*deleteReturn’ to ‘FALSE’ if ‘element’ must be kept in the queue, or
‘TRUE’ if ‘element’ must be deleted from the queue.  It must return
‘TRUE’ if the iteration must continue, or ‘FALSE’ if the iteration must
stop after processing ‘element’.

 -- C Function: void ABQIterate (ABQ abq, ABQVisitor visitor, void
          *closure)

Call ‘visitor’ for each element in the queue, passing the element and
‘closure’.  See ‘ABQVisitor’ for details.


File: MemoryPoolSystem.info,  Node: Generic modules,  Next: Bootstrapping,  Prev: Fixed-length queues,  Up: Design

4.2 Generic modules
===================

* Menu:

* Introduction: Introduction<3>.
* Requirements: Requirements<2>.
* Design: Design<2>.
* Modules::
* Limitations of generic implementations::


File: MemoryPoolSystem.info,  Node: Introduction<3>,  Next: Requirements<2>,  Up: Generic modules

4.2.1 Introduction
------------------

*note .intro;: 3b7. This is the design of generic modules in the MPS.

*note .readership;: 3b8. Any MPS developer; anyone porting the MPS to a
new platform.

*note .overview;: 3b9. Generic modules provide implementations of
functional modules using only the features of the Standard C Library.
These implementations are partially functional or non-functional, but
provide a basis for ports of the MPS to new platforms.

*note .name;: 3ba. The name “ANSI” for the generic modules is
historical: the C language was originally standardized by the American
National Standards Institute, and so Standard C used to be known as
“ANSI C”.


File: MemoryPoolSystem.info,  Node: Requirements<2>,  Next: Design<2>,  Prev: Introduction<3>,  Up: Generic modules

4.2.2 Requirements
------------------

*note .req.port;: 3bc. The MPS must be portable to new platforms.
(Otherwise we can’t meet the needs of customers using new platforms.)

*note .req.port.rapid;: 3bd. The MPS should be portable to new platforms
rapidly.

*note .req.port.rapid.expert;: 3be. An expert MPS developer (who may be
a novice on the new platform) should be able to get a minimally useful
implementation of the MPS running on a new platform within a few hours.

*note .req.port.rapid.novice;: 3bf. A novice MPS developer (who is an
expert on the new platform) should be able to get the MPS running on a
new platform within a few days.


File: MemoryPoolSystem.info,  Node: Design<2>,  Next: Modules,  Prev: Requirements<2>,  Up: Generic modules

4.2.3 Design
------------

*note .sol.modules;: 3c1. Features of the MPS which can benefit from
platform-specific implementations are divided into 'functional modules',
with clean interfaces to the MPS and to each other.  See *note .mod:
3c2. for a list of these modules.  (This helps meet *note .req.port:
3bc. by isolating the platform dependencies, and it helps meet *note
.req.port.rapid: 3bd. because a porter can mix and match
implementations, using existing implementations where possible.)

*note .sol.generic;: 3c3. Each functional module has a generic
implementation using only features of the Standard C Library.  (This
helps meet *note .req.port.rapid: 3bd. because the MPS can be ported in
stages, starting with the generic modules and porting the modules needed
to meet the most urgent requirements.  The generic implementations help
meet *note .req.port.rapid.novice: 3bf. by providing clear and
illustrative examples.)

*note .sol.fallback;: 3c4. The interfaces to the modules are designed to
make it possible to implement *note .sol.generic: 3c3.  When a
platform-specific feature is needed to meet performance (or other
attribute) requirements, the interface also makes it possible to meet
the functional requirements while missing the attribute requirements.
See *note .sol.fallback.example: 3c5. for an example.  (This helps meet
*note .req.port.rapid: 3bd. by allowing the generic implementations to
meet many or most of the functional requirements.)

*note .sol.fallback.example;: 3c5. The MPS normally uses incremental
collection to meet requirements on pause times, but this requires
barriers.  The interface to the protection module is designed to make it
possible to write an implementation without barriers, via the function
*note ProtSync(): 3c6. that synchronizes the mutator with the collector.

*note .sol.test;: 3c7. There are makefiles for the pseudo-platforms
‘anangc’, ‘ananll’ and ‘ananmv’ that compile and test the generic
implementations.  See design.mps.config.opt(1) for the configuration
options used to implement these platforms.  (This supports *note
.req.port.rapid: 3bd. by making sure that the generic implementations
are working when it is time to use them.)

   ---------- Footnotes ----------

   (1) config.html#design.mps.config.opt


File: MemoryPoolSystem.info,  Node: Modules,  Next: Limitations of generic implementations,  Prev: Design<2>,  Up: Generic modules

4.2.4 Modules
-------------

*note .mod;: 3c2. This section lists the functional modules in the MPS.

*note .mod.lock;: 3ca. Locks.  See design.mps.lock(1).

*note .mod.prmc;: 3cb. Mutator context.  See design.mps.prmc(2).

*note .mod.prot;: 3cc. Memory protection.  See design.mps.prot(3).

*note .mod.sp;: 3cd. Stack probe.  See design.mps.sp(4).

*note .mod.ss;: 3ce. Stack scanning.  See design.mps.stack-scan(5).

*note .mod.th;: 3cf. Thread manager.  See design.mps.thread-manager(6).

*note .mod.vm;: 3d0. Virtual mapping.  See design.mps.vm(7).

   ---------- Footnotes ----------

   (1) lock.html

   (2) prmc.html

   (3) prot.html

   (4) sp.html

   (5) stack-scan.html

   (6) thread-manager.html

   (7) vm.html


File: MemoryPoolSystem.info,  Node: Limitations of generic implementations,  Prev: Modules,  Up: Generic modules

4.2.5 Limitations of generic implementations
--------------------------------------------

*note .lim;: 3d3. This section summarizes the limitations of the generic
implementations of the function modules.

*note .lim.lock;: 3d4. Requires a single-threaded mutator (see
design.mps.lock.impl.an(1)).

*note .lim.prmc;: 3d5. Does not support single-stepping of accesses (see
design.mps.prmc.impl.an.fault(2)) and requires a single-threaded mutator
(see design.mps.prmc.impl.an.suspend(3)).

*note .lim.prot;: 3d6. Does not support incremental collection (see
design.mps.prot.impl.an.sync(4)) and is not compatible with
implementations of the mutator context module that support
single-stepping of accesses (see design.mps.prot.impl.an.sync.issue(5)).

*note .lim.sp;: 3d7. Only suitable for use with programs that do not
handle stack overflow faults, or do not call into the MPS from the
handler (see design.mps.sp.issue.an(6)).

*note .lim.stack-scan;: 3d8. Assumes that the stack grows downwards and
that ‘setjmp()’ reliably captures the registers (see
design.mps.stack-scan.sol.stack.platform(7)).

*note .lim.th;: 3d9. Requires a single-threaded mutator (see
design.mps.thread-manager.impl.an.single(8)).

*note .lim.vm;: 3da. Maps all reserved addresses into main memory (see
design.mps.vm.impl.an.reserve(9)), thus using more main memory than a
platform-specific implementation.

   ---------- Footnotes ----------

   (1) lock.html#design.mps.lock.impl.an

   (2) prmc.html#design.mps.prmc.impl.an.fault

   (3) prmc.html#design.mps.prmc.impl.an.suspend

   (4) prot.html#design.mps.prot.impl.an.sync

   (5) prot.html#design.mps.prot.impl.an.sync.issue

   (6) sp.html#design.mps.sp.issue.an

   (7) stack-scan.html#design.mps.stack-scan.sol.stack.platform

   (8) thread-manager.html#design.mps.thread-manager.impl.an.single

   (9) vm.html#design.mps.vm.impl.an.reserve


File: MemoryPoolSystem.info,  Node: Bootstrapping,  Next: Coalescing block structures,  Prev: Generic modules,  Up: Design

4.3 Bootstrapping
=================

* Menu:

* Introduction: Introduction<4>.
* Bootstrapping problems::


File: MemoryPoolSystem.info,  Node: Introduction<4>,  Next: Bootstrapping problems,  Up: Bootstrapping

4.3.1 Introduction
------------------

*note .intro;: 3e1. This explains how the MPS gets started.

*note .readership;: 3e2. Any MPS developer.

*note .overview;: 3e3. The job of the MPS is to allocate memory to a
program.  Before it can allocate memory, the MPS needs to create data
structures to represent its internal state.  But before it can create
those data structures, it needs to allocate memory to store them in.
This bootstrapping problem affects the MPS at several points, which are
listed here, together with their solutions.


File: MemoryPoolSystem.info,  Node: Bootstrapping problems,  Prev: Introduction<4>,  Up: Bootstrapping

4.3.2 Bootstrapping problems
----------------------------

* Menu:

* Virtual memory descriptor::
* Arena descriptor::
* Arena’s free land::


File: MemoryPoolSystem.info,  Node: Virtual memory descriptor,  Next: Arena descriptor,  Up: Bootstrapping problems

4.3.2.1 Virtual memory descriptor
.................................

*note .vm;: 3e6. Before address space can be mapped into main memory,
the virtual memory descriptor must be initialized.  But before the
virtual memory descriptor can be initialized, some address space must be
mapped into main memory in order to store it.  See
design.vm.req.bootstrap(1).

*note .vm.sol;: 3e7. The virtual memory descriptor is allocated
initially on the stack, and then copied into its place in the chunk
after the memory for it has been mapped.  See
design.vm.sol.bootstrap(2).

   ---------- Footnotes ----------

   (1) vm#req.bootstrap

   (2) vm#sol.bootstrap


File: MemoryPoolSystem.info,  Node: Arena descriptor,  Next: Arena’s free land,  Prev: Virtual memory descriptor,  Up: Bootstrapping problems

4.3.2.2 Arena descriptor
........................

*note .arena;: 3ea. Before chunks of address space can be reserved and
mapped, the virtual memory arena descriptor must be initialized (so that
the chunks can be added to the arena’s chunk tree).  But before a
virtual memory arena descriptor can be initialized, address space must
be reserved and mapped in order to store it.

*note .arena.sol;: 3eb. A small amount of address space is reserved and
mapped directly via *note VMInit(): 3ec. and *note VMMap(): 3ed. (not
via the chunk system) in order to provide enough memory for the arena
descriptor.


File: MemoryPoolSystem.info,  Node: Arena’s free land,  Prev: Arena descriptor,  Up: Bootstrapping problems

4.3.2.3 Arena’s free land
.........................

*note .land;: 3ef. Before the arena can allocate memory, a range of
addresses must be inserted into the arena’s free land (so that the free
land can hand out memory from this range).  But before addresses can be
inserted into the arena’s free land, the free land’s block pool must
have memory from the arena to store the nodes in the tree representing
those addresses.

*note .land.sol;: 3f0. The arena has two “back door” mechanisms and uses
them in combination.

*note .land.sol.alloc;: 3f1. First, there is a mechanism for allocating
a page of memory directly from a chunk, bypassing the free land.

*note .land.sol.pool;: 3f2. Second, the free land’s block pool has an
option to prevent it extending itself by allocating memory from the
arena.  Instead, it fails allocations with ‘ResLIMIT’.  The free land’s
block pool also has a mechanism, ‘MFSExtend’ to extend it with a block
of memory.  When the free land fails with ‘ResLIMIT’ the arena uses
*note .land.sol.alloc: 3f1. to provide it with memory.


File: MemoryPoolSystem.info,  Node: Coalescing block structures,  Next: Fast high-resolution clock,  Prev: Bootstrapping,  Up: Design

4.4 Coalescing block structures
===============================

* Menu:

* Introduction: Introduction<5>.
* Requirements: Requirements<3>.
* Interface: Interface<4>.
* Implementation::
* Testing::
* Notes for future development::
* Risks::


File: MemoryPoolSystem.info,  Node: Introduction<5>,  Next: Requirements<3>,  Up: Coalescing block structures

4.4.1 Introduction
------------------

*note .intro;: 3f8. This is the design for impl.c.cbs, which implements
a data structure for the management of non-intersecting memory ranges,
with eager coalescence.

*note .readership;: 3f9. This document is intended for any MM developer.

*note .source;: 3fa. design.mps.poolmvt(1), design.mps.poolmvff(2).

*note .overview;: 3fb. The “coalescing block structure” is a set of
addresses (or a subset of address space), with provision for efficient
management of contiguous ranges, including insertion and deletion, high
level communication with the client about the size of contiguous ranges,
and detection of protocol violations.

   ---------- Footnotes ----------

   (1) poolmvt.html

   (2) poolmvff.html


File: MemoryPoolSystem.info,  Node: Requirements<3>,  Next: Interface<4>,  Prev: Introduction<5>,  Up: Coalescing block structures

4.4.2 Requirements
------------------

In addition to the generic land requirements (see design.mps.land(1)),
the CBS must satisfy:

*note .req.fast;: 3fd. Common operations must have a low amortized cost.

*note .req.small;: 3fe. Must have a small space overhead for the storage
of typical subsets of address space and not have abysmal overhead for
the storage of any subset of address space.

   ---------- Footnotes ----------

   (1) land.html


File: MemoryPoolSystem.info,  Node: Interface<4>,  Next: Implementation,  Prev: Requirements<3>,  Up: Coalescing block structures

4.4.3 Interface
---------------

*note .land;: 400. CBS is an implementation of the 'land' abstract data
type, so the interface consists of the generic functions for lands.  See
design.mps.land(1).

* Menu:

* External types::
* External classes::
* Keyword arguments: Keyword arguments<2>.
* Limitations::

   ---------- Footnotes ----------

   (1) land.html


File: MemoryPoolSystem.info,  Node: External types,  Next: External classes,  Up: Interface<4>

4.4.3.1 External types
......................

 -- C Type: typedef struct CBSStruct *CBS

*note .type.cbs;: 403. The type of coalescing block structures.  A
‘CBSStruct’ is typically embedded in another structure.


File: MemoryPoolSystem.info,  Node: External classes,  Next: Keyword arguments<2>,  Prev: External types,  Up: Interface<4>

4.4.3.2 External classes
........................

*note .class.cbs;: 405. ‘CLASS(CBS)’ is the CBS class, a subclass of
‘CLASS(Land)’ suitable for passing to *note LandInit(): 406.

*note .class.fast;: 407. ‘CLASS(CBSFast)’ is subclass of ‘CLASS(CBS)’
that maintains, for each subtree, the size of the largest block in that
subtree.  This enables the *note LandFindFirst(): 408, *note
LandFindLast(): 409, and *note LandFindLargest(): 40a. generic
functions.

*note .class.zoned;: 40b. ‘CLASS(CBSZoned)’ is a subclass of
‘CLASS(CBSFast)’ that maintains, for each subtree, the union of the zone
sets of all ranges in that subtree.  This enables the *note
LandFindInZones(): 40c. generic function.


File: MemoryPoolSystem.info,  Node: Keyword arguments<2>,  Next: Limitations,  Prev: External classes,  Up: Interface<4>

4.4.3.3 Keyword arguments
.........................

When initializing a CBS, *note LandInit(): 406. takes the following
optional keyword arguments:

   * ‘CBSBlockPool’ (type ‘Pool’) is the pool from which the CBS block
     descriptors will be allocated.  If omitted, a new MFS pool is
     created for this purpose.

   * ‘MPS_KEY_CBS_EXTEND_BY’ (type *note Size: 40e.; default 4096) is
     passed as the ‘MPS_KEY_EXTEND_BY’ keyword argument to
     ‘PoolCreate()’ if a block descriptor pool is created.  It specifies
     the size of segment that the block descriptor pool will request
     from the arena.

   * ‘MFSExtendSelf’ (type *note Bool: 3a9.; default ‘TRUE’) is passed
     to ‘PoolCreate()’ if a block descriptor pool is created.  If
     ‘TRUE’, the block descriptor pool automatically extends itself when
     out of space; if ‘FALSE’, the pool returns ‘ResLIMIT’ in this case.
     (This feature is used by the arena to bootstrap its own CBS of free
     memory.  See design.mps.bootstrap.land.sol.pool(1).)

   ---------- Footnotes ----------

   (1) bootstrap.html#design.mps.bootstrap.land.sol.pool


File: MemoryPoolSystem.info,  Node: Limitations,  Prev: Keyword arguments<2>,  Up: Interface<4>

4.4.3.4 Limitations
...................

*note .limit.find;: 410. ‘CBSLandClass’ does not support the *note
LandFindFirst(): 408, *note LandFindLast(): 409, and *note
LandFindLargest(): 40a. generic functions (the subclasses do support
these operations).

*note .limit.zones;: 411. ‘CBSLandClass’ and ‘CBSFastLandClass’ do not
support the *note LandFindInZones(): 40c. generic function (the subclass
‘CBSZonedLandClass’ does support this operation).

*note .limit.iterate;: 412. CBS does not provide an implementation for
the *note LandIterateAndDelete(): 413. generic function.  This is
because ‘TreeTraverse()’ does not permit modification, for speed and to
avoid perturbing the splay tree balance.

*note .limit.flush;: 414. CBS cannot be used as the source in a call to
*note LandFlush(): 415.  (Because of *note .limit.iterate: 412.)


File: MemoryPoolSystem.info,  Node: Implementation,  Next: Testing,  Prev: Interface<4>,  Up: Coalescing block structures

4.4.4 Implementation
--------------------

* Menu:

* Splay tree::
* Low memory behaviour::
* The CBS block::


File: MemoryPoolSystem.info,  Node: Splay tree,  Next: Low memory behaviour,  Up: Implementation

4.4.4.1 Splay tree
..................

*note .impl.splay;: 418. The CBS is implemented using a splay tree (see
design.mps.splay(1)).  Each splay tree node is embedded in a block
structure with a semi-open address range (design.mps.range(2)).  The
splay tree is ordered by the range base address.

*note .impl.splay.fast-find;: 419. In the ‘CBSFastLandClass’ class,
‘cbsFindFirst()’ and ‘cbsFindLast()’ use the update/refresh facility of
splay trees to store, in each block, an accurate summary of the maximum
block size in the tree rooted at the corresponding splay node.  This
allows rapid location of the first or last suitable block, and very
rapid failure if there is no suitable block.  For example, this is used
in the implementation of allocation in the MVFF pool class
(design.mps.poolmvff(3)).

*note .impl.find-largest;: 41a. ‘cbsFindLargest()’ simply finds out the
size of the largest block in the CBS from the root of the tree, using
‘SplayRoot()’, and does *note SplayFindFirst(): 41b. for a block of that
size.  This takes time proportional to the logarithm of the size of the
free list, so it’s about the best you can do without maintaining a
separate priority queue, just to do ‘cbsFindLargest()’.  For example,
this is used in the implementation of allocation buffers in the MVFF
pool class (design.mps.poolmvff(4)).

*note .impl.splay.zones;: 41c. In the ‘CBSZonedLandClass’ class,
‘cbsFindInZones()’ uses the update/refresh facility of splay trees to
store, in each block, the union of the zones of the ranges in the tree
rooted at the corresponding splay node.  This allows rapid location of a
block in a set of zones.  For example, this is used to allocate segments
in particular zones in the arena to optimised garbage collection (see
design.mps.critical-path(5)).

   ---------- Footnotes ----------

   (1) splay.html

   (2) range.html

   (3) poolmvff.html

   (4) poolmvff.html

   (5) critical-path.html


File: MemoryPoolSystem.info,  Node: Low memory behaviour,  Next: The CBS block,  Prev: Splay tree,  Up: Implementation

4.4.4.2 Low memory behaviour
............................

*note .impl.low-mem;: 41f. When the CBS tries to allocate a new
‘CBSBlock’ structure for a new isolated range as a result of either
*note LandInsert(): 420. or *note LandDelete(): 421, and there is
insufficient memory to allocate the block structure, then the range is
not added to the CBS or deleted from it, and the call to *note
LandInsert(): 420. or *note LandDelete(): 421. returns ‘ResMEMORY’.


File: MemoryPoolSystem.info,  Node: The CBS block,  Prev: Low memory behaviour,  Up: Implementation

4.4.4.3 The CBS block
.....................

*note .impl.cbs.block;: 423. The block contains a non-empty range and a
splay tree node.

*note .impl.cbs.block.special;: 424. The range may be empty if the block
is halfway through being deleted.

*note .impl.cbs.block.special.just;: 425. This conflates values and
status, but is justified because block size is very important.


File: MemoryPoolSystem.info,  Node: Testing,  Next: Notes for future development,  Prev: Implementation,  Up: Coalescing block structures

4.4.5 Testing
-------------

*note .test;: 427. The following testing will be performed on this
module:

*note .test.land;: 428. A generic test for land implementations.  See
design.mps.land.test(1).

*note .test.pool;: 429. The arena and two pools (MVT(2) and MVFF(3)) are
implemented on top of a CBS. These are subject to testing in
development, QA, and are heavily exercised by customers.

   ---------- Footnotes ----------

   (1) land.html#design.mps.land.test

   (2) poolmvt

   (3) poolmvff


File: MemoryPoolSystem.info,  Node: Notes for future development,  Next: Risks,  Prev: Testing,  Up: Coalescing block structures

4.4.6 Notes for future development
----------------------------------

*note .future.not-splay;: 42c. The implementation of CBSs is based on
splay trees.  It could be revised to use other data structures that meet
the requirements (especially *note .req.fast: 3fd.).

*note .future.hybrid;: 42d. It would be possible to attenuate the
problem of *note .risk.overhead: 42e. (below) by using a single word bit
set to represent the membership in a (possibly aligned) word-width of
grains.  This might be used for block sizes less than a word-width of
grains, converting them when they reach all free in the bit set.  Note
that this would make coalescence slightly less eager, by up to
‘(word-width - 1)’.

*note .future.iterate.and.delete;: 42f. It would be possible to provide
an implementation for the *note LandIterateAndDelete(): 413. generic
function using ‘TreeTraverseAndDelete()’, which calls ‘TreeToVine()’
first, iterates over the vine (where deletion is straightforward), and
then rebalances the tree.  Note that this is little better than using
‘SplayFirst()’ and ‘SplayNext()’.

*note .future.lazy-coalesce;: 430. It’s long been observed that small
blocks are often freed and then reallocated, so that coalescing them is
a waste of time.  It might be worth considering how a splay tree could
implement a lazy coalescing scheme, where blocks are coalesced with
their adjacent neighbours during the search only if they aren’t big
enough.  This would break *note .impl.find-largest: 41a. and so might be
best done as a different kind of land.  On the other hand, since the MPS
does not use client memory to store the tree, eager coalescing avoids
allocation.


File: MemoryPoolSystem.info,  Node: Risks,  Prev: Notes for future development,  Up: Coalescing block structures

4.4.7 Risks
-----------

*note .risk.overhead;: 42e. Clients should note that the current
implementation of CBSs has a space overhead proportional to the number
of isolated contiguous ranges.  [Four words per range.]  If the CBS
contains every other grain in an area, then the overhead will be large
compared to the size of that area.  [Four words per two grains.]  The
CBS structure is thus suitable only for managing large enough ranges.


File: MemoryPoolSystem.info,  Node: Fast high-resolution clock,  Next: MPS Configuration,  Prev: Coalescing block structures,  Up: Design

4.5 Fast high-resolution clock
==============================

* Menu:

* Introduction: Introduction<6>.
* Requirements: Requirements<4>.
* Interface: Interface<5>.
* Implementation: Implementation<2>.


File: MemoryPoolSystem.info,  Node: Introduction<6>,  Next: Requirements<4>,  Up: Fast high-resolution clock

4.5.1 Introduction
------------------

*note .intro;: 436. This is the design of the clock module, which
implements a fast high-resolution clock for use by the telemetry system.

*note .readership;: 437. This document is intended for any MPS
developer.


File: MemoryPoolSystem.info,  Node: Requirements<4>,  Next: Interface<5>,  Prev: Introduction<6>,  Up: Fast high-resolution clock

4.5.2 Requirements
------------------

*note .req.monotonic;: 439. Successive calls to *note EVENT_CLOCK():
43a. must yield values that are monotonically increasing.  (So that
comparing the timestamp on two events never gives false positives.)

*note .req.fast;: 43b. *note EVENT_CLOCK(): 43a. should take very little
time; it should not require a system call.  (So that programs that use
the MPS remain usable when telemetry is turned on.)

*note .req.high-resolution;: 43c. Successive calls to *note
EVENT_CLOCK(): 43a. should yield values that are strictly monotonically
increasing (so that sorting the telemetry stream puts the events in the
order they happened).


File: MemoryPoolSystem.info,  Node: Interface<5>,  Next: Implementation<2>,  Prev: Requirements<4>,  Up: Fast high-resolution clock

4.5.3 Interface
---------------

‘EventClock’

*note .if.type;: 43e. The type of timestamps.  It must be an unsigned
64-bit integral type, for example a ‘typedef’ for ‘uint64_t’ or
‘unsigned __int64’.

 -- C Macro: EVENT_CLOCK_MAKE (lvalue, low, high)

*note .if.make;: 440. Construct an ‘EventClock’ timestamp from its two
halves.  The first parameter is an lvalue with type ‘EventClock’, and
the second and third parameters are 32-bit unsigned integers.  The macro
must assign a timestamp to ‘lvalue’ with the value ‘(high << 32) + low’.

 -- C Macro: EVENT_CLOCK (lvalue)

*note .if.get;: 441. Assign an ‘EventClock’ timestamp for the current
time to ‘lvalue’, which is an lvalue with type ‘EventClock’.

 -- C Macro: EVENT_CLOCK_PRINT (stream, clock)

*note .if.print;: 443. Write the value of ‘clock’ to the standard C
output file handle ‘stream’ as 16 hexadecimal digits (with leading
zeros, and capital letters A to F).

 -- C Macro: EVENT_CLOCK_WRITE (stream, clock)

*note .if.write;: 445. Write the value of ‘clock’ to the output stream
‘stream’ as 16 hexadecimal digits (with leading zeros, and capital
letters A to F). The macro should be implemented using *note WriteF():
446.


File: MemoryPoolSystem.info,  Node: Implementation<2>,  Prev: Interface<5>,  Up: Fast high-resolution clock

4.5.4 Implementation
--------------------

*note .impl.tsc;: 448. On IA-32 and x86-64, the Time Stamp Counter(1)
returned by the RDTSC instruction is a suitable clock for single-core
CPUs, but on multiple-core CPUs, different cores may have different
values or tick at different speeds, and so it may fail to meet *note
.req.monotonic: 439.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Time_Stamp_Counter


File: MemoryPoolSystem.info,  Node: MPS Configuration,  Next: The critical path through the MPS,  Prev: Fast high-resolution clock,  Up: Design

4.6 MPS Configuration
=====================

* Menu:

* Introduction: Introduction<7>.
* Requirements: Requirements<5>.
* Definitions::
* Overview::
* The build system::
* Implementation: Implementation<3>.
* Source code configuration::
* Configuration options::
* To document::
* References::


File: MemoryPoolSystem.info,  Node: Introduction<7>,  Next: Requirements<5>,  Up: MPS Configuration

4.6.1 Introduction
------------------

*note .intro;: 44d. This document describes how the Memory Pool
System(1) source code is configured so that it can target different
architectures, operating systems, build environments, varieties, and
products.

*note .readership;: 44e. Any MPS developer; anyone porting the MPS to a
new platform.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/


File: MemoryPoolSystem.info,  Node: Requirements<5>,  Next: Definitions,  Prev: Introduction<7>,  Up: MPS Configuration

4.6.2 Requirements
------------------

*note .req.import;: 450. The MPS must be simple to include in
third-party projects.

*note .req.arch;: 451. Allow architecture specific configurations of the
MPS, so that we can vary the MPS according to the target architecture.

*note .req.os;: 452. Allow operating system specific configurations of
the MPS, so that we can vary the MPS according to the target OS.

*note .req.builder;: 453. Allow build environment specific
configurations of the MPS, so that we can vary the MPS according to the
compiler, etc.

*note .req.var;: 454. Allow configurations with different amounts of
instrumentation (assertions, metering, etc.).

*note .req.impact;: 455. The configuration system should have a minimal
effect on maintainability of the implementation.

*note .req.port;: 456. The system should be easy to port across
platforms.

*note .req.maint;: 457. Maintenance of the configuration and build
system should not consume much developer time.

* Menu:

* Retired requirements::


File: MemoryPoolSystem.info,  Node: Retired requirements,  Up: Requirements<5>

4.6.2.1 Retired requirements
............................

*note .req.prod;: 459. Allow product specific configurations of the MPS,
so that we can build variants of the MPS for use in different products.
This requirement has been retired on 2012-09-03 as part of work on the
variety-reform(1) branch.  Client-specific customisation of the MPS will
be handled in source control, while the MPS source remains generic, to
reduce costs and increase reliability.  See *note [RB_2012-09-13]: 45a.

   ---------- Footnotes ----------

   (1) /project/mps/branch/2012-08-15/variety-reform


File: MemoryPoolSystem.info,  Node: Definitions,  Next: Overview,  Prev: Requirements<5>,  Up: MPS Configuration

4.6.3 Definitions
-----------------

*note .def.platform;: 45d. A 'platform' is a combination of an
architecture (*note .def.arch: 45e.), an operating system (*note
.def.os: 45f.), and a builder (*note .def.builder: 460.).  The set of
supported platforms is maintained in the Platforms section of "Building
the Memory Pool System"(1).

*note .def.arch;: 45e. An 'architecture' is processor type with
associated calling conventions and other binary interface stuff these
days often called the ABI(2). Most importantly for the MPS it determines
the layout of the register file, thread context, and thread stack.

*note .def.os;: 45f. An 'operating system' is the interface to external
resources.  Most importantly for the MPS it determines the low level
interface to virtual memory (if any) and threading.

*note .def.builder;: 460. A 'builder' is the tools (C compiler, etc.)
used to make the target (*note .def.target: 461.).  The MPS minimises
use of compiler-specific extensions, but this is handy for suppressing
warnings, inlining hints, etc.

*note .def.var;: 462. A 'variety' determines things like the amount of
debugging, internal consistency checking, annotation, etc.  In modern
IDEs this called a “build configuration” and the usual default is to
have two: “debug” and “release”.  The MPS predates this convention, but
the concept is the same.

*note .def.prod;: 463. A 'product' is the intended product into which
the MPS will fit, e.g.  ScriptWorks, Dylan, etc.  We no longer maintain
this concept as a dimension of configuration since *note .req.prod: 459.
has been retired.

*note .def.target;: 461. The 'target' is the result of the build.

*note .def.option;: 464. An 'option' is a feature of the MPS that is not
selected via the 'platform' and 'variety'.  See *note .opt: 465.

   ---------- Footnotes ----------

   (1) ../../../manual/html/guide/build.html#platforms

   (2) https://en.wikipedia.org/wiki/Application_binary_interface


File: MemoryPoolSystem.info,  Node: Overview,  Next: The build system,  Prev: Definitions,  Up: MPS Configuration

4.6.4 Overview
--------------

*note .import.source;: 467. The MPS can be simply included in client
products as source code.  Since version 1.110(1) we made it possible to
simply include the file ‘mps.c’ in a client’s build process, without
requiring a separate build of the MPS or linking a library.  This is
described section 2.3.1, "Compiling for production" of the MPS
manual(2).

*note .no-gen;: 468. No generated code or external tools are required.
On most platforms the only tool is the C compiler.  On 64-bit Windows we
require the assembler since Microsoft withdrew in-line assembler from
their C compiler.

*note .no-spaghetti;: 469. Several of the MPS team have worked on some
extremely messy code bases which used a great number of ‘#ifdef’
statements.  These quickly became very expensive to maintain and
develop.  The general rule in the MPS is “no ‘#ifdefs’”.  Instead,
platform-specific code is kept in separate source files and selected by
carefully controlled ‘#ifdefs’, such as in mps.c(3).

*note .min-dep;: 46a. Dependency on a particular configuration should be
minimized and localized when developing code.  This is enshrined in the
general rules for implementation [ref?]  that are enforced by MPS
development procedures including code review and inspection.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/version/1.110/

   (2) ../../../manual/html/guide/build.html#compiling-for-production

   (3) ../../../code/mps.c


File: MemoryPoolSystem.info,  Node: The build system,  Next: Implementation<3>,  Prev: Overview,  Up: MPS Configuration

4.6.5 The build system
----------------------

* Menu:

* Abstract build function::
* File Structure::
* Modules and naming::
* Build system rationale::
* Warnings and errors::


File: MemoryPoolSystem.info,  Node: Abstract build function,  Next: File Structure,  Up: The build system

4.6.5.1 Abstract build function
...............................

*note .build.fun;: 46d. The MPS implementation assumes only a simple
“build function” that takes a set of sources, possibly in several
languages, compiles them with a set of predefined preprocessor symbols,
and links the result with a set of libraries to form the target:

     target := build(<defs>, <srcs>, <libs>)

*note .build.sep;: 46e. Separate compilation and linkage can be seen as
a memoization of this function, and is not strictly necessary for the
build.  Indeed, since ‘version 1.110’ we found that modern compilers are
quite happy to compile the whole MPS in one go *note .import.source:
467.

*note .build.cc;: 46f. A consequence of this approach is that it should
always be possible to build a complete target with a single UNIX command
line calling the compiler driver (usually “cc” or “gcc”), for example:

     cc -o main -DCONFIG_VAR_COOL foo.c bar.c baz.s -lz

*note .build.defs;: 470. The “defs” are the set of preprocessor macros
which are to be predefined when compiling the module sources:

     CONFIG_VAR_<variety-code>

*note .var.codes;: 471. The variety codes are as follows:

*note .var.hot;: 472. ‘HOT’

     Intended for release in products.  Optimised, reduced internal
     checking, especially on the critical path *note [RB_2012-09-07]:
     473.

*note .var.cool;: 474. ‘COOL’

     Intended for use during development.  Moderately thorough internal
     consistency checking.  Reduced optimisation to allow for
     single-stepping.

*note .var.rash;: 475. ‘RASH’

     No internal checking at all.  Slight performance improvement over
     *note .var.hot: 472. at the cost of early detection of memory
     management bugs.  We do not advise use of this variety, as memory
     management bugs tend to be extremely expensive to deal with.

*note .default.hot;: 476. If no ‘CONFIG_VAR’ is present, ‘HOT’ is
assumed in config.h(1).

*note .build.srcs;: 477. The “srcs” are the set of sources that must be
compiled in order to build the target.  The set of sources may vary
depending on the configuration.  For example, different sets of sources
may be required to build different architectures.

     Note: This is a dependency between the makefile (or whatever) and
     the module configuration in config.h(2).

*note .build.libs;: 478. The “libs” are the set of libraries to which
the compiled sources must be linked in order to build the target.  For
example, when building a test program, it might include the ANSI C
library and an operating system interface library.

   ---------- Footnotes ----------

   (1) ../../../code/config.h

   (2) ../../../code/config.h


File: MemoryPoolSystem.info,  Node: File Structure,  Next: Modules and naming,  Prev: Abstract build function,  Up: The build system

4.6.5.2 File Structure
......................

*note .file.dir;: 47a. The MPS source code is arranged in a single
directory called “code” containing all the sources for the whole family
of targets.

*note .file.base;: 47b. The names of sources must be unique in the first
eight characters in order to conform to FAT filesystem naming
restrictions.  (Do not scoff – this has been an important requirement as
recently as 2012!)

*note .file.ext;: 47c. The extension may be up to three characters and
directly indicates the source language.

*note .file.platform;: 47d. Platform-specific files include the platform
code in their name.  See *note .mod.impls: 47e.


File: MemoryPoolSystem.info,  Node: Modules and naming,  Next: Build system rationale,  Prev: File Structure,  Up: The build system

4.6.5.3 Modules and naming
..........................

*note .mod.unique;: 480. Each module has an identifier which is unique
within the MPS.

*note .mod.impls;: 47e. Each module has one or more implementations
which may be in any language supported by the relevant build
environment.

*note .mod.primary;: 481. The primary implementation of a module is
written in target-independent ANSI C in a source file with the same name
as the module.

*note .mod.an;: 482. Where there are platform-specific implementations
and an inferior portable ANSI C fallback implementation, “an” is used in
place of the platform code.

*note .mod.secondary;: 483. The names of other implementations should
begin with the same prefix (the module id or a shortened version of it)
and be suffixed with on or more target parameter codes (defined below).
In particular, the names of assembly language sources must include the
target parameter code for the relevant architecture.

*note .mod.example;: 484. For example, the stack scanner is defined in
ss.h(1) (which is platform-independent).  It has some
platform-independent C in ss.c(2) and, for example, ssw3i6mv.c(3) is
specific to Windows on the x64 architecture built with Microsoft Visual
C.

   ---------- Footnotes ----------

   (1) ../../../code/ss.h

   (2) ../../../code/ss.c

   (3) ../../../code/ssw3i6mv.c


File: MemoryPoolSystem.info,  Node: Build system rationale,  Next: Warnings and errors,  Prev: Modules and naming,  Up: The build system

4.6.5.4 Build system rationale
..............................

*note .build.rat;: 487. This simple design makes it possible to build
the MPS using many different tools.  Microsoft Visual C and other
graphical development tools do not support much in the way of generated
sources, staged building, or other such stuff.  The Visual C and Xcode
“project” files correspond closely to a closure of the build function
(*note .build.fun: 46d.).  The simplicity of the build function has also
made it easy to set up builds using NMAKE (DOS), MPW (Macintosh), and to
get the MPS up and running on other platforms such as FreeBSD and Linux
in very little time.  The cost of maintaining the build systems on these
various platforms is also reduced to a minimum, allowing the MPS
developers to concentrate on primary development.  The source code is
kept simple and straightforward.  When looking at MPS sources you can
tell exactly what is going to be generated with very little context.
The sources are not munged beyond the standard ANSI C preprocessor.

*note .build.port;: 488. The portability requirement (*note .req.port:
456.) implies that the build system must use only standard tools that
will be available on all conceivable target platforms.  Experience of
development environments on the Macintosh (Metrowerks Codewarrior) and
Windows NT (Visual C++) indicates that we cannot assume much
sophistication in the use of file structure by development environments.
The best that we can hope for is the ability to combine a fixed list of
source files, libraries, and predefined preprocessor symbols into a
single target.

*note .build.maint;: 489. The maintainability requirement (*note
.req.maint: 457.) implies that we don’t spend time trying to develop a
set of tools to support anything more complicated than the simple build
function described above.  The effort in constructing and maintaining a
portable system of this kind is considerable.  Such efforts failed in
the Electronic Publishing division of Harlequin.


File: MemoryPoolSystem.info,  Node: Warnings and errors,  Prev: Build system rationale,  Up: The build system

4.6.5.5 Warnings and errors
...........................

*note .warning.free;: 48b. A consequence of *note .import.source: 467.
is that the MPS needs to compile in the context of the client’s build
system, with 'whatever compilation and warning options' the client has
enabled in that system, and this might include options causing warnings
to be treated as errors.  Accordingly, the MPS should compile without
warnings when enabling the compiler options most likely to be employed
by clients.

*note .warning.impl;: 48c. In order to ensure that the MPS meets the
requirement in *note .warning.free: 48b, during development and testing
of the MPS we compile with a large selection of warning options for each
supported compiler, and with warnings treated as errors so that
developers do not get into the habit of ignoring warning messages.
These are enabled in the compiler makefile fragments for each compiler,
for example ll.gmk(1) for Clang/LLVM.

*note .warning.benefit;: 48d. The implementation in *note .warning.impl:
48c. also helps us keep the code free of subtle compiler issues that
break memory managers, and free of constructs which might be
accidentally mis-interpreted by other developers.

*note .warning.silence;: 48e. When code needs to be modified, for
example by adding a cast, to silence a warning that has been analyzed
and turned out to be harmless, it is best practice to introduce a macro
that expresses the intention, and cross-reference this paragraph from
the macro’s comment.  If the macro is general-purpose then misc.h(2) is
a good place to put it.

   ---------- Footnotes ----------

   (1) ../../../code/ll.gmk

   (2) ../../../code/misc.h


File: MemoryPoolSystem.info,  Node: Implementation<3>,  Next: Source code configuration,  Prev: The build system,  Up: MPS Configuration

4.6.6 Implementation
--------------------

*note .impl;: 491. The two implementation files config.h(1) and
mpstd.h(2) can be seen as preprocessor programs which “accept” build
parameters and “emit” configuration parameters (*note .fig.impl: 492.).
The build parameters are defined either by the builder (in the case of
target detection) or by the build function (in the case of selecting the
variety).

*note .fig.impl;: 492.

Build parameters                Source file        Configuration parameters
                                                   
---------------------------------------------------------------------------------------------------
                                                   
*note CONFIG_VAR_HOT: 172.      ⟶ ‘config.h’       ⟶ ‘MPS_ASSERT_STRING’, etc.
                                                   
                                                   
‘_WIN32’                        ⟶ ‘mpstd.h’        ⟶ *note MPS_OS_W3: 2e2, etc.
                                                   

*note .impl.dep;: 493. No source code, other than the directives in
config.h(3) and mpstd.h(4), should depend on any build parameters.  That
is, identifiers beginning “CONFIG_” should only appear in impl.h.config.
Code may depend on configuration parameters in certain, limited ways, as
defined below (*note .conf: 494.).

* Menu:

* Target platform detection::
* Target varieties::

   ---------- Footnotes ----------

   (1) ../../../code/config.h

   (2) ../../../code/mpstd.h

   (3) ../../../code/config.h

   (4) ../../../code/mpstd.h


File: MemoryPoolSystem.info,  Node: Target platform detection,  Next: Target varieties,  Up: Implementation<3>

4.6.6.1 Target platform detection
.................................

*note .pf;: 497. The target platform is “detected” by the preprocessor
directives in mpstd.h(1).

*note .pf.form;: 498. This file consists of sets of directives of the
form:

     #elif <conjunction of builder predefinitions>
     #define MPS_PF_<platform code>
     #define MPS_PF_STRING "<platform code>"
     #define MPS_OS_<operating system code>
     #define MPS_ARCH_<architecture code>
     #define MPS_BUILD_<builder code>
     #define MPS_T_WORD     <word type>
     #define MPS_T_ULONGEST <longest unsigned integer type>
     #define MPS_WORD_WIDTH <word width in bits>
     #define MPS_WORD_SHIFT <log to the base 2 of word width>
     #define MPS_PF_ALIGN   <minimum alignment>

*note .pf.detect;: 499. The conjunction of builder predefinitions is a
constant expression which detects the target platform.  It is a logical
AND of expressions which look for preprocessor symbols defined by the
build environment to indicate the target.  These must be accompanied by
a reference to the build tool documentation from which the symbols came.
For example:

     /* "Predefined Macros" from "Visual Studio 2010" on MSDN
      * <http://msdn.microsoft.com/en-us/library/b0084kay(v=vs.100).aspx>. */

     #elif defined(_MSC_VER) && defined(_WIN32) && defined(_M_IX86)

*note .pf.codes;: 49a. The declarations of the platform, operating
system, architecture, and builder codes define preprocessor macros
corresponding to the target detected (*note .pf.detect: 499.).  For
example:

     #define MPS_PF_W3I3MV
     #define MPS_OS_W3
     #define MPS_ARCH_I3
     #define MPS_BUILD_MV

*note .pf.word;: 49b. The declaration of *note MPS_T_WORD: 2fe. defines
the unsigned integral type which corresponds, on the detected target, to
the machine word.  It is used to defined the MPS Word type
(design.mps.type.word(2)).  For example:

     #define MPS_T_WORD      unsigned long

We avoid using ‘typedef’ here because mpstd.h(3) could potentially be
included in assembly language source code.

*note .pf.word-width;: 49c. The declaration of *note MPS_WORD_WIDTH:
187. defines the number of bits in the type defined by *note MPS_T_WORD:
2fe. (*note .pf.word: 49b.) on the target.  For example:

     #define MPS_WORD_WIDTH  32

*note .pf.word-shift;: 49d. The declaration of *note MPS_WORD_SHIFT:
2ff. defines the log to the base 2 of *note MPS_WORD_WIDTH: 187.  For
example:

     #define MPS_WORD_SHIFT  5

*note .pf.pf-align;: 49e. The declaration of *note MPS_PF_ALIGN: 6f.
defines the minimum alignment which must be used for a memory block to
permit any normal processor memory access.  In other words, it is the
maximum alignment required by the processor for normal memory access.
For example:

     #define MPS_PF_ALIGN    4

*note .pf.ulongest;: 49f. The declaration of *note MPS_T_ULONGEST: 2fd.
defines the longest available unsigned integer type on the platform.
This is usually just ‘unsigned long’ but under Microsoft C on 64-bit
Windows ‘unsigned long’ is just 32-bits (curse them!)  For example:

     #define MPS_T_ULONGEST      unsigned __int64

*note .pf.pf-string;: 4a0. The declaration of *note MPS_PF_STRING: 2f6.
defines a string that is used to identify the target platform in
version.c(4).  For example:

     #define MPS_PF_STRING   "w3i6mv"

   ---------- Footnotes ----------

   (1) ../../../code/mpstd.h

   (2) type.html#design.mps.type.word

   (3) ../../../code/mpstd.h

   (4) ../../../code/version.c


File: MemoryPoolSystem.info,  Node: Target varieties,  Prev: Target platform detection,  Up: Implementation<3>

4.6.6.2 Target varieties
........................

*note .var;: 4a3. The target variety is handled by preprocessor
directives in impl.h.config.

*note .var.form;: 4a4. The file contains sets of directives of the form:

     #if defined(CONFIG_VAR_COOL)
     #define CONFIG_ASSERT
     #define CONFIG_ASSERT_ALL
     #define CONFIG_STATS

*note .var.detect;: 4a5. The configured variety is one of the variety
preprocessor definitions passed to the build function (*note
.build.defs: 470.), for example, *note CONFIG_VAR_COOL: ca.  These are
decoupled in order to keep the number of supported varieties small,
controlling each feature (for example, assertions) by a single
preprocessor definition, and maintaining flexibility about which
features are enabled in each variety.

*note .var.symbols;: 4a6. The directives should define whatever symbols
are necessary to control features.  These symbols parameterize other
parts of the code, such as the declaration of assertions, etc.  The
symbols should all begin with the prefix ‘CONFIG_’.


File: MemoryPoolSystem.info,  Node: Source code configuration,  Next: Configuration options,  Prev: Implementation<3>,  Up: MPS Configuration

4.6.7 Source code configuration
-------------------------------

*note .conf;: 494. This section describes how the configuration may
affect the source code of the MPS.

*note .conf.limit;: 4a8. The form of dependency allowed is carefully
limited to ensure that code remains maintainable and portable (*note
.req.impact: 455.).

*note .conf.min;: 4a9. The dependency of code on configuration
parameters should be kept to a minimum in order to keep the system
maintainable (*note .req.impact: 455.).

* Menu:

* Configuration Parameters::
* Abstract and Concrete Module Interfaces::


File: MemoryPoolSystem.info,  Node: Configuration Parameters,  Next: Abstract and Concrete Module Interfaces,  Up: Source code configuration

4.6.7.1 Configuration Parameters
................................

*note .conf.params;: 4ab. The compilation of a module is parameterized
by:

     MPS_ARCH_<arch-code>
     MPS_OS_<os-code>
     MPS_BUILD_<builder-code>
     MPS_PF_<platform-code>


File: MemoryPoolSystem.info,  Node: Abstract and Concrete Module Interfaces,  Prev: Configuration Parameters,  Up: Source code configuration

4.6.7.2 Abstract and Concrete Module Interfaces
...............................................

*note .abs.caller;: 4ad. Basic principle: the caller musn’t be affected
by configuration of a module.  This reduces complexity and dependency of
configuration.  All callers use the same abstract interface.  Caller
code does not change.

*note .abs.interface;: 4ae. Abstract interface includes:

   - method definitions (logical function prototypes which may be macro
     methods)

   - names of types

   - names of constants

   - names of structures and fields which form part of the interface,
     and possibly their types, depending on the protocol defined

   - the protocols

*note .abs.rule;: 4af. The abstract interface to a module may not be
altered by a configuration parameter.  However, the concrete interface
may vary.

For example, this isn’t allowed, because there is a change in the
interface:

     #if defined(PROT_FOO)
     void ProtSpong(Foo foo, Bar bar);
     #else
     int ProtSpong(Bar bar, Foo foo);
     #endif

This example shows how:

     #ifdef PROTECTION
     void ProtSync(Space space);
     /* more decls. */
     #else /* PROTECTION not */
     #define ProtSync(space) NOOP
     /* more decls. */
     #endif /* PROTECTION */

or:

     #if defined(PROT_FOO)
     typedef struct ProtStruct {
       int foo;
     } ProtStruct;
     #define ProtSpong(prot)  X((prot)->foo)
     #elif defined(PROT_BAR)
     typedef struct ProtStruct {
       float bar;
     } ProtStruct;
     #define ProtSpong(prot)  Y((prot)->bar)
     #else
     #error "No PROT_* configured."
     #endif

Configuration parameters may not be used to vary implementations in C
files.  For example, this sort of thing:

     int map(void *base, size_t size)
     {
     #if defined(MPS_OS_W3)
       VirtualAlloc(foo, bar, base, size);
     #elif defined(MPS_OS_SU)
       mmap(base, size, frob);
     #else
     #error "No implementation of map."
     #endif
     }

This violates *note .no-spaghetti: 469.


File: MemoryPoolSystem.info,  Node: Configuration options,  Next: To document,  Prev: Source code configuration,  Up: MPS Configuration

4.6.8 Configuration options
---------------------------

*note .opt;: 465. Options select features of the MPS that are not
selected by the 'platform' and the 'variety'.

*note .opt.support;: 4b1. The features selected by options are not
supported or documented in the public interface.  This is to keep the
complexity of the MPS manageable: at present the number of supported
configuration is 'platforms' × 'varieties' (at time of writing, 9 × 3 =
27).  Each supported option would double (or worse) the number of
supported configurations.

*note .opt.ansi;: 4b2. ‘CONFIG_PF_ANSI’ tells ‘mps.c’ to exclude the
sources for the auto-detected platform, and use the generic (“ANSI”)
platform instead.

*note .opt.thread;: 4b3. ‘CONFIG_THREAD_SINGLE’ causes the MPS to be
built for single-threaded execution only, where locks are not needed and
so the generic (“ANSI”) lock module ‘lockan.c’ can be used instead of
the platform-specific lock module.

*note .opt.poll;: 4b4. ‘CONFIG_POLL_NONE’ causes the MPS to be built
without support for polling.  This means that garbage collections will
only happen if requested explicitly via *note mps_arena_collect(): ce.
or *note mps_arena_step(): 19c, but it also means that protection is not
needed, and so shield operations can be replaced with no-ops in ‘mpm.h’.

*note .opt.signal.suspend;: 4b5. *note CONFIG_PTHREADEXT_SIGSUSPEND:
1fb. names the signal used to suspend a thread, on platforms using the
POSIX thread extensions module.  See design.pthreadext.impl.signals(1).

*note .opt.signal.resume;: 4b6. *note CONFIG_PTHREADEXT_SIGRESUME: 1fc.
names the signal used to resume a thread, on platforms using the POSIX
thread extensions module.  See design.pthreadext.impl.signals(2).

   ---------- Footnotes ----------

   (1) pthreadext#impl.signals

   (2) pthreadext#impl.signals


File: MemoryPoolSystem.info,  Node: To document,  Next: References,  Prev: Configuration options,  Up: MPS Configuration

4.6.9 To document
-----------------

   - What about constants in config.h?

   - Update files to refer to this design document.

   - Explain the role of ‘mps.c’

   - Reference to ‘build.txt’

   - Procedures for adding an architecture, etc.

   - Reduce duplication in this document (especially after *note
     Configuration Parameters: 4aa. which looks like it’s been pasted in
     from elsewhere.)


File: MemoryPoolSystem.info,  Node: References,  Prev: To document,  Up: MPS Configuration

4.6.10 References
-----------------

(RB_2012-09-07) Richard Brooksby.  Ravenbrook Limited.  2012-09-07.
“The critical path through the MPS(1)”.

(RB_2012-09-13) Richard Brooksby.  Ravenbrook Limited.  2013-09-13.
“The Configura CET custom mainline(2)”.

   ---------- Footnotes ----------

   (1) 
https://www.ravenbrook.com/project/mps/master/design/critical-path

   (2) https://info.ravenbrook.com/mail/2012/09/13/16-43-35/0/


File: MemoryPoolSystem.info,  Node: The critical path through the MPS,  Next: Documentation,  Prev: MPS Configuration,  Up: Design

4.7 The critical path through the MPS
=====================================

     single: critical path single: path; critical single: Memory Pool
     System; critical path

* Menu:

* Introduction: Introduction<8>.
* What makes the critical path critical::
* How the MPS avoids scanning and fixing::
* Where to find the critical path::
* The format scanner::
* The second stage fix in the MPM::
* The third stage fix in the segment class::
* Other considerations::
* References: References<2>.


File: MemoryPoolSystem.info,  Node: Introduction<8>,  Next: What makes the critical path critical,  Up: The critical path through the MPS

4.7.1 Introduction
------------------

The critical path is a key concept in the design of the Memory Pool
System(1).  Code on the critical path is usually executed more than any
other code in the process.  A change of just one instruction on the
critical path can make as much as a 1% difference in overall run-time.
A lot of the design of the MPS is arranged around making the critical
path as short and fast as possible.  This document describes the
critical path and explains some of that design, with reference to more
detailed documents.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/


File: MemoryPoolSystem.info,  Node: What makes the critical path critical,  Next: How the MPS avoids scanning and fixing,  Prev: Introduction<8>,  Up: The critical path through the MPS

4.7.2 What makes the critical path critical
-------------------------------------------

In order to determine which objects can be recycled, the garbage
collector has to frequently examine a very large number of pointers in
the program’s objects.  It does this by scanning(1) memory, both
allocated objects and roots (such as the thread stacks).

This means that the scanning functions must loop over pretty much 'every
word in memory' sooner or later.  The MPS takes great pains to avoid
scanning memory which does not need scanning, but to get good
performance, scanning must be highly optimised.

What’s more, the scanning functions apply an operation called “fix” to
every pointer (or potential pointer) that they find in the objects in
memory.  Fixing also attempts to eliminate uninteresting pointers as
fast as possible, but it has to do some work on every object that is
being considered for recycling, and that can be a large proportion of
the objects in existence.  The path through fixing must also be highly
optimised, especially in the early stages.

   ---------- Footnotes ----------

   (1) https://www.memorymanagement.org/glossary/s.html#scan


File: MemoryPoolSystem.info,  Node: How the MPS avoids scanning and fixing,  Next: Where to find the critical path,  Prev: What makes the critical path critical,  Up: The critical path through the MPS

4.7.3 How the MPS avoids scanning and fixing
--------------------------------------------

This is just a brief overview of how the MPS is designed to reduce
unnecessary scanning and fixing.

Firstly, the MPS must occasionally decide which objects to try to
recycle.  It does this using various facts it knows about the objects,
primarily their age and whether they’ve survived previous attempts at
recycling them.  It then “condemns(1)” a large number of objects at
once, and each of these objects must be “preserved” by fixing references
to them.

When the MPS condemns objects it chooses sets of objects in a small set
of “zones” in memory (preferably a single zone).  The zone of an object
can be determined extremely quickly from its address, without looking at
the object or any other data structure.

The MPS arranges that objects which will probably die at the same time
are in the same zones.

The MPS allocates in “segments”.  Each segment is of the order of one
“tract” of memory (generally the same as the operating system page size,
usually 4 KiB or 8 KiB) but may be larger if there are large objects
inside.  The MPS maintains a “summary” of the zones pointed to by all
the pointers in a segment from previous scans.

So, once the MPS has decided what to condemn, it can quickly eliminate
all segments which definitely do not point to anything in those zones.
This avoids a large amount of scanning.  It is an implementation of a
remembered set(2), though it is unlike that in most other garbage
collectors.

In addition, the fix operation can quickly ignore pointers to the wrong
zones.  This is called the “zone check” and is a BIBOP(3) technique.

Even if a pointer passes the zone check, it may still not point to a
segment containing condemned objects.  The next stage of the fix
operation is to look up the segment pointed to by the pointer and see if
it was condemned.  This is a fast lookup.

After that, each pool class must decide whether the pointer is to a
condemned object and do something to preserve it.  This code is still
critical.  The MPS will have tried to condemn objects that are dead, but
those objects are still likely to be in segments with other objects that
must be preserved.  The segment class fix method must quickly
distinguish between them.

Furthermore, many objects will be preserved at least once in their
lifetime, so even the code that preserves an object needs to be highly
efficient.  (Programs in languages like ML might not preserve 95% of
their objects even once, but many other programs will preserve nearly
all of theirs many times.)

   ---------- Footnotes ----------

   (1) https://www.memorymanagement.org/glossary/c.html#condemned.set

   (2) https://www.memorymanagement.org/glossary/r.html#remembered.set

   (3) https://www.memorymanagement.org/glossary/b.html#bibop


File: MemoryPoolSystem.info,  Node: Where to find the critical path,  Next: The format scanner,  Prev: How the MPS avoids scanning and fixing,  Up: The critical path through the MPS

4.7.4 Where to find the critical path
-------------------------------------

Very briefly, the critical path consists of five stages:

  1. The scanner, which iterates over pointers in objects.  The MPS has
     several internal scanners, but the most important ones will be
     format scanners in client code registered through *note
     mps_fmt_create_k(): 13f.

          Note: There needs to be a chapter in the manual explaining how
          to write a good scanner.  Then that could be linked from here.

  2. The first-stage fix, which filters out pointers inline in the
     scanner.  This is implemented in the *note MPS_FIX1(): 75. macro in
     mps.h(1).

  3. The second-stage fix, which filters out pointers using general
     information about segments.  This is ‘_mps_fix2()’ in trace.c(2).

  4. The third-stage fix, which filters out pointers using
     segment-specific information.  Implemented in segment class
     functions called *note amcSegFix(): 4bf, *note loSegFix(): 4c0,
     etc.  in pool*.c.

  5. Preserving the object, which might entail:

        - marking(3) it to prevent it being recycled; and/or

        - copying(4) it and updating the original pointer (or just
          updating the pointer, if the object has previously been
          copied); and/or

        - adding it to a queue of objects to be scanned later, if it
          contains pointers.

   ---------- Footnotes ----------

   (1) ../../../code/mps.h

   (2) ../../../code/trace.c

   (3) https://www.memorymanagement.org/glossary/m.html#marking

   (4) 
https://www.memorymanagement.org/glossary/c.html#copying.garbage.collection


File: MemoryPoolSystem.info,  Node: The format scanner,  Next: The second stage fix in the MPM,  Prev: Where to find the critical path,  Up: The critical path through the MPS

4.7.5 The format scanner
------------------------

The critical path starts when a format scan method is called.  That is a
call from the MPS to a client function of type *note mps_fmt_scan_t: 74.
registered with *note mps_fmt_create_k(): 13f.

Here is an example of part of a format scanner for scanning contiguous
runs of pointers, from fmtdy.c(1), the scanner for the Open Dylan(2)
runtime:

     static mps_res_t dylan_scan_contig(mps_ss_t mps_ss,
                                        mps_addr_t *base, mps_addr_t *limit)
     {
       mps_res_t res;
       mps_addr_t *p;        /* reference cursor */
       mps_addr_t r;         /* reference to be fixed */

       MPS_SCAN_BEGIN(mps_ss) {
               p = base;
         loop: if(p >= limit) goto out;
               r = *p++;
               if(((mps_word_t)r&3) != 0) /* pointers tagged with 0 */
                 goto loop;             /* not a pointer */
               if(!MPS_FIX1(mps_ss, r)) goto loop;
               res = MPS_FIX2(mps_ss, p-1);
               if(res == MPS_RES_OK) goto loop;
               return res;
         out:  assert(p == limit);
       } MPS_SCAN_END(mps_ss);

       return MPS_RES_OK;
     }

(To help with understanding optimisation of this code, it’s written in a
pseudo-assembler style, with one line roughly corresponding to each
instruction of an idealized intermediate code.)

The MPS C interface provides macros to try to help optimise this code.
The ‘mps_ss’ object is a “scan state” and contains data that is used to
eliminate uninteresting pointers now, and record information which will
be used to reduce scanning in future by maintaining the remembered set.

The macros *note MPS_SCAN_BEGIN(): 7a. and *note MPS_SCAN_END(): 7b.
load key data from the scan state into local variables, and hopefully
into processor registers.  This avoids aliasing values that we know
won’t change when calls are made to ‘_mps_fix2()’ later, and so allows
the compiler to keep the scan loop small and avoid unnecessary memory
references.

This scanner knows that words not ending in 0b00 aren’t pointers to
objects, so it eliminates them straight away.  This is a kind of
reference tag(3) chosen by the client for its object representation.

Next, the pointer is tested using *note MPS_FIX1(): 75.  This performs
fast tests on the pointer without using any other memory.  In
particular, it does the “zone check” described in section 3.  If a
pointer fails these tests, it isn’t interesting and can be skipped.  It
is very important to proceed to the next pointer as fast as possible in
this case.

Having passed these tests, we need to fix the pointer using other data
in memory, and possibly call the MPS to preserve the object.  This is
what *note MPS_FIX2(): 76. does.  The important distinction here is that
*note MPS_FIX2(): 76. can fail and return an error code, which must be
propagated without ado by returning from the scanner.  Separating *note
MPS_FIX1(): 75. from *note MPS_FIX2(): 76. helps keep the error handling
code away from the tight loop with the zone check.

‘MPS_FIX*’, the macro/inline part of the fix operation, are referred to
as “fix stage 1” or “the first stage fix” in other documents and
comments.

If these inline checks pass, ‘_mps_fix2()’ is called.  If the MPS has
been built as a separate object file or library, this is where the
function call out of the scan loop happens.  Since version 1.110 of the
MPS, we encourage clients to compile the MPS in the same translation
unit as their format code, so that the compiler can be intelligent about
inlining parts of ‘_mps_fix2()’ in the format scanner.  The instructions
for doing this are in Building the Memory Pool System(4), part of the
manual.

   ---------- Footnotes ----------

   (1) ../../../code/fmtdy.c

   (2) https://opendylan.org/

   (3) https://www.memorymanagement.org/glossary/t.html#tag

   (4) ../../../manual/build.txt


File: MemoryPoolSystem.info,  Node: The second stage fix in the MPM,  Next: The third stage fix in the segment class,  Prev: The format scanner,  Up: The critical path through the MPS

4.7.6 The second stage fix in the MPM
-------------------------------------

If a pointer gets past the first-stage fix filters, it is passed to
‘_mps_fix2()’, the “second stage fix”.  The second stage can filter out
yet more pointers using information about segments before it has to
consult the pool class.

The first test is to determine if the address points to a 'chunk' (a
contiguous region of address space managed by the arena).  Addresses
that do not point to any chunk (for example, ambiguous references that
are not in fact pointers) are rejected immediately.  See
‘ChunkOfAddr()’.

When there are many chunks (that is, when the arena has been extended
many times), this test can consume the majority of the garbage
collection time.  This is the reason that it’s important to give a good
estimate of the amount of address space you will ever occupy with
objects when you initialize the arena.

The second test applied is the “tract test”.  The MPS looks up the tract
containing the address in the tract table, which is a simple linear
table indexed by the address shifted—a kind of flat page table.  See
*note TractOfAddr(): 4c4.

If the pointer is in a tract allocated with garbage collected objects,
then the table also contains a pointer to a “segment”, which contains a
bitfield representing the “white set”—the set of garbage collection
traces for which the tract is “interesting”.  If a segment isn’t
interesting, then we know that it contains no condemned objects, and we
can filter out the pointer.

The MPM can’t know anything about the internal layout of the segment, so
at this point we dispatch to the third stage fix.

This dispatch is slightly subtle.  We have a cache of the function to
dispatch to in the scan state, which has recently been looked at and is
with luck still in the processor cache.  The reason there is a dispatch
at all is to allow for a fast changeover to emergency garbage
collection, or overriding of garbage collection with extra operations.
Those are beyond the scope of this document.  Normally, ‘ss->fix’ points
at ‘SegFix()’.

‘SegFix()’ is passed the segment, which is fetched from the tract table
entry, and that should be in the cache.  ‘SegFix()’ itself dispatches to
the segment class.


File: MemoryPoolSystem.info,  Node: The third stage fix in the segment class,  Next: Other considerations,  Prev: The second stage fix in the MPM,  Up: The critical path through the MPS

4.7.7 The third stage fix in the segment class
----------------------------------------------

The final stage of fixing is entirely dependent on the segment class.
The MPM can’t, in general, know how the objects within a segment are
arranged, so this is segment class specific code.

Furthermore, the segment class must make decisions based on the
“reference rank” of the pointer.  If a pointer is ambiguous
(‘RankAMBIG’) then it can’t be changed, so even a copying segment class
can’t move an object.  On the other hand, if the pointer is weak
(‘RankWEAK’) then the segment fix method shouldn’t preserve the object
at all, even if it’s condemned.

The exact details of the logic that the segment fix must implement in
order to co-operate with the MPM and other pools are beyond the scope of
this document, which is about the critical path.  Since it is on the
critical path, it’s important that whatever the segment fix does is
simple and fast and returns to scanning as soon as possible.

The first step, though, is to further filter out pointers which aren’t
to objects, if that’s its policy.  Then, it may preserve the object,
according to its policy, and possibly ensure that the object gets
scanned at some point in the future, if it contains more pointers.

If the object is moved to preserve it (for instance, if the pool class
implements a copying collector), or was already moved when fixing a
previous reference to it, the reference being fixed must be updated
(this is the origin of the term “fix”).

As a simple example, *note loSegFix(): 4c0. is the segment fix method
for segments belonging to the LO (Leaf Object) pool class.  It
implements a marking garbage collector, and does not have to worry about
scanning preserved objects because it is used to store objects that
don’t contain pointers.  (It is used in compiler run-time systems to
store binary data such as character strings, thus avoiding any scanning,
decoding, or remembered set overhead for them.)

*note loSegFix(): 4c0. filters any ambiguous pointers that aren’t
aligned, since they can’t point to objects it allocated.  Otherwise it
subtracts the segment base address and shifts the result to get an index
into a mark bit table.  If the object wasn’t marked and the pointer is
weak, then it sets the pointer to zero, since the object is about to be
recycled.  Otherwise, the mark bit is set, which preserves the object
from recycling when *note loSegReclaim(): 4c6. is called later on.
*note loSegFix(): 4c0. illustrates about the minimum and most efficient
thing a segment fix method can do.


File: MemoryPoolSystem.info,  Node: Other considerations,  Next: References<2>,  Prev: The third stage fix in the segment class,  Up: The critical path through the MPS

4.7.8 Other considerations
--------------------------

So far this document has described the ways in which the garbage
collector is designed around optimising the critical path.  There are a
few other things that the MPS does that are important.

Firstly, inlining is very important.  The first stage fix is inlined
into the format scanner by being implemented in macros in mps.h(1).  And
to get even better inlining, we recommend(2) that the whole MPS is
compiled in a single translation unit with the client format and that
strong global optimisation is applied.

Secondly, we are very careful with code annotations on the critical
path.  Assertions, statistics, and telemetry are all disabled on the
critical path in “hot” (production) builds.  (In fact, it’s because the
critical path is critical that we can afford to leave annotations
switched on elsewhere.)

Last, but by no means least, we pay a lot of brainpower and measurement
to the critical path, and are very very careful about changing it.  Code
review around the critical path is especially vigilant.

And we write long documents about it.

   ---------- Footnotes ----------

   (1) ../../../code/mps.h

   (2) ../../../manual/build.txt


File: MemoryPoolSystem.info,  Node: References<2>,  Prev: Other considerations,  Up: The critical path through the MPS

4.7.9 References
----------------


File: MemoryPoolSystem.info,  Node: Documentation,  Next: Execution environment,  Prev: The critical path through the MPS,  Up: Design

4.8 Documentation
=================

* Menu:

* Introduction: Introduction<9>.
* Types: Types<2>.
* Requirements: Requirements<6>.
* Implementation: Implementation<4>.
* Manual extensions::
* Design formatting conventions::
* References: References<3>.


File: MemoryPoolSystem.info,  Node: Introduction<9>,  Next: Types<2>,  Up: Documentation

4.8.1 Introduction
------------------

*note .intro;: 4cf. This is the design of the documentation system for
the Memory Pool System.

*note .readership;: 4d0. This document is intended for any MPS
developer.


File: MemoryPoolSystem.info,  Node: Types<2>,  Next: Requirements<6>,  Prev: Introduction<9>,  Up: Documentation

4.8.2 Types
-----------

*note .type;: 4d2. The MPS has multiple types of documentation, suitable
for different audiences.

*note .type.comment;: 4d3. Comments in the code provide information that
is required in order for developers to make correct edits to nearby
code.  (Audience: MPS developers editing nearby code.)

*note .type.design;: 4d4. Design documentation lists requirements and
explains how the code meets the requirements.  (Audience: MPS developers
working on a subsystem.)

*note .type.devguide;: 4d5. Developer guides provide general guidance
for developers, not specific to any particular subsystem.  (Audience:
MPS developers generally.)

*note .type.procedure;: 4d6. Procedures list the steps for carrying out
development tasks.  (Audience: MPS developers who need to carry out
particular tasks reliably.)

*note .type.tutorial;: 4d7. Tutorials describe how to use the MPS to
meet client program requirements.  (Audience: beginner client program
developers.)

*note .type.reference;: 4d8. Reference documentation specifies the
public features of the MPS. (Audience: expert client program
developers.)

*note .type.mmref;: 4d9. The Memory Management Reference describes
general principles of memory management, with cross-references to the
MPS documentation.  (Audience: the world.)


File: MemoryPoolSystem.info,  Node: Requirements<6>,  Next: Implementation<4>,  Prev: Types<2>,  Up: Documentation

4.8.3 Requirements
------------------

*note .req.source;: 4db. Derived from *note [RB_2013-05-09]: 4dc.

*note .req.easy;: 4dd. It must be easy to read and write documentation
using standard text editors.  Barriers to documentation must be low.

*note .req.presentation;: 4de. It must be possible to process
documentation into presentation formats, for example web pages.

*note .req.single-source;: 4df. Documents must have a single source.
Processing into other formats must be automatic and not depend on hand
editing or maintaining parallel versions.

*note .req.durable;: 4e0. The format of documents should be supported
for the foreseeable future.  It must not require continual updating to
keep up with changes to processing software.

*note .req.design.ref;: 4e1. It must be easy to reference points made in
design documents from the code.

*note .req.design.standalone;: 4e2. Design documents must stand alone:
they must not require particular software to make them readable or
complete.


File: MemoryPoolSystem.info,  Node: Implementation<4>,  Next: Manual extensions,  Prev: Requirements<6>,  Up: Documentation

4.8.4 Implementation
--------------------

*note .impl.rst;: 4e4. Documents are written in reStructuredText(1)
(RST).

*note .impl.design;: 4e5. Design documents are written in plain RST
(with no custom directives) to meet *note .req.design.standalone: 4e2.

*note .impl.design.pelican;: 4e6. Design documents are converted to HTML
using pelican.readers.RstReader(2) as part of Charlotte(3).

*note .impl.design.github;: 4e7. Design documents are also rendered as
HTML by GitHub(4).

*note .impl.manual;: 4e8. The manual is written in RST using Sphinx(5)
extensions and custom manual extensions (see *note .ext: 4e9.).

*note .impl.manual.sphinx;: 4ea. The manual is converted to HTML using
the Sphinx(6) documentation generator.

*note .impl.manual.design;: 4eb. Design documents are automatically
processed for inclusion in the manual using a set of formatting
conventions (see *note .fmt: 4ec.).

   ---------- Footnotes ----------

   (1) http://docutils.sourceforge.net/rst.html

   (2) 
https://fossies.org/dox/pelican-3.7.1/classpelican_1_1readers_1_1RstReader.html

   (3) https://info.ravenbrook.com/project/charlotte

   (4) 
https://docs.github.com/en/repositories/working-with-files/using-files/working-with-non-code-files#rendering-differences-in-prose-documents

   (5) https://www.sphinx-doc.org/en/master/

   (6) https://www.sphinx-doc.org/en/master/


File: MemoryPoolSystem.info,  Node: Manual extensions,  Next: Design formatting conventions,  Prev: Implementation<4>,  Up: Documentation

4.8.5 Manual extensions
-----------------------

*note .ext;: 4e9. These are reStructuredText directives and roles used
by the MPS manual.  See manual/source/extensions/mps/__init__.py.

*note .ext.aka;: 4ee. The ‘aka’ directive generates an “Also known as”
section.  This should be used in a glossary entry, and should contain a
comma-separated, alphabetically ordered, list of glossary entries (in
italics) that are synonyms for this glossary entry.

*note .ext.bibref;: 4ef. The ‘bibref’ directive generates a “Related
publication” or “Related publications” section.  This should be used in
a glossary entry, and should contain a comma-separated, alphabetically
ordered, list of ‘:ref:’ roles referring to entries in the bibliography.

*note .ext.deprecated;: 4f0. The ‘deprecated’ directive generates a
“Deprecated” section.  It should be used in a description of a public
interface in the MPS Reference, and describe the first version in which
the interface was deprecated, and the interface that should be used
instead.  There may be an initial “starting with version 1.115”
paragraph, but this is unnecessary if the directive is used in the
“Deprecated interfaces” chapter.

*note .ext.historical;: 4f1. The ‘historical’ directive generates a
“Historical note” section.  This should be used in a glossary entry, and
should contain material of historical interest, for example the origin
of the term, or ways in which it was formerly used.

*note .ext.link;: 4f2. The ‘link’ directive generates a “Related link”
or “Related links” section.  This should be used in a glossary entry,
and should contain a comma-separated list of references to URLs.

*note .ext.note;: 4f3. The ‘note’ directive generates a “Note” or
“Notes” section.  This should consist of a paragraph or a numbered list
containing especially important information about an interface that a
user should be aware of when using it.

*note .ext.opposite;: 4f4. The ‘opposite’ directive generates an
“Opposite term” or “Opposite terms” section.  This should be used in a
glossary entry, and should contain a comma-separated, alphabetically
ordered, list of ‘:term:’ roles referring to glossary entries with
opposite meaning.

*note .ext.relevance;: 4f5. The ‘relevance’ directive generates a
“Relevance to memory management” section.  This should be used in a
glossary entry, and should contain an explanation of how the term
relates to memory management, if this is not obvious.

*note .ext.see;: 4f6. The ‘see’ directive generates a “See” section.
This should be used in a glossary entry, and should contain a single
‘:term:’ role referring to the entry for which the currente entry is a
synonym.

*note .ext.seealso;: 4f7. The ‘seealso’ directive generates a “See also”
section.  This should be used in a glossary entry, and should contain a
comma-separated, alphabetically ordered, list of ‘:term:’ roles
referring to glossary entries that relate to the entry but are neither
synonyms for it (*note .ext.aka: 4ee.), nor opposites (*note
.ext.opposite: 4f4.), nor similar (*note .ext.similar: 4f8.).

*note .ext.similar;: 4f8. The ‘similar’ directive generates a “Similar
term” or “Similar terms” section.  This should be used in a glossary
entry, and should contain a comma-separated, alphabetically ordered,
list of ‘:term:’ roles referring to glossary entries with similar
meaning to the entry but which are not synonyms for it (*note .ext.aka:
4ee.).

*note .ext.specific;: 4f9. The ‘mps:specific’ directive generates an “In
the MPS” section.  This should be used in a glossary entry, and should
contain an explanation of how the glossary entry pertains to the MPS. If
the term is idiosyncratic to the MPS, for example “spare committed
memory” then the entire glossary entry should consist of a single
‘mps:specific’ directive to make it clear that the term is not in
general use.


File: MemoryPoolSystem.info,  Node: Design formatting conventions,  Next: References<3>,  Prev: Manual extensions,  Up: Documentation

4.8.6 Design formatting conventions
-----------------------------------

*note .fmt;: 4ec. This section lists formatting conventions used in the
design documentation that are used to generate extended markup when the
design document is converted for use in the MPS manual.  See
manual/source/extensions/mps/designs.py.

*note .fmt.function-decl;: 4fb. A paragraph consisting of a function
declaration on a single line formatted as code, for example:

     ``void LandFinish(Land land)``

is translated into a ‘c:function’ directive:

     .. c:function:: void LandFinish(Land land)

*note .fmt.macro-decl;: 4fc. A paragraph consisting of a macro
declaration on a single line formatted as code, for example:

     ``RING_FOR(node, ring, next)``

is translated into a ‘c:macro’ directive:

     .. c:macro:: RING_FOR(node, ring, next)

*note .fmt.macro;: 4fd. Macros are identified by having names consisting
of capital letters, numbers, and underscore, or appearing in the list of
exceptions given by the ‘MACROS’ global in designs.py.

*note .fmt.type-def;: 4fe. A paragraph consisting of a type definition
on a single line formatted as code, for example:

     ``typedef LandStruct *Land``

is translated into a ‘c:type’ directive:

     .. c:type:: LandStruct *Land

*note .fmt.function-ref;: 4ff. A word formatted as code and suffixed by
‘()’, for example:

     This saves a separate call to :c:func:`LandDelete()`, and uses the
     knowledge of exactly where we found the range.

is translated into a ‘:c:func:’ role:

     This saves a separate call to :c:func:`LandDelete`, and uses the
     knowledge of exactly where we found the range.

*note .fmt.type-ref;: 500. The name of an MPS type formatted as code,
for example:

     The function must return a :c:type:`Bool` indicating whether to continue
     with the iteration.

is translated into a ‘:c:type:’ role:

     The function must return a :c:type:`Bool` indicating whether to
     continue with the iteration.

The list of MPS types thus converted is given by the ‘TYPES’ global in
designs.py, plus any word matching ‘mps_[a-z_]+_[stu]’, plus any word
ending ‘Class’, ‘Function’, ‘Method’, ‘Struct’, or ‘Union’.

*note .fmt.tag;: 501. A paragraph starting with an MPS tag, for example:

     :mps:tag:`type.land` The type of a generic land instance.

is translated into an ‘:mps:tag:’ role:

     :mps:tag:`type.land` The type of a generic land instance.

*note .fmt.ref;: 502. Cross-references to tags, for example:

     A *node* is used in the typical data structure sense to mean an
     element of a tree (see also :mps:ref:`.type.tree`).

is translated into an ‘:mps:ref:’ role:

     A *node* is used in the typical data structure sense to mean an
     element of a tree (see also :mps:ref:`.type.tree`).

*note .fmt.history;: 503. The section “Document History” is removed.

*note .fmt.copyright;: 504. The section “Copyright and License” is
removed.

*note .fmt.sections;: 505. Section numbers are removed.

*note .fmt.metadata;: 506. Metadata roles are removed, except for:

*note .fmt.metadata.tag;: 507. ‘:Tag:’, which is translated into an
‘mps:prefix’ directive; and

*note .fmt.metadata.index;: 508. ‘:Index Terms:’, which is is translated
into an ‘index’ directive.

*note .fmt.citation;: 509. Citations are translated from design style:

     [Citation] "Title"; Author; Date; <URL>.

into manual style:

     [Citation] Author. Date. "`Title <URL>`__".

*note .fmt.link.relative;: 50a. Project-relative links must be specified
using named hyperlink targets(1) whose targets start with ‘../’, for
example:

     ``#ifdefs``, such as in mps.c_.

     .. _mps.c: ../../../code/mps.c

The target is adjusted to reflect the different location of the manual
sources relative to the design sources.

   ---------- Footnotes ----------

   (1) 
https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#hyperlink-targets


File: MemoryPoolSystem.info,  Node: References<3>,  Prev: Design formatting conventions,  Up: Documentation

4.8.7 References
----------------

(RB_2013-05-09) Richard Brooksby.  Ravenbrook Limited.  2013-05-09.
“MPS design document format and process(1)”.

   ---------- Footnotes ----------

   (1) https://info.ravenbrook.com/mail/2013/05/09/14-54-55/0/


File: MemoryPoolSystem.info,  Node: Execution environment,  Next: Fail-over allocator,  Prev: Documentation,  Up: Design

4.9 Execution environment
=========================

* Menu:

* Introduction: Introduction<10>.
* Discussion::
* Interpretation::
* Requirements: Requirements<7>.
* Architecture::


File: MemoryPoolSystem.info,  Node: Introduction<10>,  Next: Discussion,  Up: Execution environment

4.9.1 Introduction
------------------

*note .intro;: 512. This document describes how the MPS is designed to
work in different execution environments (see standard.ansic section
5.1.2).


File: MemoryPoolSystem.info,  Node: Discussion,  Next: Interpretation,  Prev: Introduction<10>,  Up: Execution environment

4.9.2 Discussion
----------------

*note .std;: 514. These are the relevant statements from the
International Standard ISO/IEC 9899:1990 “Programming languages — C”,
with tags added:

       4. Compliance

     […]

     *note .std.com.hosted;: 515. A “conforming hosted implementation”
     shall accept any strictly conforming program.  *note
     .std.com.free;: 516. A “conforming freestanding implementation”
     shall accept any strictly conforming program in which the use of
     the features specified in the library clause (clause 7) is confined
     to the contents of the standard headers ‘<float.h>’, ‘<limits.h>’,
     ‘<stdarg.h>’, and ‘<stddef.h>’.  A conforming implementation may
     have extensions (including additional library functions), provided
     they do not alter the behaviour of any strictly conforming program.

     […]

     5.1.2 Execution environments

     *note .std.def;: 517. Two execution environments are defined:
     “freestanding” and “hosted”.  […]

     *note .std.init;: 518. All objects in static storage shall be
     “initialized” (set to their initial values) before program startup.
     The manner and timing of such initialization are otherwise
     unspecified.  […]

     *note .std.term;: 519. “Program termination” returns control to the
     execution environment.  […]

     5.1.2.1 Freestanding environment

     *note .std.free.lib;: 51a. Any library facilities available to a
     freestanding environment are implementation-defined.

     *note .std.free.term;: 51b. The effect of program termination in a
     free-standing environment is implementation-defined.


File: MemoryPoolSystem.info,  Node: Interpretation,  Next: Requirements<7>,  Prev: Discussion,  Up: Execution environment

4.9.3 Interpretation
--------------------

*note .int.free;: 51d. We interpret the “freestanding environment” as
being the sort of environment you’d expect in an embedded system.  The
classic example is a washing machine.  There are no library facilities
available, only language facilities.

*note .int.free.lib;: 51e. We assume that the headers ‘<float.h>’,
‘<limits.h>’, ‘<stdarg.h>’ and ‘<stddef.h>’ are available in the
freestanding environment, because they define only language features and
not library calls.  We assume that we may not make use of definitions in
any other headers in freestanding parts of the system.

*note .int.free.term;: 51f. We may not terminate the program in a
freestanding environment, and therefore we may not call ‘abort()’.  We
can’t call ‘abort()’ anyway, because it’s not defined in the headers
listed above (*note .int.free.lib: 51e.).

*note .int.free.term.own;: 520. We can add an interface for asserting,
that is, reporting an error and not returning, for use in debugging
builds only.  This is because the environment can implement this in a
way that does not return to the MPS, but doesn’t terminate, either.  We
need this if debugging builds are to run in a (possibly simulated or
emulated) freestanding environment at all.


File: MemoryPoolSystem.info,  Node: Requirements<7>,  Next: Architecture,  Prev: Interpretation,  Up: Execution environment

4.9.4 Requirements
------------------

*note .req;: 522. It should be possible to make use of the MPS in a
freestanding environment such as an embedded controller.

*note .req.conf;: 523. There can be configurations of the MPS that are
not freestanding (such as using a VM arena).


File: MemoryPoolSystem.info,  Node: Architecture,  Prev: Requirements<7>,  Up: Execution environment

4.9.5 Architecture
------------------

*note .arch;: 525. Like Gaul, the MPS is divided into three parts: the
'core', the 'platform', and the 'plinth'.

*note .arch.core;: 526. The 'core' consists of the Memory Pool Manager
(the core data structures and algorithms) and the built-in Pool Classes.
The core must be freestanding.

*note .arch.platform;: 527. The 'platform' provides the core with
interfaces to features of the operating system and processor (locks,
memory protection, mutator context, stack probing, stack and register
scanning, thread management, and virtual memory).  The platform is
specialized to a particular environment and so can safely use whatever
features are available in that environment.

*note .arch.plinth;: 528. The 'plinth' provides the core with interfaces
to features of the user environment (time, assertions, and logging).
See design.mps.io(1) and design.mps.lib(2).

*note .arch.distinction;: 529. The distinction between 'plinth' and
'platform' is that end users will need to customize the features
provided by the plinth for most programs that use the MPS (and so the
interface needs to be simple, documented and supported), whereas
implementing the platform interface is a specialized task that will
typically be done once for each platform and then maintained alongside
the core.

   ---------- Footnotes ----------

   (1) io.html

   (2) lib.html


File: MemoryPoolSystem.info,  Node: Fail-over allocator,  Next: Finalization<3>,  Prev: Execution environment,  Up: Design

4.10 Fail-over allocator
========================

* Menu:

* Introduction: Introduction<11>.
* Interface: Interface<6>.
* Implementation: Implementation<5>.


File: MemoryPoolSystem.info,  Node: Introduction<11>,  Next: Interface<6>,  Up: Fail-over allocator

4.10.1 Introduction
-------------------

*note .intro;: 52f. This is the design of the fail-over allocator, a
data structure for the management of address ranges.

*note .readership;: 530. This document is intended for any MPS
developer.

*note .source;: 531. design.mps.land(1), design.mps.poolmvt(2),
design.mps.poolmvff(3).

*note .overview;: 532. The fail-over allocator combines two 'land'
instances.  It stores address ranges in one of the lands (the 'primary')
unless insertion fails, in which case it falls back to the other (the
'secondary').  The purpose is to be able to combine two lands with
different properties: with a CBS(4) for the primary and a Freelist(5)
for the secondary, operations are fast so long as there is memory to
allocate new nodes in the CBS(6), but operations can continue using the
Freelist(7) when memory is low.

   ---------- Footnotes ----------

   (1) land.html

   (2) poolmvt.html

   (3) poolmvff.html

   (4) cbs

   (5) freelist

   (6) cbs

   (7) freelist


File: MemoryPoolSystem.info,  Node: Interface<6>,  Next: Implementation<5>,  Prev: Introduction<11>,  Up: Fail-over allocator

4.10.2 Interface
----------------

*note .land;: 535. The fail-over allocator is an implementation of the
'land' abstract data type, so the interface consists of the generic
functions for lands.  See design.mps.land(1).

* Menu:

* Types: Types<3>.
* Classes::
* Keyword arguments: Keyword arguments<3>.

   ---------- Footnotes ----------

   (1) land.html


File: MemoryPoolSystem.info,  Node: Types<3>,  Next: Classes,  Up: Interface<6>

4.10.2.1 Types
..............

 -- C Type: typedef struct FailoverStruct *Failover

*note .type.failover;: 538. The type of fail-over allocator structures.
A ‘FailoverStruct’ is typically embedded in another structure.


File: MemoryPoolSystem.info,  Node: Classes,  Next: Keyword arguments<3>,  Prev: Types<3>,  Up: Interface<6>

4.10.2.2 Classes
................

*note .class;: 53a. ‘CLASS(Failover)’ is the fail-over allocator class,
a subclass of ‘CLASS(Land)’ suitable for passing to *note LandInit():
406.


File: MemoryPoolSystem.info,  Node: Keyword arguments<3>,  Prev: Classes,  Up: Interface<6>

4.10.2.3 Keyword arguments
..........................

When initializing a fail-over allocator, *note LandInit(): 406. requires
these two keyword arguments:

   * ‘FailoverPrimary’ (type *note Land: 53c.) is the primary land.

   * ‘FailoverSecondary’ (type *note Land: 53c.) is the secondary land.


File: MemoryPoolSystem.info,  Node: Implementation<5>,  Prev: Interface<6>,  Up: Fail-over allocator

4.10.3 Implementation
---------------------

*note .impl.assume;: 53e. The implementation assumes that the primary is
fast but space-hungry (a CBS(1)) and the secondary is slow but
space-frugal (a Freelist(2)).  This assumption is used in the following
places:

*note .impl.assume.flush;: 53f. The fail-over allocator attempts to
flush the secondary to the primary before any operation, in order to
benefit from the speed of the primary wherever possible.  In the normal
case where the secondary is empty this is cheap.

*note .impl.assume.delete;: 540. When deletion of a range on the primary
fails due to lack of memory, we assume that this can only happen when
there are splinters on both sides of the deleted range, one of which
needs to be allocated a new node (this is the case for CBS(3)), and that
therefore the following procedure will be effective: first, delete the
enclosing range from the primary (leaving no splinters and thus
requiring no allocation), and re-insert the splinters (failing over to
the secondary if necessary).

   ---------- Footnotes ----------

   (1) cbs

   (2) freelist

   (3) cbs


File: MemoryPoolSystem.info,  Node: Finalization<3>,  Next: Free list allocator,  Prev: Fail-over allocator,  Up: Design

4.11 Finalization
=================

* Menu:

* Overview: Overview<2>.
* Requirements: Requirements<8>.
* Implementation: Implementation<6>.
* External interface::
* Internal interface::


File: MemoryPoolSystem.info,  Node: Overview<2>,  Next: Requirements<8>,  Up: Finalization<3>

4.11.1 Overview
---------------

*note .overview;: 546. Finalization is implemented internally using the
MRG pool class (design.mps.poolmrg(1)).  Objects can be registered for
finalization by calling *note mps_finalize(): e8.  Notification of
finalization is given to the client via the messaging interface
(design.mps.message(2)).  The MRG pool class implements a *note Message:
547. subclass which implements the finalization messages.

   ---------- Footnotes ----------

   (1) poolmrg.html

   (2) message.html


File: MemoryPoolSystem.info,  Node: Requirements<8>,  Next: Implementation<6>,  Prev: Overview<2>,  Up: Finalization<3>

4.11.2 Requirements
-------------------

*note .req;: 54a. Historically only Dylan had requirements for
finalization, see req.dylan.fun.final(1).  Now (2003-02-19) Configura
have requirements for finalization.  Happily they are very similar.

   ---------- Footnotes ----------

   (1) 
https://info.ravenbrook.com/project/mps/import/2001-09-27/mminfo/doc/req/dylan


File: MemoryPoolSystem.info,  Node: Implementation<6>,  Next: External interface,  Prev: Requirements<8>,  Up: Finalization<3>

4.11.3 Implementation
---------------------

*note .impl.over;: 54d. Registering an object for finalization
corresponds to allocating a reference of rank FINAL to that object.
This reference is allocated in a guardian object in a pool belonging to
the MRG pool class (see design.mps.poolmrg(1)).

*note .impl.arena.struct;: 54e. A single pool belonging to the MRG pool
class and used for managing final references is kept in the arena and
referred to as the “final pool”.

*note .impl.arena.lazy;: 54f. The final pool is lazily created.  It is
not created until the first object is registered for finalization.

*note .impl.arena.flag;: 550. There is a flag in the Arena that
indicates whether the final pool has been created yet or not.

*note .impl.scan;: 551. An object is determined to be finalizable if it
is fixed at rank FINAL for a trace, and was not fixed at any lower rank
for that trace.  See design.mps.poolmrg.scan.wasold(2).

*note .impl.message;: 552. When an object is determined to be
finalizable, a message for that object is posted to the arena’s message
queue.

*note .impl.arena-destroy.empty;: 553. ‘ArenaDestroy()’ empties the
message queue by calling *note MessageEmpty(): 554.

*note .impl.arena-destroy.final-pool;: 555. If the final pool has been
created then ‘ArenaDestroy()’ destroys the final pool.

*note .impl.access;: 556. *note mps_message_finalization_ref(): ed.
needs to access the finalization message to retrieve the reference and
then write it to where the client asks.  This must be done carefully, in
order to avoid invalidating collection invariants such as the segment
summary.

*note .impl.invariants;: 557. We protect the invariants by using
‘ArenaRead()’ and ‘ArenaWrite()’ to read and write the reference via the
software barrier.

   ---------- Footnotes ----------

   (1) poolmrg.html

   (2) poolmrg.html#design.mps.poolmrg.scan.wasold


File: MemoryPoolSystem.info,  Node: External interface,  Next: Internal interface,  Prev: Implementation<6>,  Up: Finalization<3>

4.11.4 External interface
-------------------------

*note .if.register;: 559. *note mps_finalize(): e8. registers an object
for finalization.

*note .if.deregister;: 55a. *note mps_definalize(): 24c. deregisters an
object for finalization.  It is an error to definalize an object that
has not been registered for finalization.

*note .if.get-ref;: 55b. *note mps_message_finalization_ref(): ed.
returns the reference to the finalized object stored in the finalization
message.

*note .if.multiple;: 55c. The external interface allows an object to be
registered multiple times, but does not specify the number of
finalization messages that will be posted for that object.


File: MemoryPoolSystem.info,  Node: Internal interface,  Prev: External interface,  Up: Finalization<3>

4.11.5 Internal interface
-------------------------

 -- C Function: *note Res: 55f. ArenaFinalize (Arena arena, Ref addr)

*note .int.finalize.create;: 560. Creates the final pool if it has not
been created yet.

*note .int.finalize.alloc;: 561. Allocates a guardian in the final pool.

*note .int.finalize.alloc.multiple;: 562. A consequence of this
implementation is that if an object is finalized multiple times, then
multiple guardians are created in the final pool, and so multiple
messages will be posted to the message queue when the object is
determined to be finalizable.  But this behaviour is not guaranteed by
the documentation, leaving us free to change the implementation.

*note .int.finalize.write;: 563. Writes a reference to the object into
the guardian object.

*note .int.finalize.all;: 564. That’s all.

*note .int.finalize.error;: 565. If either the creation of the pool or
the allocation of the object fails then the error is returned to the
caller.

*note .int.finalize.error.no-unwind;: 566. This function does not need
to do any unwinding in the error cases because the creation of the pool
is not something that needs to be undone.

 -- C Function: *note Res: 55f. ArenaDefinalize (Arena arena, Ref obj)

*note .int.definalize.fail;: 568. If the final pool has not been
created, return ‘ResFAIL’ immediately.

*note .int.definalize.search;: 569. Otherwise, search for a guardian in
the final pool that refers to the object and which has not yet been
finalized.  If one is found, delete it and return ‘ResOK’.  Otherwise no
guardians in the final pool refer to the object, so return ‘ResFAIL’.


File: MemoryPoolSystem.info,  Node: Free list allocator,  Next: New developer guide,  Prev: Finalization<3>,  Up: Design

4.12 Free list allocator
========================

* Menu:

* Introduction: Introduction<12>.
* Overview: Overview<3>.
* Requirements: Requirements<9>.
* Interface: Interface<7>.
* Implementation: Implementation<7>.
* Testing: Testing<2>.
* Opportunities for improvement::


File: MemoryPoolSystem.info,  Node: Introduction<12>,  Next: Overview<3>,  Up: Free list allocator

4.12.1 Introduction
-------------------

*note .intro;: 56f. This is the design of the free list allocator.

*note .readership;: 570. Any MPS developer.


File: MemoryPoolSystem.info,  Node: Overview<3>,  Next: Requirements<9>,  Prev: Introduction<12>,  Up: Free list allocator

4.12.2 Overview
---------------

*note .overview;: 572. The free list allocator is an “emergency”
allocator.  It is intended for use as a fallback allocation strategy in
low memory situations, when memory is not available for the control
structures needed by other allocators.  In these situations the free
list allocator ensures that memory is not lost, but with several
disadvantages:

  1. operations on the free list take time proportional to the number of
     free blocks;

  2. the data structures are stored in client memory and so are
     vulnerable to corruption;

  3. the data structures have poor locality (and thus potentially poor
     cache performance).

When memory becomes available again to allocate control structures, the
free lists can be “flushed” back into the more efficient data
structures.


File: MemoryPoolSystem.info,  Node: Requirements<9>,  Next: Interface<7>,  Prev: Overview<3>,  Up: Free list allocator

4.12.3 Requirements
-------------------

In addition to the generic land requirements (see design.mps.land(1)),
free lists must satisfy:

*note .req.zero-overhead;: 574. Must have zero space overhead for the
storage of any set of free blocks, so that it can be used to manage
memory when no memory can be allocated for control structures.

   ---------- Footnotes ----------

   (1) land.html


File: MemoryPoolSystem.info,  Node: Interface<7>,  Next: Implementation<7>,  Prev: Requirements<9>,  Up: Free list allocator

4.12.4 Interface
----------------

*note .land;: 576. Free lists are an implementation of the 'land'
abstract data type, so the interface consists of the generic functions
for lands.  See design.mps.land(1).

* Menu:

* Types: Types<4>.
* Classes: Classes<2>.
* Keyword arguments: Keyword arguments<4>.

   ---------- Footnotes ----------

   (1) land.html


File: MemoryPoolSystem.info,  Node: Types<4>,  Next: Classes<2>,  Up: Interface<7>

4.12.4.1 Types
..............

 -- C Type: typedef struct FreelistStruct *Freelist

*note .type.freelist;: 579. The type of free lists.  A ‘FreelistStruct’
is typically embedded in another structure.


File: MemoryPoolSystem.info,  Node: Classes<2>,  Next: Keyword arguments<4>,  Prev: Types<4>,  Up: Interface<7>

4.12.4.2 Classes
................

*note .class;: 57b. ‘CLASS(Freelist)’ is the free list class, a subclass
of ‘CLASS(Land)’ suitable for passing to *note LandInit(): 406.


File: MemoryPoolSystem.info,  Node: Keyword arguments<4>,  Prev: Classes<2>,  Up: Interface<7>

4.12.4.3 Keyword arguments
..........................

When initializing a free list, *note LandInit(): 406. takes no keyword
arguments.  Pass ‘mps_args_none’.


File: MemoryPoolSystem.info,  Node: Implementation<7>,  Next: Testing<2>,  Prev: Interface<7>,  Up: Free list allocator

4.12.5 Implementation
---------------------

*note .impl.list;: 57e. The isolated contiguous free address ranges are
kept on an address-ordered singly linked free list.  (As in traditional
‘malloc()’ implementations.)

*note .impl.block;: 57f. If the free address range is large enough to
contain an inline block descriptor consisting of two pointers, then the
two pointers stored are to the next free range in address order (or
‘freelistEND’ if there are no more ranges), and to the limit of the
current free address range, in that order.

*note .impl.grain;: 580. Otherwise, the free address range must be large
enough to contain a single pointer.  The pointer stored is to the next
free range in address order, or ‘freelistEND’ if there are no more
ranges.

*note .impl.tag;: 581. Grains and blocks are distinguished by a one-bit
tag in the low bit of the first word (the one containing the pointer to
the next range).  Grains have this bit set; blocks have this bit reset.

*note .impl.invariant;: 582. The ranges stored in the free list are
'isolated': no two ranges are adjacent or overlapping.

*note .impl.merge;: 583. When a free address range is added to the free
list, it is merged with adjacent ranges so as to maintain *note
.impl.invariant: 582.

*note .impl.rule.break;: 584. The use of ‘freelistEND’ to mark the end
of the list violates the rule that exceptional values should not be used
to distinguish exceptional situations.  This infraction allows the
implementation to meet *note .req.zero-overhead: 574.  (There are other
ways to do this, such as using another tag to indicate the last block in
the list, but these would be more complicated.)


File: MemoryPoolSystem.info,  Node: Testing<2>,  Next: Opportunities for improvement,  Prev: Implementation<7>,  Up: Free list allocator

4.12.6 Testing
--------------

*note .test;: 586. The following testing will be performed on this
module:

*note .test.land;: 587. A generic test for land implementations.  See
design.mps.land.test(1).

*note .test.pool;: 588. Two pools (MVT(2) and MVFF(3)) use free lists as
a fallback when low on memory.  These are subject to testing in
development, QA, and are heavily exercised by customers.

   ---------- Footnotes ----------

   (1) land.html#design.mps.land.test

   (2) poolmvt

   (3) poolmvff


File: MemoryPoolSystem.info,  Node: Opportunities for improvement,  Prev: Testing<2>,  Up: Free list allocator

4.12.7 Opportunities for improvement
------------------------------------

*note .improve.length;: 58b. When iterating over the list, we could
check that the number of elements visited in the course of the iteration
does not exceed the recorded size of the list.

*note .improve.maxsize;: 58c. We could maintain the maximum size of any
range on the list, and use that to make an early exit from
‘freelistFindLargest()’.  It’s not clear that this would actually be an
improvement.


File: MemoryPoolSystem.info,  Node: New developer guide,  Next: Transliterating the alphabet into hexadecimal,  Prev: Free list allocator,  Up: Design

4.13 New developer guide
========================

* Menu:

* Introduction: Introduction<13>.
* What to read first::
* References: References<4>.


File: MemoryPoolSystem.info,  Node: Introduction<13>,  Next: What to read first,  Up: New developer guide

4.13.1 Introduction
-------------------

*note .intro;: 592. This is an introduction to the Memory Pool System
(MPS) for new developers.

*note .source;: 593. This is based on *note [APT_2018-09-17]: 594.


File: MemoryPoolSystem.info,  Node: What to read first,  Next: References<4>,  Prev: Introduction<13>,  Up: New developer guide

4.13.2 What to read first
-------------------------

   * manual/build.txt(1) – how to build the MPS.

   * manual/guide(2) – tutorial for the public interface.

   * manual/topic(3) – reference manual for the public interface.

   * manual/code-index(4) – description and purpose of each file of
     source code.

   * design.mps.config(5) – build configuration.

   * design.mps.tests(6) – how to run test cases.

   * design.mps.doc(7) – how to write and edit documentation.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/master/manual/build.txt

   (2) 
https://www.ravenbrook.com/project/mps/master/manual/html/guide/index.html

   (3) 
https://www.ravenbrook.com/project/mps/master/manual/html/topic/index.html

   (4) 
https://www.ravenbrook.com/project/mps/master/manual/html/code-index.html

   (5) config.html

   (6) tests.html

   (7) doc.html


File: MemoryPoolSystem.info,  Node: References<4>,  Prev: What to read first,  Up: New developer guide

4.13.3 References
-----------------

(APT_2018-09-17) “Procedure for new developers”; Alistair Turnbull;
Ravenbrook Limited; 2018-09-17;
<‘https://info.ravenbrook.com/mail/2018/09/17/11-16-41/0/’>


File: MemoryPoolSystem.info,  Node: Transliterating the alphabet into hexadecimal,  Next: C Style – formatting,  Prev: New developer guide,  Up: Design

4.14 Transliterating the alphabet into hexadecimal
==================================================

* Menu:

* Introduction: Introduction<14>.
* Transliteration::
* Justification::
* Notes::
* References: References<5>.


File: MemoryPoolSystem.info,  Node: Introduction<14>,  Next: Transliteration,  Up: Transliterating the alphabet into hexadecimal

4.14.1 Introduction
-------------------

*note .scope;: 59d. This document explains how to represent the alphabet
as hexadecimal digits.

*note .readership;: 59e. This document is intended for anyone devising
arbitrary constants which may appear in hex-dumps.

*note .sources;: 59f. This transliteration was supplied by Richard
Kistruck *note [RHSK-1997-04-07]: 5a0. based on magic number encodings
for object signatures used by Richard Brooksby *note [RB-1996-02-12]:
5a1, the existence of which was inspired by the structure marking used
in the Multics operating system *note [THVV-1995]: 5a2.


File: MemoryPoolSystem.info,  Node: Transliteration,  Next: Justification,  Prev: Introduction<14>,  Up: Transliterating the alphabet into hexadecimal

4.14.2 Transliteration
----------------------

*note .forward;: 5a4. The chosen transliteration is as follows:

     ABCDEFGHIJKLMNOPQRSTUVWXYZ
     ABCDEF9811C7340BC6520F3812

*note .backward;: 5a5. The backwards transliteration is as follows:

     0 OU
     1 IJY
     2 TZ
     3 MW
     4 N
     5 S
     6 R
     7 L
     8 HX
     9 G
     A A
     B BP
     C CKQ
     D D
     E E
     F FV

*note .pad;: 5a6. If padding is required (to fill a hex constant
length), you should use 9’s, because G is rare and can usually be
inferred from context.

*note .punc;: 5a7. There is no formal scheme for spaces, or punctuation.
It is suggested that you use 9 (as *note .pad: 5a6.).


File: MemoryPoolSystem.info,  Node: Justification,  Next: Notes,  Prev: Transliteration,  Up: Transliterating the alphabet into hexadecimal

4.14.3 Justification
--------------------

*note .letters;: 5a9. The hexadecimal letters (A-F) are all formed by
similarity of sound.  B and P sound similar, as do F and V, and C, K, &
Q can all sound similar.

*note .numbers;: 5aa. The numbers (0-9) are all formed by similarity of
shape (but see *note .trans.t: 5ab.).  Nevertheless, 1=IJY retains some
similarity of sound.

*note .trans.t;: 5ab. T is an exception to *note .numbers: 5aa, but is
such a common letter that it deserves it.


File: MemoryPoolSystem.info,  Node: Notes,  Next: References<5>,  Prev: Justification,  Up: Transliterating the alphabet into hexadecimal

4.14.4 Notes
------------

*note .change;: 5ad. This transliteration differs from the old
transliteration used for signatures (see design.mps.sig(1)), as follows:
J:6->1; L:1->7; N:9->4; R:4->6; W:8->3; X:5->8; Y:E->I.

*note .problem.mw;: 5ae. There is a known problem that M and W are both
common, map to the same digit (3), and are hard to distinguish in
context.

*note .find.c;: 5af. It is possible to find all 8-digit hexadecimal
constants and how many times they’re used in C files, using the
following Perl script:

     perl5 -n -e 'BEGIN { %C=(); } if(/0x([0-9A-Fa-f]{8})/) { $C{$1} = +[] if(
     !defined($C{$1})); push(@{$C{$1}}, $ARGV); } END { foreach $H (sort(keys(%C)))
     { printf "%3d %s %s\n", scalar(@{$C{$H}}), $H, join(", ", @{@C{$H}}); } }' *.c
     *.h

*note .comment;: 5b0. It is a good idea to add a comment to any constant
declaration indicating the English version and which letters were
selected (by capitalisation), e.g.:

     #define SpaceSig        ((Sig)0x5195BACE) /* SIGnature SPACE */

   ---------- Footnotes ----------

   (1) sig.html


File: MemoryPoolSystem.info,  Node: References<5>,  Prev: Notes,  Up: Transliterating the alphabet into hexadecimal

4.14.5 References
-----------------

(RB-1996-02-12) “Signature magic numbers” (e-mail message); Richard
Brooksby <rb@ravenbrook.com>; Harlequin; 1996-12-02 12:05:30Z.

(RHSK-1997-04-07) “Alpha-to-Hex v1.0 beta”; Richard Kistruck;
Ravenbrook; 1997-04-07 14:42:02+0100;
<‘https://info.ravenbrook.com/project/mps/mail/1997/04/07/13-44/0.txt’>.

(THVV-1995) “Structure Marking”; Tom Van Vleck; multicians.org(1);
<‘http://www.multicians.org/thvv/marking.html’>.

   ---------- Footnotes ----------

   (1) http://www.multicians.org/


File: MemoryPoolSystem.info,  Node: C Style – formatting,  Next: C Style – naming,  Prev: Transliterating the alphabet into hexadecimal,  Up: Design

4.15 C Style – formatting
=========================

* Menu:

* Introduction: Introduction<15>.
* General formatting conventions::


File: MemoryPoolSystem.info,  Node: Introduction<15>,  Next: General formatting conventions,  Up: C Style – formatting

4.15.1 Introduction
-------------------

*note .scope;: 5b8. This document describes the Ravenbrook conventions
for the general format of C source code in the MPS.

*note .readership;: 5b9. This document is intended for anyone working on
or with the C source code.


File: MemoryPoolSystem.info,  Node: General formatting conventions,  Prev: Introduction<15>,  Up: C Style – formatting

4.15.2 General formatting conventions
-------------------------------------

* Menu:

* Line width::
* White space::
* Sections and paragraphs::
* Statements::
* Indentation::
* Positioning of braces::
* Switch statements::
* Comments::
* Macros: Macros<2>.


File: MemoryPoolSystem.info,  Node: Line width,  Next: White space,  Up: General formatting conventions

4.15.2.1 Line width
...................

*note .width;: 5bc. Lines should be no wider than 72 characters.  *note
.width.why;: 5bd. Many people use 80 column terminal windows so that
multiple windows can be placed side by side.  Restricting lines to 72
characters allows line numbering to be used (in vi for example) and also
allows diffs to be displayed without overflowing the terminal.


File: MemoryPoolSystem.info,  Node: White space,  Next: Sections and paragraphs,  Prev: Line width,  Up: General formatting conventions

4.15.2.2 White space
....................

*note .space.notab;: 5bf. No tab characters should appear in the source
files.  Ordinary spaces should be used to indent and format the sources.

*note .space.notab.why;: 5c0. Tab characters are displayed differently
on different platforms, and sometimes translated back and forth,
destroying layout information.

*note .space.punct;: 5c1. There should always be whitespace after commas
and semicolons and similar punctuation.

*note .space.op;: 5c2. Put white space around operators in expressions,
except when removing it would make the expression clearer by binding
certain sub-expressions more tightly.  For example:

     foo = x + y*z;

*note .space.control;: 5c3. One space between a control-flow keyword
(‘switch’, ‘while’, ‘for’, ‘if’) and the following opening parenthesis.

*note .space.control.why;: 5c4. This distinguishes control statements
lexically from function calls, making it easier to distinguish them
visually and when searching with tools like ‘grep’.

*note .space.function.not;: 5c5. No space between a function name and
the opening parenthesis beginning its argument list.


File: MemoryPoolSystem.info,  Node: Sections and paragraphs,  Next: Statements,  Prev: White space,  Up: General formatting conventions

4.15.2.3 Sections and paragraphs
................................

*note .section;: 5c7. Source files can be thought of as breaking down
into “sections” and “paragraphs”.  A section might be the leader comment
of a file, the imports, or a set of declarations which are related.

*note .section.space;: 5c8. Precede sections by two blank lines (except
the first one in the file, which should be the leader comment in any
case).

*note .section.comment;: 5c9. Each section should start with a banner
comment (see *note .comment.banner: 5ca.) describing what the section
contains.

*note .para;: 5cb. Within sections, code often breaks down into natural
units called “paragraphs”.  A paragraph might be a set of strongly
related declarations (Init and Finish, for example), or a few lines of
code which it makes sense to consider together (the assignment of fields
into a structure, for example).

*note .para.space;: 5cc. Precede paragraphs by a single blank line.


File: MemoryPoolSystem.info,  Node: Statements,  Next: Indentation,  Prev: Sections and paragraphs,  Up: General formatting conventions

4.15.2.4 Statements
...................

*note .statement.one;: 5ce. Generally only have at most one statement
per line.  In particular the following are deprecated:

     if (thing) return;

     a=0; b=0;

     case 0: f = inRampMode ? AMCGen0RampmodeFrequency : AMCGen0Frequency;

*note .statement.one.why;: 5cf. Debuggers can often only place
breakpoints on lines, not expressions or statements within a line.  The
‘if (thing) return;’ is a particularly important case, if thing is a
reasonably rare return condition then you might want to breakpoint it in
a debugger session.  Annoying because ‘if (thing) return;’ is quite
compact and pleasing otherwise.


File: MemoryPoolSystem.info,  Node: Indentation,  Next: Positioning of braces,  Prev: Statements,  Up: General formatting conventions

4.15.2.5 Indentation
....................

*note .indent;: 5d1. Indent the body of a block by two spaces.  For
formatting purposes, the “body of a block” means:

   - statements between braces,

   - a single statement following a lone ‘if’;

   - statements in a switch body; see .switch.

(*note .indent.logical;: 5d2. The aim is to group what we think of as
logical blocks, even though they may not exactly match how “block” is
used in the definition of C syntax).

Some examples:

     if (res != ResOK) {
       SegFinish(&span->segStruct);
       PoolFreeP(MV->spanPool, span, sizeof(SpanStruct));
       return res;
     }

     if (res != ResOK)
       goto error;

     if (j == block->base) {
       if (j+step == block->limit) {
         if (block->thing)
           putc('@', stream);
       }
     } else if (j+step == block->limit) {
       putc(']', stream);
       pop_bracket();
     } else {
       putc('.', stream);
     }

     switch (c) {
     case 'A':
       c = 'A';
       p += 1;
       break;
     }

*note .indent.goto-label;: 5d3. Place each goto-label on a line of its
own, outdented to the same level as the surrounding block.  Then indent
the non-label part of the statement normally.

     result foo(void)
     {
       statement();
       if (error)
         goto foo;
       statement();
       return OK;

     foo:
       unwind();
       return ERROR;
     }

*note .indent.case-label;: 5d4. Outdent case- and default-labels in a
switch statement in the same way as *note .indent.goto-label: 5d3.  See
*note .switch: 5d5.

*note .indent.cont;: 5d6. If an expression or statement won’t fit on a
single line, indent the continuation lines by two spaces, apart from the
following exception:

*note .indent.cont.parens;: 5d7. if you break a statement inside a
parameter list or other parenthesized expression, indent so that the
continuation lines up just after the open parenthesis.  For example:

     res = ChunkInit(chunk, arena, alignedBase,
                     AddrAlignDown(limit, ArenaGrainSize(arena)),
                     AddrOffset(base, limit), boot);

*note .indent.cont.expr;: 5d8. Note that when breaking an expression it
is clearer to place the operator at the start of the continuation line:

     CHECKL(AddrAdd((Addr)chunk->allocTable, BTSize(chunk->pages))
            <= PageIndexBase(chunk, chunk->allocBase));

This is particularly useful in long conditional expressions that use &&
and ||.  For example:

     if (BufferRankSet(buffer) != RankSetEMPTY
         && (buffer->mode & BufferModeFLIPPED) == 0
         && !BufferIsReset(buffer))

*note .indent.hint;: 5d9. Usually, it is possible to determine the
correct indentation for a line by looking to see if the previous line
ends with a semicolon.  If it does, indent to the same amount, otherwise
indent by two more spaces.  The main exceptions are lines starting with
a close brace, goto-labels, and line-breaks between parentheses.


File: MemoryPoolSystem.info,  Node: Positioning of braces,  Next: Switch statements,  Prev: Indentation,  Up: General formatting conventions

4.15.2.6 Positioning of braces
..............................

*note .brace.otb;: 5db. Use the “One True Brace” (or OTB) style.  This
places the open brace after the control word or expression, separated by
a space, and when there is an else, places that after the close brace.
For example:

     if (buffer->mode & BufferModeFLIPPED) {
       return buffer->initAtFlip;
     } else {
       return buffer->ap_s.init;
     }

The same applies to ‘struct’, ‘enum’, and ‘union’.

*note .brace.otb.function.not;: 5dc. OTB is never used for function
definitions.

*note .brace.always;: 5dd. Braces are always required after ‘if’,
‘else’, ‘switch’, ‘while’, ‘do’, and ‘for’.

*note .brace.always.except;: 5de. Except that a lone ‘if’ with no ‘else’
is allowed to drop its braces when its body is a single simple
statement.  Typically this will be a ‘goto’ or an assignment.  For
example:

     if (res != ResOK)
       goto failStart;

Note in particular that an ‘if’ with an ‘else’ must have braces on both
paths.


File: MemoryPoolSystem.info,  Node: Switch statements,  Next: Comments,  Prev: Positioning of braces,  Up: General formatting conventions

4.15.2.7 Switch statements
..........................

*note .switch;: 5d5. format switch statements like this:

     switch (SplaySplay(splay, oldKey, splay->compare)) {
     default:
       NOTREACHED;
       /* fall through */
     case CompareLESS:
       return SplayTreeRoot(splay);

     case CompareGREATER:
     case CompareEQUAL:
       return SplayTreeSuccessor(splay);
     }

The component rules that result in this style are:

*note .switch.break;: 5e0. The last line of every case-clause body must
be an unconditional jump statement (usually ‘break’, but may be ‘goto’,
‘continue’, or ‘return’), or if a fall-through is intended, the comment
‘/* fall through */’.  (Note: if the unconditional jump should never be
taken, because of previous conditional jumps, use ‘NOTREACHED’ on the
line before it.)  This rule is to prevent accidental fall-throughs, even
if someone makes a editing mistake that causes a conditional jump to be
missed.  This rule is automatically checked by GCC and Clang with the
‘-Wimplicit-fallthrough’ option.

*note .switch.default;: 5e1. It is usually a good idea to have a
default-clause, even if all it contains is ‘NOTREACHED’ and ‘break’ or
‘/* fall through */’.  Remember that ‘NOTREACHED’ doesn’t stop the
process in all build varieties.


File: MemoryPoolSystem.info,  Node: Comments,  Next: Macros<2>,  Prev: Switch statements,  Up: General formatting conventions

4.15.2.8 Comments
.................

*note .comment;: 5e3. There are three types of comments: banners,
paragraph comments, and column comments.

*note .comment.banner;: 5ca. Banner comments come at the start of
sections.  A banner comment consists of a heading usually composed of a
symbol, an em-dash (–) and a short explanation, followed by English text
which is formatted using conventional text documentation guidelines (see
guide.text).  The open and close comment tokens (‘/*’ and ‘*/’) are
placed at the top and bottom of a column of asterisks.  The text is
separated from the asterisks by one space.  Place a blank line between
the banner comment and the section it comments.  For example:

     /* BlockStruct --  Block descriptor
      *
      * The pool maintains a descriptor structure for each
      * contiguous allocated block of memory it manages.
      * The descriptor is on a simple linked-list of such
      * descriptors, which is in ascending order of address.
      */

     typedef struct BlockStruct {

*note .comment.para;: 5e4. Paragraph comments come at the start of
paragraphs in the code.  A paragraph comment consists of formatted
English text.  For example:

     /* If the freed area is in the base sentinel then insert
        the new descriptor after it, otherwise insert before. */
     if (isBase) {

*note .comment.para.precede;: 5e5. Paragraph comments, even one-liners,
precede the code to which they apply.

*note .comment.column;: 5e6. Column comments appear in a column to the
right of the code.  They should be used sparingly, since they clutter
the code and make it hard to edit.  Use them on variable declarations
and structure, union, or enum declarations.  They should start at least
at column 32 (counting from 0, that is, on a tab-stop), and should be
terse descriptive text.  Abandon English sentence structure if this
makes the comment clearer.  Don’t write more than one line.  Here’s an
example:

     typedef struct MVFFStruct {     /* MVFF pool outer structure */
       PoolStruct poolStruct;        /* generic structure */
       LocusPrefStruct locusPrefStruct; /* the preferences for allocation */
       Size extendBy;                /* size to extend pool by */
       Size avgSize;                 /* client estimate of allocation size */
       double spare;                 /* spare space fraction, see MVFFReduce */
       MFSStruct cbsBlockPoolStruct; /* stores blocks for CBSs */
       CBSStruct totalCBSStruct;     /* all memory allocated from the arena */
       CBSStruct freeCBSStruct;      /* free memory (primary) */
       FreelistStruct flStruct;      /* free memory (secondary, for emergencies) */
       FailoverStruct foStruct;      /* free memory (fail-over mechanism) */
       Bool firstFit;                /* as opposed to last fit */
       Bool slotHigh;                /* prefers high part of large block */
       Sig sig;                      /* <design/sig/> */
     } MVFFStruct;


File: MemoryPoolSystem.info,  Node: Macros<2>,  Prev: Comments,  Up: General formatting conventions

4.15.2.9 Macros
...............

*note .macro.careful;: 5e8. Macros in C are a real horror bag, be extra
careful.  There’s lots that could go here, but proper coverage probably
deserves a separate document.  Which isn’t written yet.

*note .macro.general;: 5e9. Do try and follow the other formatting
conventions for code in macro definitions.

*note .macro.backslash;: 5ea. Backslashes used for continuation lines in
macro definitions should be put on the right somewhere where they will
be less in the way.  Example:

     #define RAMP_RELATION(X)                       \
       X(RampOUTSIDE,        "outside ramp")        \
       X(RampBEGIN,          "begin ramp")          \
       X(RampRAMPING,        "ramping")             \
       X(RampFINISH,         "finish ramp")         \
       X(RampCOLLECTING,     "collecting ramp")


File: MemoryPoolSystem.info,  Node: C Style – naming,  Next: Review checklist,  Prev: C Style – formatting,  Up: Design

4.16 C Style – naming
=====================

* Menu:

* Introduction: Introduction<16>.
* Capitalization::
* Prefixes::
* Suffixes::


File: MemoryPoolSystem.info,  Node: Introduction<16>,  Next: Capitalization,  Up: C Style – naming

4.16.1 Introduction
-------------------

*note .scope;: 5f0. This document describes the conventions for naming
in C source code that’s internal in the MPS. See
design.mps.interface-c(1) for the corresponding conventions for the
public interface.

*note .readership;: 5f1. This document is intended for anyone working on
or with the C source code.

   ---------- Footnotes ----------

   (1) interface-c.html


File: MemoryPoolSystem.info,  Node: Capitalization,  Next: Prefixes,  Prev: Introduction<16>,  Up: C Style – naming

4.16.2 Capitalization
---------------------

*note .capital.macro;: 5f3. Statement-like macros have names consisting
of uppercase words separated by underscores, for example
‘ARG_DEFINE_KEY’.

*note .capital.constant;: 5f4. Constants have names consisting of a type
(named according to *note .capital.program: 5f5. or *note
.capital.other: 5f6.), concatenated with an identifier in uppercase with
underscores, for example ‘BufferFramePOP_PENDING’.

*note .capital.program;: 5f5. Other names with program scope consist of
concatenated title-case words, for example ‘BufferFramePush’.

*note .capital.other;: 5f6. Other names (including function parameters,
names with block scope, and names with file scope) consist of
concatenated words, the first of which is lowercase and the remainder
are uppercase.  For example, ‘poolReturn’.


File: MemoryPoolSystem.info,  Node: Prefixes,  Next: Suffixes,  Prev: Capitalization,  Up: C Style – naming

4.16.3 Prefixes
---------------

*note .prefix.program;: 5f8. Any name with program scope must start with
the name of the module to which it belongs.  For example, names
belonging to the buffer module must start with ‘buffer’ or ‘Buffer’ or
‘BUFFER’.  Justification: the C language lacks a namespace facility so
the only way to avoid name clashes is for each name to be globally
unique.

*note .prefix.file;: 5f9. Any name with file scope should start with the
name of the module to which it belongs.  Justification: makes it easy to
tell which module a function belongs to; makes it easy to set
breakpoints in the debugger.


File: MemoryPoolSystem.info,  Node: Suffixes,  Prev: Prefixes,  Up: C Style – naming

4.16.4 Suffixes
---------------

*note .suffix.struct;: 5fb. The type of a structure must be the same as
the structure tag, and must consist of the type of the pointer to the
structure concatenated with ‘Struct’.  For example, ‘ArenaStruct’.

*note .suffix.union;: 5fc. The type of a union must be the same as the
union tag, and must consist of the type of the pointer to the union
concatenated with ‘Union’.  For example, ‘PageUnion’.

*note .suffix.class;: 5fd. The type of a class (see
design.mps.protocol(1)) must end with ‘Class’.  For example,
‘ArenaClass’.

*note .suffix.method;: 5fe. The type of a method in a class must end
with ‘Method’.  For example, ‘PoolFixMethod’.

*note .suffix.visitor;: 5ff. The type of a visitor function must end
with ‘Visitor’.  For example, ‘TreeVisitor’.

*note .suffix.function;: 600. The type of other functions must end with
‘Function’.  For example, *note TreeKeyFunction: 601.

   ---------- Footnotes ----------

   (1) protocol.html


File: MemoryPoolSystem.info,  Node: Review checklist,  Next: C interface design,  Prev: C Style – naming,  Up: Design

4.17 Review checklist
=====================

* Menu:

* Introduction: Introduction<17>.
* Checklist::


File: MemoryPoolSystem.info,  Node: Introduction<17>,  Next: Checklist,  Up: Review checklist

4.17.1 Introduction
-------------------

*note .scope;: 607. This document contains a list of checks to apply
when reviewing code or other documents in the Memory Pool System.

*note .readership;: 608. This document is intended for reviewers.

*note .example;: 609. The “example” links are issues caused by a failure
to apply the checklist item.

*note .diff;: 60a. Some items in the checklist are particularly
susceptible to being ignored if one reviews only via the version control
diff.  These items refer to this tag.


File: MemoryPoolSystem.info,  Node: Checklist,  Prev: Introduction<17>,  Up: Review checklist

4.17.2 Checklist
----------------

*note .test;: 60c. If a new feature has been added to the code, is there
a test case?  Example: job003923(1).

*note .unwind;: 60d. If code has been updated in a function that unwinds
its state in failure cases, have the failure cases been updated to
correspond?  Example: job003922(2).  See *note .diff: 60a.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003923/

   (2) https://www.ravenbrook.com/project/mps/issue/job003922/


File: MemoryPoolSystem.info,  Node: C interface design,  Next: Keyword arguments in the MPS,  Prev: Review checklist,  Up: Design

4.18 C interface design
=======================

* Menu:

* Introduction: Introduction<18>.
* Analysis::
* Architecture: Architecture<2>.
* Naming conventions::
* Type conventions::
* Checking::
* Binary compatibility issues::
* Constraints::
* Implementation: Implementation<8>.
* Notes: Notes<2>.


File: MemoryPoolSystem.info,  Node: Introduction<18>,  Next: Analysis,  Up: C interface design

4.18.1 Introduction
-------------------

*note .scope;: 614. This document is the design for the Memory Pool
System (MPS) interface to the C Language, impl.h.mps.

*note .bg;: 615. See mail.richard.1996-07-24.10-57(1).

   ---------- Footnotes ----------

   (1) 
https://info.ravenbrook.com/project/mps/mail/1996/07/24/10-57/0.txt


File: MemoryPoolSystem.info,  Node: Analysis,  Next: Architecture<2>,  Prev: Introduction<18>,  Up: C interface design

4.18.2 Analysis
---------------

* Menu:

* Goals::
* Requirements: Requirements<10>.


File: MemoryPoolSystem.info,  Node: Goals,  Next: Requirements<10>,  Up: Analysis

4.18.2.1 Goals
..............

*note .goal.c;: 619. The file impl.h.mps is the C external interface to
the MPS. It is the default interface between client code written in C
and the MPS.

*note .goal.cpp;: 61a. impl.h.mps is not specifically designed to be an
interface to C++, but should be usable from C++.


File: MemoryPoolSystem.info,  Node: Requirements<10>,  Prev: Goals,  Up: Analysis

4.18.2.2 Requirements
.....................

*note .req;: 61c. The interface must provide an interface from client
code written in C to the functionality of the MPS required by the
product (see req.product), and Open Dylan (req.dylan).

*note .req.separation;: 61d. The external interface may not include
internal MPS header files (such as ‘pool.h’).

*note .req.flexibility;: 61e. It is essential that the interface cope
well with change, in order to avoid restricting possible future MPS
developments.  This means that the interface must be “open ended” in its
definitions.  This accounts for some of the apparently tortuous methods
of doing things (such as the keyword argument mechanism; see
design.mps.keyword-arguments(1)).  The requirement is that the MPS
should be able to add new functionality, or alter the implementation of
existing functionality, without affecting existing client code.  A
stronger requirement is that the MPS should be able to change without
'recompiling' client code.  This is not always possible.

*note .req.name.iso;: 61f. The interface shall not conflict in terms of
naming with any interfaces specified by ISO C and all reasonable future
versions.

*note .req.name.general;: 620. The interface shall use a documented and
reasonably small portion of the namespace so that clients can use the
MPS C interface in combination with other interfaces without name
conflicts.

   ---------- Footnotes ----------

   (1) keyword-arguments.html


File: MemoryPoolSystem.info,  Node: Architecture<2>,  Next: Naming conventions,  Prev: Analysis,  Up: C interface design

4.18.3 Architecture
-------------------

*note .fig.arch;: 622. The architecture of the MPS Interface

[missing figure]

Just behind ‘mps.h’ is the file ‘mpsi.c’, the “MPS interface layer”
which does the job of converting types and checking parameters before
calling through to the MPS proper, using internal MPS methods.


File: MemoryPoolSystem.info,  Node: Naming conventions,  Next: Type conventions,  Prev: Architecture<2>,  Up: C interface design

4.18.4 Naming conventions
-------------------------

*note .naming;: 624. The external interface names should adhere to the
documented interface conventions; these are found in the “Interface
conventions(1)” chapter of the Reference Manual.  They are
paraphrased/recreated here.

*note .naming.file;: 625. All files in the external interface have names
starting with ‘mps’.

*note .naming.unixy;: 626. The external interface does not follow the
same naming conventions as the internal code.  The interface is designed
to resemble a more conventional C, Unix, or Posix naming convention.

*note .naming.case;: 627. Identifiers are in lower case, except
non-function-like macros, which are in upper case.

*note .naming.global;: 628. All documented identifiers begin ‘mps_’ or
‘MPS_’.

*note .naming.all;: 629. All identifiers defined by the MPS begin ‘mps_’
or ‘MPS_’ or ‘_mps_’.

*note .naming.type;: 62a. Types are suffixed ‘_t’, except for structure
and union types.

*note .naming.struct;: 62b. Structure types and tags are suffixed ‘_s’.

*note .naming.union;: 62c. Unions types and tags are suffixed ‘_u’.

*note .naming.scope;: 62d. The naming conventions apply to all
identifiers (see ISO C §6.1.2); this includes names of functions,
variables, types (through typedef), structure and union tags,
enumeration members, structure and union members, macros, macro
parameters, labels.

*note .naming.scope.labels;: 62e. labels (for ‘goto’ statements) should
be rare, only in special block macros and probably not even then.

*note .naming.scope.other;: 62f. The naming convention would also extend
to enumeration types and parameters in functions prototypes but both of
those are prohibited from having names in an interface file.

   ---------- Footnotes ----------

   (1) ../../../topic/interface.html


File: MemoryPoolSystem.info,  Node: Type conventions,  Next: Checking,  Prev: Naming conventions,  Up: C interface design

4.18.5 Type conventions
-----------------------

*note .type.gen;: 631. The interface defines memory addresses as
‘void *’ and sizes as ‘size_t’ for compatibility with standard C (in
particular, with ‘malloc()’).  These types must be binary compatible
with the internal types *note Addr: 632. and *note Size: 40e.
respectively.  Note that this restricts the definitions of the internal
types *note Addr: 632. and *note Size: 40e. when the MPS is interfaced
with C, but does not restrict the MPS in general.

*note .type.opaque;: 633. Opaque types are defined as pointers to
structures which are never defined.  These types are cast to the
corresponding internal types in ‘mpsi.c’.

*note .type.trans;: 634. Some transparent structures are defined.  The
client is expected to read these, or poke about in them, under
documented restrictions.  The most important is the allocation point
structure (*note mps_ap_s: 1c1.) which is part of allocation buffers.
The transparent structures must be binary compatible with corresponding
internal structures.  For example, the fields of *note mps_ap_s: 1c1.
must correspond with ‘APStruct’ internally.  This is checked by ‘mpsi.c’
in ‘mps_check()’.

*note .type.pseudo;: 635. Some pseudo-opaque structures are defined.
These only exist so that code can be inlined using macros.  The client
code shouldn’t mess with them.  The most important case of this is the
scan state (‘mps_ss_s’) which is accessed by the in-line scanning
macros, ‘MPS_SCAN_*’ and ‘MPS_FIX*’.

*note .type.enum;: 636. There are no enumeration types in the interface.
Note that enum specifiers (to declare integer constants) are fine as
long as no type is declared.  See guide.impl.c.misc.enum.type.

*note .type.fun;: 637. Whenever function types or derived function types
(such as pointer to function) are declared a prototype should be used
and the parameters to the function should not be named.  This includes
the case where you are declaring the prototype for an interface
function.

*note .type.fun.example;: 638. So use:

     extern mps_res_t mps_alloc(mps_addr_t *, mps_pool_t, size_t, ...);

rather than:

     extern mps_res_t mps_alloc(mps_addr_t *addr_return, mps_pool_t pool , size_t size, ...);

and:

     typedef mps_addr_t (*mps_fmt_class_t)(mps_addr_t);

rather than:

     typedef mps_addr_t (*mps_fmt_class_t)(mps_addr_t object);

See guide.impl.c.misc.prototype.parameters.


File: MemoryPoolSystem.info,  Node: Checking,  Next: Binary compatibility issues,  Prev: Type conventions,  Up: C interface design

4.18.6 Checking
---------------

*note .check.testt;: 63a. Before any use of a parameter ‘foo’ belonging
to a pointer type ‘Foo’, it is checked using ‘TESTT(Foo, foo)’.  The
macro ‘TESTT()’ in impl.h.check performs simple thread-safe checking of
‘foo’, so it can be called outside of ‘ArenaEnter()’ and ‘ArenaLeave()’.

*note .check.avert;: 63b. With the arena lock held, ‘foo’ is checked
using ‘AVERT(Foo, foo)’.  This macro has different definitions depending
on how the MPS is compiled (see design.mps.config.def.var(1)).  It may
expand to ‘TESTT()’, or it may call the full checking function for the
type.

*note .check.types;: 63c. We use definitions of types in both our
external interface and our internal code, and we want to make sure that
they are compatible.  (The external interface changes less often and
hides more information.)  This checking uses the following macros,
originally from mail.richard.1996-08-07.09-49(2).

 -- C Macro: COMPATLVALUE (lvalue1, lvalue2)

*note .check.types.compat.lvalue;: 63e. This macro checks the assignment
compatibility of two lvalues.  It uses ‘sizeof’ to ensure that the
assignments have no effect.

     #define COMPATLVALUE(lv1, lv2) \
       ((void)sizeof((lv1) = (lv2)), (void)sizeof((lv2) = (lv1)), TRUE)

 -- C Macro: COMPATTYPE (type1, type2)

*note .check.types.compat.type;: 640. This macro checks that two types
are assignment-compatible and equal in size.  The hack here is that it
generates an lvalue for each type by casting zero to a pointer to the
type.  The use of ‘sizeof’ avoids the undefined behaviour that would
otherwise result from dereferencing a null pointer.

     #define COMPATTYPE(t1, t2) \
       (sizeof(t1) == sizeof(t2) && \
        COMPATLVALUE(*((t1 *)0), *((t2 *)0)))

 -- C Macro: COMPATFIELDAPPROX (structure1, field1, structure2, field2)

*note .check.types.compat.field.approx;: 642. This macro checks that the
offset and size of two fields in two structure types are the same.

     #define COMPATFIELDAPPROX(s1, f1, s2, f2) \
       (sizeof(((s1 *)0)->f1) == sizeof(((s2 *)0)->f2) && \
        offsetof(s1, f1) == offsetof(s2, f2))

 -- C Macro: COMPATFIELD (structure1, field1, structure2, field2)

*note .check.types.compat.field;: 644. This macro checks the offset,
size, and assignment-compatibility of two fields in two structure types.

     #define COMPATFIELD(s1, f1, s2, f2) \
       (COMPATFIELDAPPROX(s1, f1, s2, f2) && \
        COMPATLVALUE(((s1 *)0)->f1, ((s2 *)0)->f2))

   ---------- Footnotes ----------

   (1) config.html#design.mps.config.def.var

   (2) 
https://info.ravenbrook.com/project/mps/mail/1996/08/07/09-49/0.txt


File: MemoryPoolSystem.info,  Node: Binary compatibility issues,  Next: Constraints,  Prev: Checking,  Up: C interface design

4.18.7 Binary compatibility issues
----------------------------------

As in, “Enumeration types are not allowed” (see
mail.richard.1995-09-08.09-28(1)).

*note .compat;: 646. There are two main aspects to run-time
compatibility: binary interface and protocol.

*note .compat.binary;: 647. The binary interface is all the information
needed to correctly use the library, and includes external symbol
linkage, calling conventions, type representation compatibility,
structure layouts, etc.

*note .compat.binary.unneeded;: 648. Binary compatibility is not
required by the open source MPS: we expect (and indeed, recommend) that
a client program is compiled against the MPS sources.  Nonetheless we
try to maintain binary compatibility in case the capability is required
in future.

*note .compat.binary.dependencies;: 649. The binary interface is
determined completely by the header file and the target.  The header
file specifies the external names and the types, and the target platform
specifies calling conventions and type representation.  There is
therefore a many-to-one mapping between the header file version and the
binary interface.

*note .compat.protocol;: 64a. The protocol is how the library is
actually used by the client code – whether this is called before that –
and determines the semantic correctness of the client with respect to
the library.

*note .compat.protocol.dependencies;: 64b. The protocol is determined by
the implementation of the library.

   ---------- Footnotes ----------

   (1) 
https://info.ravenbrook.com/project/mps/mail/1995/09/08/09-28/0.txt


File: MemoryPoolSystem.info,  Node: Constraints,  Next: Implementation<8>,  Prev: Binary compatibility issues,  Up: C interface design

4.18.8 Constraints
------------------

*note .cons;: 64d. The MPS C Interface constrains the MPS in order to
provide useful memory management services to a C or C++ program.

*note .cons.addr;: 64e. The interface constrains the MPS address type,
Addr (design.mps.type.addr(1)), to being the same as C’s generic pointer
type, ‘void *’, so that the MPS can manage C objects in the natural way.

*note .pun.addr;: 64f. We pun the type of *note mps_addr_t: 11d. (which
is ‘void *’) into *note Addr: 632. (an incomplete type, see
design.mps.type.addr(2)).  This happens in the call to the scan state’s
fix function, for example.

*note .cons.size;: 650. The interface constrains the MPS size type,
*note Size: 40e. (design.mps.type.size(3)), to being the same as C’s
size type, ‘size_t’, so that the MPS can manage C objects in the natural
way.

*note .pun.size;: 651. We pun the type of ‘size_t’ in mps.h into *note
Size: 40e. in the MPM, as an argument to the format methods.  We assume
this works.

*note .cons.word;: 652. The MPS assumes that *note Word: 653.
(design.mps.type.word(4)) and *note Addr: 632. (design.mps.type.addr(5))
are the same size, and the interface constrains *note Word: 653. to
being the same size as C’s generic pointer type, ‘void *’.

   ---------- Footnotes ----------

   (1) type.html#design.mps.type.addr

   (2) type.html#design.mps.type.addr

   (3) type.html#design.mps.type.size

   (4) type.html#design.mps.type.word

   (5) type.html#design.mps.type.addr


File: MemoryPoolSystem.info,  Node: Implementation<8>,  Next: Notes<2>,  Prev: Constraints,  Up: C interface design

4.18.9 Implementation
---------------------

*note .impl;: 656. The external interface consists of the following
header files:

*note .impl.mps;: 657. ‘mps.h’ is the main external interface,
containing of type and function declarations needed by all clients of
the MPS.

*note .impl.mpstd;: 658. ‘mpstd.h’ is the MPS target detection header.
It decodes preprocessor symbols which are predefined by build
environments in order to determine the target platform (see
design.mps.config(1)), and then defines uniform symbols, such as *note
MPS_ARCH_I3: 2e5, for use externally and internally by the MPS.
‘mpstd.h’ is not included by any of the other external headers, as it
relies on exact set of preprocessor constants defined by compilers.

*note .impl.mpsio;: 659. ‘mpsio.h’ is the interface to the MPS I/O
subsystem, part of the plinth.  See design.mps.io(2).

*note .impl.mpslib;: 65a. ‘mpslib.h’ is the interface to the MPS Library
Interface, part of the plinth.  See design.mps.lib(3).

*note .impl.mpsa;: 65b. Interfaces to arena classes are in files with
names starting ‘mpsa’: for example, the interface to the Virtual Memory
arena class is in ‘mpsavm.h’.

*note .impl.mpsc;: 65c. Interfaces to pool classes are in files with
names starting ‘mpsc’: for example, the interface to the MVFF pool class
is in ‘mpscmvff.h’.

   ---------- Footnotes ----------

   (1) config.html

   (2) io.html

   (3) lib.html


File: MemoryPoolSystem.info,  Node: Notes<2>,  Prev: Implementation<8>,  Up: C interface design

4.18.10 Notes
-------------

*note .fmt.extend;: 65e. ‘mps_fmt_A_t’ is so called because new pool
classes might require new format methods, but these methods cannot be
added to the format structure without breaking binary compatibility.
Therefore these new pool classes would use new format structures named
‘mps_fmt_B_t’ and so on.

*note .thread-safety;: 65f. Most calls through this interface lock the
arena and therefore make the MPM single-threaded.  In order to do this
they must recover the arena from their parameters.  Methods such as
‘FormatArena()’ and *note ThreadArena(): 660. must therefore be callable
when the arena is 'not' locked.  These methods are tagged with the tag
of this note.

*note .lock-free;: 661. Certain functions inside the MPM are thread-safe
and do not need to be serialized by using locks.  They are marked with
the tag of this note.

*note .form;: 662. Almost all functions in this implementation simply
cast their arguments to the equivalent internal types, and cast results
back to the external type, where necessary.  Only exceptions are noted
in comments.


File: MemoryPoolSystem.info,  Node: Keyword arguments in the MPS,  Next: Lands,  Prev: C interface design,  Up: Design

4.19 Keyword arguments in the MPS
=================================

* Menu:

* Introduction: Introduction<19>.
* Overview: Overview<4>.
* Internals::
* The varargs legacy::
* References: References<6>.


File: MemoryPoolSystem.info,  Node: Introduction<19>,  Next: Overview<4>,  Up: Keyword arguments in the MPS

4.19.1 Introduction
-------------------

Up to version 1.111, the Memory Pool System(1) used varags to pass
arguments to arena and pool classes, because the general MPS interface
can’t specify what arguments those classes might need in C prototypes.
This mechanism was error-prone and did not allow for any optional
arguments, meaning that the client had to specify or predict esoteric
tuning parameters.

Starting with version 1.112, the MPS uses an idiom for keyword
arguments.

The keyword argument design was originally proposed in *note
[RB_2012-05-24]: 667.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/


File: MemoryPoolSystem.info,  Node: Overview<4>,  Next: Internals,  Prev: Introduction<19>,  Up: Keyword arguments in the MPS

4.19.2 Overview
---------------

The basic design is not specific to the MPS. The keyword argument list
is passed as an array of argument structures which look like this:

     typedef struct mps_key_s *mps_key_t;
     typedef struct mps_arg_s {
       mps_key_t key;
       union {
         int i;
         char c;
         void *p;
         size_t size;
         /* etc. */
       } val;
     } mps_arg_s;

The argument list is assembled and passed like this:

     mps_arg_s args[3];
     args[0].key = MPS_KEY_MIN_SIZE;
     args[0].val.size = 32;
     args[1].key = MPS_KEY_MAX_SIZE;
     args[1].val.size = 1024;
     args[2].key = MPS_KEY_ARGS_END;
     mps_pool_create_k(&pool, some_pool_class(), args);

This can be written quite concisely in C99:

     mps_pool_create_k(&pool, some_pool_class(),
             (mps_arg_s []){{MPS_KEY_MIN_SIZE, {.size = 32}},
                            {MPS_KEY_MAX_SIZE, {.size = 1024}},
                            {MPS_KEY_ARGS_END}});

The arguments that are recognised and used by the function are removed
from the array (and the subsequent arguments moved up) so that if they
are all consumed the array has ‘MPS_KEY_ARGS_END’ in slot zero on
return.  This can be checked by the caller.

   - It’s not a static error to pass excess arguments.  This makes it
     easy to substitute one pool or arena class for another (which might
     ignore some arguments).  The caller can check that ‘args[0].key’ is
     ‘MPS_KEY_ARGS_END’ if desired.

   - NULL is not a valid argument list.  This is in line with general
     MPS design principles to avoid accidental omissions.  For
     convenience, we provide ‘mps_args_none’ as a static empty argument
     list.

   - NULL is not a valid argument key.  This is in line with general MPS
     design principles to avoid accidental omissions.  Every key points
     to a structure with a signature that can be checked.  This makes it
     virtually impossible to get an argument list with bad keys or that
     is unterminated past MPS checking.


File: MemoryPoolSystem.info,  Node: Internals,  Next: The varargs legacy,  Prev: Overview<4>,  Up: Keyword arguments in the MPS

4.19.3 Internals
----------------

Internally, keys are static constant structures which are signed and
contain a checking method for the argument, like this:

     typedef struct mps_arg_s *Arg;
     typedef struct mps_key_s {
       Sig sig;              /* Always KeySig */
       const char *name;
       Bool check(Arg arg);
     } KeyStruct;

They are mostly declared in the modules that consume them, except for a
few common keys.  Declarations look like:

     const KeyStruct _mps_key_extend_by = {KeySig, "extend_by", ArgCheckSize};

but ‘arg.h’ provides a macro for this:

     ARG_DEFINE_KEY(extend_by, Size);

We define keys as static structures (rather than, say, an enum) because:

   - The set of keys can be extended indefinitely.

   - The set of keys can be extended by independently linked modules.

   - The structure contents allow strong checking of argument lists.

In the MPS C Interface, we declare keys like this:

     extern const struct mps_key_s _mps_key_extend_by;
     #define MPS_KEY_EXTEND_BY (&_mps_key_extend_by)

The underscore on the symbol requests that client code doesn’t reference
it, but instead uses the macro.  This gives us adaptability to change
the design and replace keys with, say, magic numbers.


File: MemoryPoolSystem.info,  Node: The varargs legacy,  Next: References<6>,  Prev: Internals,  Up: Keyword arguments in the MPS

4.19.4 The varargs legacy
-------------------------

For backward compatibility, varargs to arena and pool creation are
converted into keyword arguments by position, using a method in the
arena or pool class.  For example:

     static void MVVarargs(ArgStruct args[], va_list varargs)
     {
       args[0].key = MPS_KEY_EXTEND_BY;
       args[0].val.size = va_arg(varargs, Size);
       args[1].key = MPS_KEY_MEAN_SIZE;
       args[1].val.size = va_arg(varargs, Size);
       args[2].key = MPS_KEY_MAX_SIZE;
       args[2].val.size = va_arg(varargs, Size);
       args[3].key = MPS_KEY_ARGS_END;
       AVER(ArgListCheck(args));
     }

This leaves the main body of code, and any future code, free to just
handle keyword arguments only.

Varargs methods must be thread-safe as they are called without taking
the arena lock.

The use of varargs is deprecated in the manual and the interface and
these methods can be deleted at some point in the future.


File: MemoryPoolSystem.info,  Node: References<6>,  Prev: The varargs legacy,  Up: Keyword arguments in the MPS

4.19.5 References
-----------------

(RB_2012-05-24) Richard Brooksby.  Ravenbrook Limited.  2012-05-24.
“Keyword and optional arguments(1)”.

   ---------- Footnotes ----------

   (1) https://info.ravenbrook.com/mail/2012/05/24/21-19-15/0/


File: MemoryPoolSystem.info,  Node: Lands,  Next: Lock module,  Prev: Keyword arguments in the MPS,  Up: Design

4.20 Lands
==========

* Menu:

* Introduction: Introduction<20>.
* Definitions: Definitions<2>.
* Requirements: Requirements<11>.
* Interface: Interface<8>.
* Implementations::
* Testing: Testing<3>.


File: MemoryPoolSystem.info,  Node: Introduction<20>,  Next: Definitions<2>,  Up: Lands

4.20.1 Introduction
-------------------

*note .intro;: 671. This is the design of the 'land' abstract data type,
which represents a collection of contiguous address ranges.

*note .readership;: 672. This document is intended for any MPS
developer.

*note .source;: 673. design.mps.cbs(1), design.mps.freelist(2).

*note .overview;: 674. Collections of address ranges are used in several
places in the MPS: the arena stores a set of mapped address ranges;
pools store sets of address ranges which have been acquired from the
arena and sets of address ranges that are available for allocation.  The
'land' abstract data type makes it easy to try out different
implementations with different performance characteristics and other
attributes.

*note .name;: 675. The name is inspired by 'rangeland' meaning 'group of
ranges' (where 'ranges' is used in the sense 'grazing areas').

   ---------- Footnotes ----------

   (1) cbs.html

   (2) freelist.html


File: MemoryPoolSystem.info,  Node: Definitions<2>,  Next: Requirements<11>,  Prev: Introduction<20>,  Up: Lands

4.20.2 Definitions
------------------

*note .def.range;: 677. A (contiguous) 'range' of addresses is a
semi-open interval on address space.

*note .def.isolated;: 678. A contiguous range is 'isolated' with respect
to some property it has, if adjacent elements do not have that property.


File: MemoryPoolSystem.info,  Node: Requirements<11>,  Next: Interface<8>,  Prev: Definitions<2>,  Up: Lands

4.20.3 Requirements
-------------------

*note .req.set;: 67a. Must maintain a set of addresses.

*note .req.add;: 67b. Must be able to add address ranges to the set.

*note .req.remove;: 67c. Must be able to remove address ranges from the
set.

*note .req.size;: 67d. Must report concisely to the client when isolated
contiguous ranges of at least a certain size appear and disappear.

*note .req.iterate;: 67e. Must support the iteration of all isolated
contiguous ranges.

*note .req.protocol;: 67f. Must detect protocol violations.

*note .req.debug;: 680. Must support debugging of client code.

*note .req.align;: 681. Must support an alignment (the alignment of all
addresses specifying ranges) of down to ‘sizeof(void *)’ without losing
memory.


File: MemoryPoolSystem.info,  Node: Interface<8>,  Next: Implementations,  Prev: Requirements<11>,  Up: Lands

4.20.4 Interface
----------------

* Menu:

* Types: Types<5>.
* Generic functions::


File: MemoryPoolSystem.info,  Node: Types<5>,  Next: Generic functions,  Up: Interface<8>

4.20.4.1 Types
..............

 -- C Type: typedef LandStruct *Land

*note .type.land;: 684. The type of a generic land instance.

 -- C Type: typedef *note Bool: 3a9. (*LandVisitor)(*note Land: 53c.
          land, *note Range: 686. range, void *closure)

*note .type.visitor;: 687. Type ‘LandVisitor’ is a callback function
that may be passed to *note LandIterate(): 688.  It is called for every
isolated contiguous range in address order.  The function must return a
*note Bool: 3a9. indicating whether to continue with the iteration.

 -- C Type: typedef *note Bool: 3a9. (*LandDeleteVisitor)(*note Bool:
          3a9. *deleteReturn, *note Land: 53c. land, *note Range: 686.
          range, void *closure)

*note .type.deletevisitor;: 68a. Type ‘LandDeleteVisitor’ is a callback
function that may be passed to *note LandIterateAndDelete(): 413.  It is
called for every isolated contiguous range in address order.  The
function must return a *note Bool: 3a9. indicating whether to continue
with the iteration.  It may additionally update ‘*deleteReturn’ to
‘TRUE’ if the range must be deleted from the land, or ‘FALSE’ if the
range must be kept.  (The default is to keep the range.)


File: MemoryPoolSystem.info,  Node: Generic functions,  Prev: Types<5>,  Up: Interface<8>

4.20.4.2 Generic functions
..........................

 -- C Function: *note Res: 55f. LandInit (Land land, LandClass class,
          Arena arena, Align alignment, void *owner, ArgList args)

*note .function.init;: 68c. *note LandInit(): 406. initializes the land
structure for the given class.  The land will perform allocation (if
necessary – not all land classes need to allocate) in the supplied
arena.  The ‘alignment’ parameter is the alignment of the address ranges
that will be stored and retrieved from the land.  The parameter ‘owner’
is output as a parameter to the ‘LandInit’ event.  The newly initialized
land contains no ranges.

 -- C Function: *note Res: 55f. LandCreate (Land *landReturn, Arena
          arena, LandClass class, Align alignment, void *owner, ArgList
          args)

*note .function.create;: 68e. *note LandCreate(): 68d. allocates memory
for a land structure of the given class in ‘arena’, and then passes all
parameters to *note LandInit(): 406.

 -- C Function: void LandFinish (Land land)

*note .function.finish;: 690. *note LandFinish(): 68f. finishes the land
structure and discards any other resources associated with the land.

 -- C Function: void LandSize (Land land)

*note .function.size;: 692. *note LandSize(): 691. returns the total
size of the ranges stored in the land.

 -- C Function: *note Res: 55f. LandInsert (Range rangeReturn, Land
          land, Range range)

*note .function.insert;: 693. If any part of ‘range’ is already in the
land, then leave the land unchanged and return ‘ResFAIL’.  Otherwise,
attempt to insert ‘range’ into the land.  If the insertion succeeds,
then update ‘rangeReturn’ to describe the contiguous isolated range
containing the inserted range (this may differ from ‘range’ if there was
coalescence on either side) and return ‘ResOK’.  If the insertion fails,
return a result code indicating allocation failure.

*note .function.insert.fail;: 694. Insertion of a valid range (that is,
one that does not overlap with any range in the land) can only fail if
the new range is isolated and the allocation of the necessary data
structure to represent it failed.

*note .function.insert.alias;: 695. It is acceptable for ‘rangeReturn’
and ‘range’ to share storage.

 -- C Function: *note Res: 55f. LandInsertSteal (Range rangeReturn, Land
          land, Range rangeIO)

*note .function.insert-steal;: 697. If any part of ‘rangeIO’ is already
in the land, then leave the land unchanged and return ‘ResFAIL’.
Otherwise, insert ‘rangeIO’ into the land, update ‘rangeReturn’ to
describe the contiguous isolated range containing the inserted range
(this may differ from ‘range’ if there was coalescence on either side),
and return ‘ResOK’.

*note .function.insert-steal.steal;: 698. If insertion requires
allocation for the land’s internal data structures, steal some of the
memory in ‘rangeIO’, use it to satisfy the allocation, update ‘rangeIO’
so that it describes the remaining part of of the range, and insert the
remainder into the land as described above.

*note .function.insert-steal.allocated;: 699. In order for stealing to
work, the inserted range must be allocated from the arena to some pool
or pools.

*note .function.insert-steal.empty;: 69a. After stealing memory,
‘rangeIO’ might be empty, in which case ‘rangeReturn’ will be a copy of
‘rangeIO’.

*note .function.insert-steal.alias.not;: 69b. It is not acceptable for
‘rangeReturn’ and ‘rangeIO’ to share storage.

 -- C Function: *note Res: 55f. LandDelete (Range rangeReturn, Land
          land, Range range)

*note .function.delete;: 69c. If any part of the range is not in the
land, then leave the land unchanged and return ‘ResFAIL’.  Otherwise,
update ‘rangeReturn’ to describe the contiguous isolated range that
contains ‘range’ (this may differ from ‘range’ if there are fragments on
either side) and attempt to delete the range from the land.  If the
deletion succeeds, return ‘ResOK’.  If the deletion fails, return a
result code indicating allocation failure.

*note .function.delete.fail;: 69d. Deletion of a valid range (that is,
one that is wholly contained in the land) can only fail if there are
fragments on both sides and the allocation of the necessary data
structures to represent them fails.

*note .function.delete.return;: 69e. *note LandDelete(): 421. returns
the contiguous isolated range that contains ‘range’ even if the deletion
fails.  This is so that the caller can try deleting the whole block
(which is guaranteed to succeed) and managing the fragments using a
fallback strategy.

*note .function.delete.alias;: 69f. It is acceptable for ‘rangeReturn’
and ‘range’ to share storage.

 -- C Function: *note Res: 55f. LandDeleteSteal (Range rangeReturn, Land
          land, Range range)

*note .function.delete-steal;: 6a1. If any part of the range is not in
the land, then leave the land unchanged and return ‘ResFAIL’.
Otherwise, update ‘rangeReturn’ to describe the contiguous isolated
range that contains ‘range’ (this may differ from ‘range’ if there are
fragments on either side), delete the range from the land, and return
‘ResOK’.

*note .function.delete-steal.steal;: 6a2. If deletion requires
allocation for the land’s internal data structures, steal some of the
memory in the contiguous isolated range that contains ‘range’, and use
it to satisfy the allocation.

*note .function.delete-steal.allocated;: 6a3. In order for stealing to
work, the addresses stored in the land must be allocated from the arena
to some pool or pools.

*note .function.delete-steal.alias;: 6a4. It is acceptable for
‘rangeReturn’ and ‘range’ to share storage.

 -- C Function: *note Bool: 3a9. LandIterate (Land land, LandVisitor
          visitor, void *closure)

*note .function.iterate;: 6a5. *note LandIterate(): 688. is the function
used to iterate all isolated contiguous ranges in a land.  It receives a
visitor function to invoke on every range, and a closure pointer to pass
on to the visitor function.  If the visitor function returns ‘FALSE’,
then iteration is terminated and *note LandIterate(): 688. returns
‘FALSE’.  If all iterator method calls return ‘TRUE’, then *note
LandIterate(): 688. returns ‘TRUE’

 -- C Function: *note Bool: 3a9. LandIterateAndDelete (Land land,
          LandDeleteVisitor visitor, void *closure)

*note .function.iterate.and.delete;: 6a6. As *note LandIterate(): 688,
but the visitor function additionally returns a Boolean indicating
whether the range should be deleted from the land.

*note .function.iterate.and.delete.justify;: 6a7. The reason for having
both *note LandIterate(): 688. and *note LandIterateAndDelete(): 413. is
that it may be possible to use a more efficient algorithm, or to
preserve more properties of the data structure, when it is known that
the land will not be modified during the iteration.  For example, in the
CBS implementation, *note LandIterate(): 688. uses ‘TreeTraverse()’
which preserves the tree structure, whereas *note
LandIterateAndDelete(): 413. uses ‘TreeTraverseAndDelete()’ which
flattens the tree structure, losing information about recently accessed
nodes.

 -- C Function: *note Bool: 3a9. LandFindFirst (Range rangeReturn, Range
          oldRangeReturn, Land land, Size size, FindDelete findDelete)

*note .function.find.first;: 6a8. Locate the first block (in address
order) within the land of at least the specified size, update
‘rangeReturn’ to describe that range, and return ‘TRUE’.  If there is no
such block, it returns ‘FALSE’.

In addition, optionally delete the top, bottom, or all of the found
range, depending on the ‘findDelete’ argument.  This saves a separate
call to *note LandDelete(): 421, and uses the knowledge of exactly where
we found the range.  The value of ‘findDelete’ must come from this
enumeration:

     enum {
         FindDeleteNONE,    /* don't delete after finding */
         FindDeleteLOW,     /* delete size bytes from low end of block */
         FindDeleteHIGH,    /* delete size bytes from high end of block */
         FindDeleteENTIRE   /* delete entire range */
     };

The original contiguous isolated range in which the range was found is
returned via the ‘oldRangeReturn’ argument.  (If ‘findDelete’ is
‘FindDeleteNONE’ or ‘FindDeleteENTIRE’, then this will be identical to
the range returned via the ‘rangeReturn’ argument.)

 -- C Function: *note Bool: 3a9. LandFindLast (Range rangeReturn, Range
          oldRangeReturn, Land land, Size size, FindDelete findDelete)

*note .function.find.last;: 6a9. Like *note LandFindFirst(): 408, except
that it finds the last block in address order.

 -- C Function: *note Bool: 3a9. LandFindLargest (Range rangeReturn,
          Range oldRangeReturn, Land land, Size size, FindDelete
          findDelete)

*note .function.find.largest;: 6aa. Locate the largest block within the
land, and if that block is at least as big as ‘size’, return its range
via the ‘rangeReturn’ argument, and return ‘TRUE’.  If there are no
blocks in the land at least as large as ‘size’, return ‘FALSE’.  Pass 0
for ‘size’ if you want the largest block unconditionally.

Like *note LandFindFirst(): 408, optionally delete the range (specifying
‘FindDeleteLOW’ or ‘FindDeleteHIGH’ has the same effect as
‘FindDeleteENTIRE’), and return the original contiguous isolated range
in which the range was found via the ‘oldRangeReturn’ argument.

 -- C Function: *note Res: 55f. LandFindInZones (Bool *foundReturn,
          Range rangeReturn, Range oldRangeReturn, Land land, Size size,
          ZoneSet zoneSet, Bool high)

*note .function.find.zones;: 6ab. Locate a block at least as big as
‘size’ that lies entirely within the ‘zoneSet’, return its range via the
‘rangeReturn’ argument, set ‘*foundReturn’ to ‘TRUE’, and return
‘ResOK’.  (The first such block, if ‘high’ is ‘FALSE’, or the last, if
‘high’ is ‘TRUE’.)  If there is no such block, set ‘*foundReturn’ to
‘FALSE’, and return ‘ResOK’.

Delete the range as for *note LandFindFirst(): 408. and ‘LastFindLast()’
(with the effect of ‘FindDeleteLOW’ if ‘high’ is ‘FALSE’ and the effect
of ‘FindDeleteHIGH’ if ‘high’ is ‘TRUE’), and return the original
contiguous isolated range in which the range was found via the
‘oldRangeReturn’ argument.

*note .function.find.zones.fail;: 6ac. It’s possible that the range
can’t be deleted from the land because that would require allocation, in
which case the result code indicates the cause of the failure.

 -- C Function: *note Res: 55f. LandDescribe (Land land, mps_lib_FILE
          *stream)

*note .function.describe;: 6ae. *note LandDescribe(): 6ad. prints a
textual representation of the land to the given stream.  It is provided
for debugging purposes only.

 -- C Function: void LandFlush (Land dest, Land src)

*note .function.flush;: 6af. Delete ranges of addresses from ‘src’ and
insert them into ‘dest’, so long as *note LandInsert(): 420. remains
successful.


File: MemoryPoolSystem.info,  Node: Implementations,  Next: Testing<3>,  Prev: Interface<8>,  Up: Lands

4.20.5 Implementations
----------------------

There are three land implementations:

  1. CBS (Coalescing Block Structure) stores ranges in a splay tree.  It
     has fast (logarithmic in the number of ranges) insertion, deletion
     and searching, but has substantial space overhead.  See
     design.mps.cbs(1).

  2. Freelist stores ranges in an address-ordered free list, as in
     traditional ‘malloc()’ implementations.  Insertion, deletion, and
     searching are slow (proportional to the number of ranges) but it
     does not need to allocate.  See design.mps.freelist(2).

  3. Failover combines two lands, using one (the 'primary') until it
     fails, and then falls back to the other (the 'secondary').  See
     design.mps.failover(3).

   ---------- Footnotes ----------

   (1) cbs.html

   (2) freelist.html

   (3) failover.html


File: MemoryPoolSystem.info,  Node: Testing<3>,  Prev: Implementations,  Up: Lands

4.20.6 Testing
--------------

*note .test;: 6b3. There is a stress test for implementations of this
interface in impl.c.landtest.  This allocates a large block of memory
and then simulates the allocation and deallocation of ranges within this
block using both a *note Land: 53c. and a *note BT: 6b4.  It makes both
valid and invalid requests, and compares the *note Land: 53c. response
to the correct behaviour as determined by the *note BT: 6b4.  It
iterates the ranges in the *note Land: 53c, comparing them to the *note
BT: 6b4.  It invokes the *note LandDescribe(): 6ad. generic function,
but makes no automatic test of the resulting output.


File: MemoryPoolSystem.info,  Node: Lock module,  Next: Client message protocol,  Prev: Lands,  Up: Design

4.21 Lock module
================

* Menu:

* Introduction: Introduction<21>.
* Background::
* Requirements: Requirements<12>.
* Interface: Interface<9>.
* Implementation: Implementation<9>.
* Example: Example<2>.
* References: References<7>.


File: MemoryPoolSystem.info,  Node: Introduction<21>,  Next: Background,  Up: Lock module

4.21.1 Introduction
-------------------

*note .intro;: 6b9. This is the design of the lock module.

*note .readership;: 6ba. Any MPS developer; anyone porting the MPS to a
new platform.


File: MemoryPoolSystem.info,  Node: Background,  Next: Requirements<12>,  Prev: Introduction<21>,  Up: Lock module

4.21.2 Background
-----------------

*note .need;: 6bc. In an environment where multiple threads are
accessing shared data, threads need to cooperate to maintain
consistency.  Locks provide a simple mechanism for doing this.

*note .ownership;: 6bd. A lock is an object which may be “owned” by a
single thread at a time.  By claiming ownership of a lock before
executing some piece of code, a thread can guarantee that no other
thread owns the lock during execution of that code.  If some other
thread holds a claim on a lock, the thread trying to claim the lock will
suspend until the lock is released by the owning thread.

*note .data;: 6be. A simple way of using this behaviour is to associate
a lock with a shared data structure.  By claiming that lock around
accesses to the data, a consistent view of the structure can be seen by
the accessing thread.  More generally any set of operations which are
required to be mutually exclusive may be performed so by using locks.


File: MemoryPoolSystem.info,  Node: Requirements<12>,  Next: Interface<9>,  Prev: Background,  Up: Lock module

4.21.3 Requirements
-------------------

*note .req.thread-safety;: 6c0. Support the locking needs of
design.mps.thread-safety(1).

*note .req.binary;: 6c1. Provide 'binary' locks: that is, locks that can
be claimed, and until released, other attempts to claim them block.
(This is needed to implement the arena lock.)

*note .req.recursive;: 6c2. Provide 'recursive' locks: that is, locks
that can be claimed again by the thread currently holding them, without
blocking or deadlocking.  (This is needed to implement the global
recursive lock.)

*note .req.held;: 6c3. Provide a means to test if a lock is held.  (This
is needed for debugging a dynamic function table callback on Windows on
x86-64.  See *note mps_arena_busy(): 1a7. for a detailed description of
this use case.  Note that in this use case the program is running
single-threaded and so there is no need for this feature to be
thread-safe.)

*note .req.global;: 6c4. Provide 'global' locks: that is locks that need
not be allocated or initialized by the user.

*note .req.global.binary;: 6c5. Provide a global binary lock.  (This is
required to protect the data structure allowing multiple arenas to
coordinate handling of protection faults: see
design.mps.thread-safety.sol.global.mutable(2).)

*note .req.global.recursive;: 6c6. Provide a global recursive lock.
(This is required to protect protocol class initialization: see
design.mps.thread-safety.sol.global.once(3).)

*note .req.deadlock.not;: 6c7. There is no requirement to provide
protection against deadlock.  (Clients are able to avoid deadlock using
traditional strategies such as ordering of locks; see
design.mps.thread-safety.sol.deadlock(4).)

   ---------- Footnotes ----------

   (1) thread-safety.html

   (2) thread-safety.html#design.mps.thread-safety.sol.global.mutable

   (3) thread-safety.html#design.mps.thread-safety.sol.global.once

   (4) thread-safety.html#design.mps.thread-safety.sol.deadlock


File: MemoryPoolSystem.info,  Node: Interface<9>,  Next: Implementation<9>,  Prev: Requirements<12>,  Up: Lock module

4.21.4 Interface
----------------

 -- C Type: typedef LockStruct *Lock

An opaque type representing a lock.  Clients that needs to allocate
space for a lock should dynamically allocate space for the structure,
calling *note LockSize(): 6cb. to determine the size.

 -- C Function: size_t LockSize (void)

Return the size of a ‘LockStruct’ for allocation purposes.

 -- C Function: void LockInit (Lock lock)

Initialize the lock.  This must be called before any use of the lock.
After initialization, the lock is not owned by any thread.

 -- C Function: void LockFinish (Lock lock)

Finish the lock.  The lock must not be owned by any thread.

 -- C Function: void LockClaim (Lock lock)

Wait, if necessary, until the lock is not owned by any thread.  Then
claim ownership of the lock by the current thread.

 -- C Function: void LockRelease (Lock lock)

Releases ownership of a lock that is currently owned.

 -- C Function: void LockClaimRecursive (Lock lock)

Remembers the previous state of the lock with respect to the current
thread and claims the lock (if not already held).

 -- C Function: void LockReleaseRecursive (Lock lock)

Restores the previous state of the lock remembered by the corresponding
*note LockClaimRecursive(): 6d0. call.

 -- C Function: *note Bool: 3a9. LockIsHeld (Lock lock)

Return true if the lock is held by any thread, false otherwise.  Note
that this function need not be thread-safe (see *note .req.held: 6c3.).

 -- C Function: void LockInitGlobal (void)

Initialize (or re-initialize) the global locks.  This should only be
called in the following circumstances: the first time either of the
global locks is claimed; and in the child process after a ‘fork()’.  See
design.mps.thread-safety.sol.fork.lock(1).

 -- C Function: void LockClaimGlobal (void)

Claims ownership of the binary global lock which was previously not held
by current thread.

 -- C Function: void LockReleaseGlobal (void)

Releases ownership of the binary global lock that is currently owned.

 -- C Function: void LockClaimGlobalRecursive (void)

Remembers the previous state of the recursive global lock with respect
to the current thread and claims the lock (if not already held).

 -- C Function: void LockReleaseGlobalRecursive (void)

Restores the previous state of the recursive global lock remembered by
the corresponding *note LockClaimGlobalRecursive(): 6d6. call.

 -- C Function: void LockSetup (void)

One-time initialization function, intended for calling
‘pthread_atfork()’ on the appropriate platforms: see
design.mps.thread-safety.sol.fork.lock(2).

   ---------- Footnotes ----------

   (1) thread-safety.html#design.mps.thread-safety.sol.fork.lock

   (2) thread-safety.html#design.mps.thread-safety.sol.fork.lock


File: MemoryPoolSystem.info,  Node: Implementation<9>,  Next: Example<2>,  Prev: Interface<9>,  Up: Lock module

4.21.5 Implementation
---------------------

*note .impl.recursive;: 6da. For recursive claims, the list of previous
states can be implemented by keeping a count of the number of claims
made by the current thread so far.  In the multi-threaded
implementations this is handled by the operating system interface, but a
count is still kept and used to check correctness.

*note .impl.recursive.limit;: 6db. The implementation imposes a limit on
the number of recursive claims (see issue.lock-claim-limit(1)).  On
Windows, the critical section object contains the field ‘LONG
RecursionCount’.  In typical POSIX Threads implementations,
‘pthread_mutex_t’ uses an ‘int’ for the count of recursive claims.

*note .impl.global;: 6dc. The binary and recursive global locks are
typically implemented using the same mechanism as normal locks.  (But an
operating system-specific mechanism is used, if possible, to ensure that
the global locks are initialized just once.)

*note .impl.an;: 6dd. Single-threaded generic implementation ‘lockan.c’:

   - single-threaded;

   - no need for locking;

   - locking structure contains count;

   - provides checking in debug version;

   - otherwise does nothing except keep count of claims.

*note .impl.w3;: 6de. Windows implementation ‘lockw3.c’:

   - supports Windows threads;

   - uses critical section objects *note [cso]: 6df.;

   - locking structure contains a critical section object;

   - recursive and non-recursive calls use the same Windows function;

   - also performs checking.

*note .impl.ix;: 6e0. POSIX implementation ‘lockix.c’:

   - supports *note [POSIXThreads]: 6e1.;

   - locking structure contains a mutex, initialized to check for
     recursive locking;

   - locking structure contains a count of the number of active claims;

   - non-recursive locking calls ‘pthread_mutex_lock()’ and expects
     success;

   - recursive locking calls ‘pthread_mutex_lock()’ and expects either
     success or ‘EDEADLK’ (indicating a recursive claim);

   - also performs checking.

   ---------- Footnotes ----------

   (1) 
https://info.ravenbrook.com/project/mps/import/2001-09-27/mminfo/issue/lock-claim-limit


File: MemoryPoolSystem.info,  Node: Example<2>,  Next: References<7>,  Prev: Implementation<9>,  Up: Lock module

4.21.6 Example
--------------

*note .example.init;: 6e3. An example of allocating and initializing a
lock:

     #include "lock.h"

     static Lock lock;

     void init()
     {
         mps_addr_t p;
         if (mps_alloc(&p, pool, LockSize()) != MPS_RES_OK)
             exit(1);
         lock = p;
         LockInit(lock);
     }

*note .example.binary;: 6e4. An example of using a binary lock:

     void binaryUse()
     {
         /* lock must not be owned by this thread, or else this deadlocks. */
         LockClaim(lock);
         /* lock is now owned by this thread. */
         /* cannot call binaryUse() at this point. */
         /* only one thread at a time may be at this point. */
         LockRelease(lock);
         /* lock not owned by this thread. */
     }

*note .example.recursive;: 6e5. An example of using a recursive lock:

     void recursiveUse()
     {
         /* lock may or may not already be owned by this thread. */
         LockClaimRecursive(lock);
         /* lock is now owned by this thread. */
         /* cannot call binaryUse() at this point. */
         /* can call recursiveUse() at this point. */
         /* only one thread at a time may be at this point. */
         LockReleaseRecursive(lock);
         /* lock is still owned by this thread if it was before. */
     }


File: MemoryPoolSystem.info,  Node: References<7>,  Prev: Example<2>,  Up: Lock module

4.21.7 References
-----------------

(cso) Microsoft Developer Network; “Critical Section Objects”;
<‘https://docs.microsoft.com/en-gb/windows/desktop/Sync/critical-section-objects’>

(POSIXThreads) The Open Group; “The Single UNIX Specification, Version
2—Threads”;
<‘https://pubs.opengroup.org/onlinepubs/7990989775/xsh/threads.html’>


File: MemoryPoolSystem.info,  Node: Client message protocol,  Next: Monitor,  Prev: Lock module,  Up: Design

4.22 Client message protocol
============================

* Menu:

* Introduction: Introduction<22>.
* Requirements: Requirements<13>.
* Design: Design<3>.
* External interface: External interface<2>.
* Internal interface: Internal interface<2>.
* Message life cycle::
* References: References<8>.


File: MemoryPoolSystem.info,  Node: Introduction<22>,  Next: Requirements<13>,  Up: Client message protocol

4.22.1 Introduction
-------------------

*note .intro;: 6ec. The client message protocol provides a means by
which clients can receive messages from the MPS. The motivating use case
is finalization notification (see design.mps.finalize(1)), but the
mechanism is also used for feedback about collections.

*note .contents;: 6ed. This document describes the design of the
external and internal interfaces and concludes with a sketch of an
example design of an internal client.  The example is that of
implementing finalization using the MRG pool.

*note .readership;: 6ee. Any MPS developer.

   ---------- Footnotes ----------

   (1) finalize.html


File: MemoryPoolSystem.info,  Node: Requirements<13>,  Next: Design<3>,  Prev: Introduction<22>,  Up: Client message protocol

4.22.2 Requirements
-------------------

*note .req.synchronous;: 6f0. The message protocol must be synchronous
with the client program: that is, the client program must be able to
choose when to collect and act on messages.  Justification: *note
[Boehm_2002]: 6f1. shows that asynchronous finalization is impossible to
implement correctly.

*note .req.reliable;: 6f2. Posting a message must be reliable: that is,
it must not fail for a dynamic reason such as running out memory to
store the message.  Justification: messages can’t be used to implement
finalization unless the messages can be delivered reliably.

*note .req.extensible.types;: 6f3. The message mechanism must be
extensible with new types of message in future versions of the MPS,
without breaking client programs that do not receive those types of
message.

*note .req.resources;: 6f4. It follows from *note .req.extensible.types:
6f3. that messages must not use resources unless the client program has
requested them (otherwise resources would leak in client programs that
have not been updated to handle new types of message).

*note .req.extensible.fields;: 6f5. It must be possible to add new
fields to existing types of message in future versions of the MPS,
without breaking client programs that do not receive those types of
message.


File: MemoryPoolSystem.info,  Node: Design<3>,  Next: External interface<2>,  Prev: Requirements<13>,  Up: Client message protocol

4.22.3 Design
-------------

*note .sol.synchronous;: 6f7. Messages are stored on a ring belonging to
the arena.  An interface is provided that allows the client program to
collect messages from the ring at a time of its choosing.

*note .sol.reliable;: 6f8. The memory needed for the message is
allocated at an earlier point in time, when it possible to communicate
an allocation failure via a result code.  In particular, space for a
finalization message is allocated when the client program calls *note
mps_finalize(): e8, and space for trace messages is allocated in the
arena (there can be at most one instance of each message per trace, and
the maximum number of traces is known statically).

*note .sol.resources;: 6f9. Messages are not posted unless they belong
to a type that has been enabled by the client program calling
‘mps_message_enable()’.  This means that message types that are not
understood by the client program are not posted and use no resources.

*note .sol.extensible.fields;: 6fa. Message fields are retrieved by
calling accessor functions.


File: MemoryPoolSystem.info,  Node: External interface<2>,  Next: Internal interface<2>,  Prev: Design<3>,  Up: Client message protocol

4.22.4 External interface
-------------------------

* Menu:

* Functions: Functions<2>.
* Types of messages::


File: MemoryPoolSystem.info,  Node: Functions<2>,  Next: Types of messages,  Up: External interface<2>

4.22.4.1 Functions
..................

*note .if.fun;: 6fd. The following functions are provided:

*note .if.fun.poll;: 6fe. *note mps_message_poll(): 240. sees whether
there are any messages pending.  Returns 1 only if there is a message on
the queue of arena.  Returns 0 otherwise.

*note .if.fun.enable;: 6ff. *note mps_message_type_enable(): eb. enables
the flow of messages of a certain type.  The queue of messages of a
arena will contain only messages whose types have been enabled.
Initially all message types are disabled.  Effectively this function
allows the client to declare to the MPS what message types the client
understands.

*note .if.fun.disable;: 700. *note mps_message_type_disable(): 239.
disables the flow of messages of a certain type.  The antidote to *note
mps_message_type_enable(): eb.  Disables the specified message type.
Flushes any existing messages of that type on the queue, and stops any
further generation of messages of that type.  This permits clients to
dynamically decline interest in a message type, which may help to avoid
a memory leak or bloated queue when the messages are only required
temporarily.

*note .if.fun.get;: 701. *note mps_message_get(): ec. begins a message
“transaction”.  If there is a message of the specified type on the queue
then the first such message will be removed from the queue and a handle
to it will be returned to the client via the ‘messageReturn’ argument;
in this case the function will return ‘TRUE’.  Otherwise it will return
‘FALSE’.  Having obtained a handle on a message in this way, the client
can use the type-specific accessors to find out about the message.  When
the client is done with the message the client should call *note
mps_message_discard(): ee.; failure to do so will result in a resource
leak.

*note .if.fun.discard;: 702. *note mps_message_discard(): ee. ends a
message “transaction”.  It indicates to the MPS that the client is done
with this message and its resources may be reclaimed.

*note .if.fun.type.any;: 703. *note mps_message_queue_type(): 241.
determines the type of a message in the queue.  Returns ‘TRUE’ only if
there is a message on the queue of arena, and in this case updates the
‘typeReturn’ argument to be the type of a message in the queue.
Otherwise returns ‘FALSE’.

*note .if.fun.type;: 704. *note mps_message_type(): 23e. determines the
type of a message (that has already been got).  Only legal when inside a
message transaction (that is, after *note mps_message_get(): ec. and
before *note mps_message_discard(): ee.).  Note that the type will be
the same as the type that the client passed in the call to *note
mps_message_get(): ec.


File: MemoryPoolSystem.info,  Node: Types of messages,  Prev: Functions<2>,  Up: External interface<2>

4.22.4.2 Types of messages
..........................

*note .type;: 706. The type governs the “shape” and meaning of the
message.

*note .type.int;: 707. A message type is an integer belonging to the
*note MessageType: 708. enumeration.

*note .type.semantics;: 709. A type indicates the semantics of the
message.

*note .type.semantics.interpret;: 70a. The semantics of a message are
interpreted by the client by calling various accessor methods on the
message.

*note .type.accessor;: 70b. The type of a message governs which accessor
methods are legal to apply to the message.

*note .type.finalization;: 70c. There is a finalization type,
‘MessageTypeFINALIZATION’.

*note .type.finalization.semantics;: 70d. A finalization message
indicates that an object has been discovered to be finalizable (see
design.mps.poolmrg.def.final.object(1) for a definition of finalizable).

*note .type.finalization.ref;: 70e. The accessor function *note
mps_message_finalization_ref(): ed. retrieves the reference to the
object which is finalizable.

*note .type.finalization.ref.scan;: 70f. Note that the reference
returned must be stored in scanned memory.

   ---------- Footnotes ----------

   (1) poolmrg.html#design.mps.poolmrg.def.final.object


File: MemoryPoolSystem.info,  Node: Internal interface<2>,  Next: Message life cycle,  Prev: External interface<2>,  Up: Client message protocol

4.22.5 Internal interface
-------------------------

* Menu:

* Types: Types<6>.
* Functions: Functions<3>.


File: MemoryPoolSystem.info,  Node: Types<6>,  Next: Functions<3>,  Up: Internal interface<2>

4.22.5.1 Types
..............

 -- C Type: typedef struct MessageStruct *Message

*note .message.type;: 712. *note Message: 547. is the type of messages.

*note .message.instance;: 713. Messages are instances of Message
Classes.

*note .message.concrete;: 714. Concretely a message is represented by a
‘MessageStruct’.  A ‘MessageStruct’ has the usual signature field (see
design.mps.sig(1)).  A ‘MessageStruct’ has a type field which defines
its type, a ring node, which is used to attach the message to the queue
of pending messages, a class field, which identifies a *note
MessageClass: 715. object.

*note .message.intent;: 716. The intention is that a ‘MessageStruct’
will be embedded in some richer object which contains information
relevant to that specific type of message.

*note .message.struct;: 717. The structure is declared as follows:

     typedef struct mps_message_s {
       Sig sig;                      /* <design/sig/> */
       Arena arena;                  /* owning arena */
       MessageClass klass;           /* Message Class Structure */
       Clock postedClock;            /* mps_clock() at post time, or 0 */
       RingStruct queueRing;         /* Message queue ring */
     } MessageStruct;

 -- C Type: typedef struct MessageClassStruct *MessageClass

*note .class;: 718. A message class is an encapsulation of methods.  It
encapsulates methods that are applicable to all types of messages
(generic) and methods that are applicable to messages only of a certain
type (type-specific).

*note .class.concrete;: 719. Concretely a message class is represented
by a ‘MessageClassStruct’ (a struct).  Clients of the Message module are
expected to allocate storage for and initialise the
‘MessageClassStruct’.  It is expected that such storage will be
allocated and initialised statically.

*note .class.one-type;: 71a. A message class implements exactly one
message type.  The identifier for this type is stored in the ‘type’
field of the ‘MessageClassStruct’.  Note that the converse is not true:
a single message type may be implemented by two (or more) different
message classes (for example: for two pool classes that require
different implementations for that message type).

*note .class.methods.generic;: 71b. The generic methods are as follows:

   * ‘delete’ – used when the message is destroyed (by the client
     calling *note mps_message_discard(): ee.).  The class
     implementation should finish the message (by calling *note
     MessageFinish(): 71c.) and storage for the message should be
     reclaimed (if applicable).

*note .class.methods.specific;: 71d. The type specific methods are:

*note .class.methods.specific.finalization;: 71e. Specific to
‘MessageTypeFINALIZATION’:

   * ‘finalizationRef’ – returns a reference to the finalizable object
     represented by this message.

*note .class.methods.specific.gc;: 71f. Specific to ‘MessageTypeGC’:

   * ‘gcLiveSize’ – returns the number of bytes (of objects) that were
     condemned by the trace but survived.

   * ‘gcCondemnedSize’ – returns the number of bytes condemned by the
     trace.

   * ‘gcNotCondemnedSize’ – returns the number of bytes (of objects)
     that are collectable but were not condemned by the trace.

*note .class.methods.specific.gcstart;: 720. Specific to
‘MessageTypeGCSTART’:

   * ‘gcStartWhy’ – returns an English-language description of the
     reason why the trace was started.

*note .class.sig.double;: 721. The ‘MessageClassStruct’ has a signature
field at both ends.  This is so that if the ‘MessageClassStruct’ changes
size (by adding extra methods for example) then any static initializers
will generate errors from the compiler (there will be a type error
causes by initialising a non-signature type field with a signature)
unless the static initializers are changed as well.

*note .class.struct;: 722. The structure is declared as follows:

     typedef struct MessageClassStruct {
       Sig sig;                      /* <design/sig/> */
       const char *name;             /* Human readable Class name */

       MessageType type;             /* Message Type */

       /* generic methods */
       MessageDeleteMethod delete;   /* terminates a message */

       /* methods specific to MessageTypeFINALIZATION */
       MessageFinalizationRefMethod finalizationRef;

       /* methods specific to MessageTypeGC */
       MessageGCLiveSizeMethod gcLiveSize;
       MessageGCCondemnedSizeMethod gcCondemnedSize;
       MessageGCNotCondemnedSizeMethod gcNotCondemnedSize;

       /* methods specific to MessageTypeGCSTART */
       MessageGCStartWhyMethod gcStartWhy;

       Sig endSig;                   /* <design/message/#class.sig.double> */
     } MessageClassStruct;

*note .space.queue;: 723. The arena structure is augmented with a
structure for managing for queue of pending messages.  This is a ring in
the ‘ArenaStruct’:

     struct ArenaStruct
     {
       ...
       RingStruct messageRing;
       ...
     }

   ---------- Footnotes ----------

   (1) sig.html


File: MemoryPoolSystem.info,  Node: Functions<3>,  Prev: Types<6>,  Up: Internal interface<2>

4.22.5.2 Functions
..................

 -- C Function: void MessageInit (Arena arena, Message message,
          MessageClass klass, MessageType type)

*note .fun.init;: 726. Initializes the ‘MessageStruct’ pointed to by
‘message’.  The caller of this function is expected to manage the store
for the ‘MessageStruct’.

 -- C Function: void MessageFinish (Message message)

*note .fun.finish;: 727. Finishes the ‘MessageStruct’ pointed to by
‘message’.  The caller of this function is expected to manage the store
for the ‘MessageStruct’.

 -- C Function: void MessagePost (Arena arena, Message message)

*note .fun.post;: 729. Places a message on the queue of an arena.

*note .fun.post.precondition;: 72a. Prior to calling the function, the
‘queueRing’ field of the message must be a singleton
(design.mps.ring.def.singleton(1)).  After the call to the function the
message will be available for MPS client to access.  After the call to
the function the message fields must not be manipulated except from the
message’s class’s method functions (that is, you mustn’t poke about with
the ‘queueRing’ field in particular).

 -- C Function: void MessageEmpty (Arena arena)

*note .fun.empty;: 72b. Empties the message queue.  This function has
the same effect as discarding all the messages on the queue.  After
calling this function there will be no messages on the queue.

*note .fun.empty.internal-only;: 72c. This functionality is not exposed
to clients.  We might want to expose this functionality to our clients
in the future.

   ---------- Footnotes ----------

   (1) ring.html#design.mps.ring.def.singleton


File: MemoryPoolSystem.info,  Node: Message life cycle,  Next: References<8>,  Prev: Internal interface<2>,  Up: Client message protocol

4.22.6 Message life cycle
-------------------------

*note .life.alloc;: 72e. Space for the message structure is allocated at
the earliest point in time when the MPS knows that the message might be
needed.

*note .life.init;: 72f. The message structure is initialized by calling
*note MessageInit(): 725.

*note .life.post;: 730. The message is posted on the arena’s message
queue by calling *note MessagePost(): 728.

*note .life.get;: 731. The client program retrieves the message by
calling *note mps_message_get(): ec.

*note .life.discard;: 732. The client program indicates that it is
finished with the message by calling *note mps_message_discard(): ee.

*note .life.reuse;: 733. The MPS may reuse the message structure, in
which case the lifecycle continues from *note .life.post: 730.

*note .life.delete;: 734. When the MPS no longer needs the message
structure, its ‘delete’ method is called.


File: MemoryPoolSystem.info,  Node: References<8>,  Prev: Message life cycle,  Up: Client message protocol

4.22.7 References
-----------------

(Boehm_2002) Hans-J. Boehm.  2002.  “Destructors, Finalizers, and
Synchronization(1)”.  HP Labs technical report HPL-2002-335.

   ---------- Footnotes ----------

   (1) http://www.hpl.hp.com/techreports/2002/HPL-2002-335.html


File: MemoryPoolSystem.info,  Node: Monitor,  Next: Nailboards for ambiguously referenced segments,  Prev: Client message protocol,  Up: Design

4.23 Monitor
============

* Menu:

* Introduction: Introduction<23>.
* Requirements: Requirements<14>.
* Installation and usage::
* References: References<9>.


File: MemoryPoolSystem.info,  Node: Introduction<23>,  Next: Requirements<14>,  Up: Monitor

4.23.1 Introduction
-------------------

*note .intro;: 73b. This is the design of the MPS monitor, a graphical
user interface for inspecting the behaviour of the MPS in a client
program by collating the program’s telemetry output.

*note .readership;: 73c. This document is intended for any MPS user.

*note .source;: 73d. This is based on *note [GDR_2018-06-27]: 73e.


File: MemoryPoolSystem.info,  Node: Requirements<14>,  Next: Installation and usage,  Prev: Introduction<23>,  Up: Monitor

4.23.2 Requirements
-------------------

It should be possible to analyze the behaviour of the MPS in a client
program:

*note .req.state.running;: 740. that is currently running
(job003960(1)); or

*note .req.state.stopped;: 741. that has finished running.

It should be possible to see:

*note .req.memory.total;: 742. the total memory in use by the client
program *note [GR_2004-12-02]: 743.;

*note .req.memory.pool;: 744. the memory in use by each pool
(job003960(2));

*note .req.trace;: 745. when traces take place (job003960(3));

*note .req.trace.generation;: 746. which generations get collected by
each trace (job003960(4));

*note .req.time-fraction;: 747. the fraction of runtime spent in
collections;

*note .req.barriers;: 748. the rate of barrier hits, to indicate how the
barriers are working (job003921(5)).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003960/

   (2) https://www.ravenbrook.com/project/mps/issue/job003960/

   (3) https://www.ravenbrook.com/project/mps/issue/job003960/

   (4) https://www.ravenbrook.com/project/mps/issue/job003960/

   (5) https://www.ravenbrook.com/project/mps/issue/job003921/


File: MemoryPoolSystem.info,  Node: Installation and usage,  Next: References<9>,  Prev: Requirements<14>,  Up: Monitor

4.23.3 Installation and usage
-----------------------------

These are placeholder instructions, to be revised when we figure out the
best way to automate them.

  1. Build the ‘mpseventpy’ program:

          cd code
          nmake /f w3i6mv.nmk VARIETY=cool mpseventpy.exe # Windows
          make -f xci6ll.gmk VARIETY=cool mpseventpy # macOS
          make -f lii6ll.gmk VARIETY=cool mpseventpy # Linux

  2. Run ‘mpseventpy’ program and redirect the output to
     ‘tool/mpsevent.py’:

          w3i6mv/cool/mpseventpy.exe > ../tool/mpsevent.py # Windows
          xci6ll/cool/mpseventpy > ../tool/mpsevent.py # macOS
          lii6ll/cool/mpseventpy > ../tool/mpsevent.py # Linux

  3. Install Python 3.6 (or later).  On Windows, there are installers(1)
     named like ‘python-3.6.6-amd64.exe’.  On other platforms, you
     probably want to use your package manager, for example:

          sudo port install python36 # macPorts
          sudo apt install python3.6 # Linux

  4. On Windows, you’ll want to edit the system environment variables to
     put Python 3.6 on the path.

  5. Install Matplotlib and PyQt5.  On Windows, the easiest way to do
     this is to launch a command prompt (possibly as administrator, if
     you installed Python somewhere like ‘C:/Program Files’) and then:

          python -m ensurepip
          python -m pip install matplotlib pyqt5

     On other platforms, you’ll want to use the package manager, for
     example:

          sudo port install py36-matplotlib py36-pyqt5 # macPorts
          sudo apt install python3-matplotlib python3-pyqt5 # Linux

  6. Now, from the ‘tool’ subdirectory, you should be able to run the
     monitor:

          cd tool
          ./monitor [FILENAME]

     where FILENAME defaults to mpsio.log.  So for example, you could
     compile the ‘amcss’ smoke test:

          cd code
          nmake /f w3i6mv.nmk VARIETY=cool amcss.exe # Windows
          make -f xci6ll.gmk VARIETY=cool amcss # macOS
          make -f lli6ll.gmk VARIETY=cool amcss # Linux

     and then run ‘amcss’ generating telemetry output:

          cd tool
          MPS_TELEMETRY_FILENAME=mpsio.log MPS_TELEMETRY_CONTROL="arena pool user” ../code/w3i6mv/cool/amcss.exe > /dev/null # Windows
          MPS_TELEMETRY_FILENAME=mpsio.log MPS_TELEMETRY_CONTROL="arena pool user" ../code/xci6ll/cool/amcss > /dev/null # macOS
          MPS_TELEMETRY_FILENAME=mpsio.log MPS_TELEMETRY_CONTROL="arena pool user" ../code/lli6ll/cool/amcss > /dev/null # Linux

     and then launch the monitor on the file you just created:

          cd tool
          ./monitor

     which should show you something like this (the exact graphs will
     depend on the random choices made by ‘amcss’):

 [image src="MemoryPoolSystem-figures/monitor.png" alt="Screenshot of the MPS monitor showing a run of the amcss smoke test." ]


     Figure
  7. The monitor is capable of monitoring an application in real-time.
     The pause button on the toolbar pauses the updating of the display
     (but not the application).  The zoom and pan tools automatically
     pause the updating too, so after zooming you’ll need to unpause in
     order to resume updating the display.

   ---------- Footnotes ----------

   (1) https://www.python.org/ftp/python/3.6.5/python-3.6.5-amd64.exe


File: MemoryPoolSystem.info,  Node: References<9>,  Prev: Installation and usage,  Up: Monitor

4.23.4 References
-----------------

(GDR_2018-06-27) Gareth Rees.  Ravenbrook Limited.  2018-06-27.
“Setting up and running the monitor(1)”.

(GR_2004-12-02) Göran Rydqvist.  Configura Sverige AB. 2004-12-02.  “RE:
MPS, working set, and address space(2)”.

   ---------- Footnotes ----------

   (1) https://info.ravenbrook.com/mail/2018/06/27/10-51-04/0/

   (2) https://info.ravenbrook.com/mail/2004/12/02/07-53-32/0/


File: MemoryPoolSystem.info,  Node: Nailboards for ambiguously referenced segments,  Next: Pool classes<2>,  Prev: Monitor,  Up: Design

4.24 Nailboards for ambiguously referenced segments
===================================================

* Menu:

* Introduction: Introduction<24>.
* Requirements: Requirements<15>.
* Implementation: Implementation<10>.
* Future::
* References: References<10>.


File: MemoryPoolSystem.info,  Node: Introduction<24>,  Next: Requirements<15>,  Up: Nailboards for ambiguously referenced segments

4.24.1 Introduction
-------------------

*note .intro;: 751. This is the design of the nailboard module.

*note .readership;: 752. Any MPS developer.

*note .overview;: 753. A nailboard represents a set of addresses to
which ambiguous references have been found.  It is implemented as a
specialized bit table that maps addresses within a range to 'nails'.
The mapping has granularity, so that all addresses within a word, say,
will map to the same nail.

*note .purpose;: 754. Nailboards are used by the AMC pool class to
record ambiguous references to grains within a segment.  See
design.mps.poolamc.nailboard(1).

   ---------- Footnotes ----------

   (1) poolamc.html#design.mps.poolamc.nailboard


File: MemoryPoolSystem.info,  Node: Requirements<15>,  Next: Implementation<10>,  Prev: Introduction<24>,  Up: Nailboards for ambiguously referenced segments

4.24.2 Requirements
-------------------

*note .req.granularity;: 757. A nailboard must be able to set nails for
addresses down to the grain size of the segment.  (Because individual
objects may be this small, and we must be able to preserve or reclaim
individual objects.)

*note .req.set;: 758. A nailboard must be able to set a nail
corresponding to any aligned address in the range covered.  (Because
ambiguous references may have arbitrary values.)

*note .req.reset.not;: 759. A nailboard is 'not' required to be able to
reset a nail.  (Because resetting a nail would correspond to proving
that there is 'no' ambiguous reference to that address, but that can
only be established when the trace is complete.)

*note .req.range;: 75a. A nailboard must be able to determine if any
nail is set in a contiguous range.  (Because we must preserve the whole
object if there is any ambiguous reference to it.)

*note .req.range.cost;: 75b. Determining if any nail is set in a
continuous range must be cheap.  That is, it must take time that is no
more than logarithmic in the size of the range.  (Because scanning
overhead must be proportional to the number of objects, not to their
size.)

