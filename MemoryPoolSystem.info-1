This is MemoryPoolSystem.info, produced by makeinfo version 7.1.1 from
MemoryPoolSystem.texi.

     Memory Pool System 1.118.0, Feb 11, 2025

     Ravenbrook Limited

     Copyright © 2025, Ravenbrook Limited

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* MemoryPoolSystem: (MemoryPoolSystem.info). One line description of project.
END-INFO-DIR-ENTRY


   Generated by Sphinx 8.1.3.


File: MemoryPoolSystem.info,  Node: Top,  Next: Guide,  Up: (dir)

Memory Pool System Documentation
********************************

     Memory Pool System 1.118.0, Feb 11, 2025

     Ravenbrook Limited

     Copyright © 2025, Ravenbrook Limited

* Menu:

* Guide::
* Reference::
* Pool reference::
* Design::
* Old design::
* Bibliography::
* Memory Management Glossary::
* Index to source code::
* Memory Pool System Kit Open Source License::
* Contact us::
* Contributing to the MPS::
* Release notes::
* Introduction to memory management::
* Home::
* Frequently Asked Questions::
* Copyright::
* Acknowledgements::
* Index::

 -- The Detailed Node Listing --

Guide

* Overview of the Memory Pool System::
* Building the Memory Pool System::
* Garbage collecting a language with the Memory Pool System::
* The stretchy vector problem::
* Debugging with the Memory Pool System::
* Tuning the Memory Pool System for performance::
* Advanced topics::
* Implementing malloc and free::

Overview of the Memory Pool System

* Supported target platforms::
* Technical introduction::
* What next?::

Building the Memory Pool System

* Introduction::
* Getting hold of the MPS Kit::
* Compiling the MPS for your project::
* Building the MPS manual::
* Building the MPS for development::
* Installing the Memory Pool System::

Compiling the MPS for your project

* Compiling for production::
* Compiling for debugging::
* Optimizing for your object format::
* Compiling without the C library::

Building the MPS for development

* Prerequisites::
* Platforms::
* Running make::

Installing the Memory Pool System

* mpseventsql::

Garbage collecting a language with the Memory Pool System

* The Scheme interpreter::
* Choosing an arena class::
* Choosing a pool class::
* Describing your objects::
* Creating the pool::
* Roots::
* Threads::
* Allocation::
* Maintaining consistency::
* Tidying up::
* What next?: What next?<2>.

Describing your objects

* Alignment::
* The scan method::
* The skip method::
* The forward method::
* The is-forwarded method::
* The padding method::

Debugging with the Memory Pool System

* General debugging advice::
* Address space layout randomization::
* Example; underscanning: Example underscanning.
* Example; allocating with wrong size: Example allocating with wrong size.
* What next?: What next?<3>.

Advanced topics

* Finalization::
* Location dependency::
* Weak hash tables::
* Global symbol table::
* Segregation of objects::

Reference

* Interface conventions::
* Keyword arguments::
* Error handing::
* Arenas::
* Pools::
* Allocation: Allocation<2>.
* Object formats::
* Scanning::
* Threads: Threads<2>.
* Roots: Roots<2>.
* Garbage collection::
* Messages::
* Finalization: Finalization<2>.
* Location dependency: Location dependency<2>.
* Segregated allocation caches::
* Allocation patterns::
* Allocation frames::
* Debugging pools::
* Telemetry::
* Weak references::
* Transforms::
* Plinth::
* Platforms: Platforms<2>.
* Porting the MPS::
* Deprecated interfaces::
* Security issues::

Interface conventions

* Support policy::
* Language::
* Headers::
* Identifiers::
* Types::
* Functions::
* Type punning::
* Macros::
* General types::

Error handing

* Result codes::
* Assertions::
* Varieties::

Assertions

* Assertion handling::
* Common assertions and their causes::

Arenas

* Client arenas::
* Virtual memory arenas::
* Arena properties::
* Arena states::
* Running garbage collections::
* Using idle time for collection::
* Arena introspection and debugging::
* Arena extension callbacks::

Pools

* Pool classes::
* Pool introspection::

Allocation

* Manual allocation::
* Allocation points::
* Allocation point protocol::
* Example; allocating a symbol: Example allocating a symbol.
* Cautions::
* Example; inserting into a doubly linked list: Example inserting into a doubly linked list.
* Allocation point implementation::

Object formats

* Interface::
* In-band headers::
* Cautions: Cautions<2>.
* Format methods::
* Object format introspection::

Scanning

* Scanning protocol::
* Tagged references::
* Critical path::
* Ambiguous references::
* Unfixed references::
* Example; Scheme objects: Example Scheme objects.
* Scanning interface::
* Fixing interface::
* Area scanners::

Threads

* Thread safety::
* Thread registration::
* Signal and exception handling issues::
* Fork safety::
* Thread interface::

Roots

* Registering roots::
* Cautions: Cautions<3>.
* Thread roots::
* Ranks::
* Root modes::
* Root interface::
* Root introspection::

Garbage collection

* Generation chains::
* Scheduling of collections::
* Garbage collection start messages::
* Garbage collection messages::

Messages

* Finalization messages::
* Example; interactive chatter: Example interactive chatter.
* Message types::
* Message interface::
* Message queue interface::

Finalization

* Multiple finalizations::
* Cautions: Cautions<4>.
* Finalization interface::
* Finalization messages: Finalization messages<2>.

Location dependency

* Terminology::
* Creating dependencies::
* Adding dependencies::
* Testing dependencies for staleness::
* Thread safety: Thread safety<2>.
* Location dependency interface::

Segregated allocation caches

* Cache interface::
* Allocation interface::

Allocation patterns

* Ramp allocation::

Telemetry

* Telemetry utilities::
* Example::
* Event categories::
* Environment variables::
* Decoding the telemetry stream::
* Making the telemetry stream readable::
* Loading the telemetry stream into SQLite::
* Decoding the telemetry stream in Python::
* Telemetry events::
* Telemetry interface::
* Telemetry labels::
* Customizing the telemetry system::

Transforms

* Cautions: Cautions<5>.
* Interface: Interface<2>.

Plinth

* I/O module::
* Library module::

Platforms

* Platform codes::
* Platform interface::
* Historical platform codes::
* Historical platform list::
* Platform limitations::

Porting the MPS

* Platform code::
* Functional modules::
* Platform detection::
* Platform configuration::
* Module selection::
* Makefile::
* Porting strategy::
* Update the documentation::
* Contribute::

Deprecated interfaces

* Deprecated in version 1.118: Deprecated in version 1 118.
* Deprecated in version 1.115: Deprecated in version 1 115.
* Deprecated in version 1.113: Deprecated in version 1 113.
* Deprecated in version 1.112: Deprecated in version 1 112.

Security issues

* Predictable address space layout on FreeBSD::
* Address disclosure::
* Telemetry: Telemetry<2>.

Pool reference

* Choosing a pool class: Choosing a pool class<2>.
* Pool class properties::
* Writing a new pool class::
* AMC (Automatic Mostly-Copying): AMC Automatic Mostly-Copying.
* AMCZ (Automatic Mostly-Copying Zero-rank): AMCZ Automatic Mostly-Copying Zero-rank.
* AMS (Automatic Mark and Sweep): AMS Automatic Mark and Sweep.
* AWL (Automatic Weak Linked): AWL Automatic Weak Linked.
* LO (Leaf Object): LO Leaf Object.
* MFS (Manual Fixed Small): MFS Manual Fixed Small.
* MVFF (Manual Variable First Fit): MVFF Manual Variable First Fit.
* MVT (Manual Variable Temporal): MVT Manual Variable Temporal.
* SNC (Stack No Checking): SNC Stack No Checking.

Choosing a pool class

* Choosing an automatic pool class::
* Choosing a manual pool class::

AMC (Automatic Mostly-Copying)

* AMC properties::
* AMC interface::
* Hash arrays::

AMCZ (Automatic Mostly-Copying Zero-rank)

* AMCZ properties::
* AMCZ interface::

AMS (Automatic Mark and Sweep)

* AMS properties::
* AMS interface::

AWL (Automatic Weak Linked)

* AWL properties::
* Dependent objects::
* Protection faults::
* Caution::
* AWL interface::

LO (Leaf Object)

* LO properties::
* LO interface::

MFS (Manual Fixed Small)

* MFS properties::
* MFS interface::

MVFF (Manual Variable First Fit)

* MVFF properties::
* MVFF interface::

MVT (Manual Variable Temporal)

* Temporal fit::
* MVT properties::
* MVT interface::

SNC (Stack No Checking)

* SNC properties::
* SNC interface::

Design

* Fixed-length queues::
* Generic modules::
* Bootstrapping::
* Coalescing block structures::
* Fast high-resolution clock::
* MPS Configuration::
* The critical path through the MPS::
* Documentation::
* Execution environment::
* Fail-over allocator::
* Finalization: Finalization<3>.
* Free list allocator::
* New developer guide::
* Transliterating the alphabet into hexadecimal::
* C Style – formatting::
* C Style – naming::
* Review checklist::
* C interface design::
* Keyword arguments in the MPS::
* Lands::
* Lock module::
* Client message protocol::
* Monitor::
* Nailboards for ambiguously referenced segments::
* Pool classes: Pool classes<2>.
* Mutator context::
* Memory protection::
* POSIX implementation of protection module::
* Ranges of addresses::
* Ring data structure::
* Shield::
* Signatures in the MPS::
* Stack probe::
* Splay trees::
* Stack and register scanning::
* Tests::
* Multi-threaded testing::
* Thread manager::
* Thread safety in the MPS::
* Transforms: Transforms<2>.
* General MPS types::
* Library version mechanism::
* Virtual mapping::
* Walking formatted objects::
* Write barrier::
* The WriteF function::

Fixed-length queues

* Introduction: Introduction<2>.
* Requirements::
* Interface: Interface<3>.

Generic modules

* Introduction: Introduction<3>.
* Requirements: Requirements<2>.
* Design: Design<2>.
* Modules::
* Limitations of generic implementations::

Bootstrapping

* Introduction: Introduction<4>.
* Bootstrapping problems::

Bootstrapping problems

* Virtual memory descriptor::
* Arena descriptor::
* Arena’s free land::

Coalescing block structures

* Introduction: Introduction<5>.
* Requirements: Requirements<3>.
* Interface: Interface<4>.
* Implementation::
* Testing::
* Notes for future development::
* Risks::

Interface

* External types::
* External classes::
* Keyword arguments: Keyword arguments<2>.
* Limitations::

Implementation

* Splay tree::
* Low memory behaviour::
* The CBS block::

Fast high-resolution clock

* Introduction: Introduction<6>.
* Requirements: Requirements<4>.
* Interface: Interface<5>.
* Implementation: Implementation<2>.

MPS Configuration

* Introduction: Introduction<7>.
* Requirements: Requirements<5>.
* Definitions::
* Overview::
* The build system::
* Implementation: Implementation<3>.
* Source code configuration::
* Configuration options::
* To document::
* References::

Requirements

* Retired requirements::

The build system

* Abstract build function::
* File Structure::
* Modules and naming::
* Build system rationale::
* Warnings and errors::

Implementation

* Target platform detection::
* Target varieties::

Source code configuration

* Configuration Parameters::
* Abstract and Concrete Module Interfaces::

The critical path through the MPS

* Introduction: Introduction<8>.
* What makes the critical path critical::
* How the MPS avoids scanning and fixing::
* Where to find the critical path::
* The format scanner::
* The second stage fix in the MPM::
* The third stage fix in the segment class::
* Other considerations::
* References: References<2>.

Documentation

* Introduction: Introduction<9>.
* Types: Types<2>.
* Requirements: Requirements<6>.
* Implementation: Implementation<4>.
* Manual extensions::
* Design formatting conventions::
* References: References<3>.

Execution environment

* Introduction: Introduction<10>.
* Discussion::
* Interpretation::
* Requirements: Requirements<7>.
* Architecture::

Fail-over allocator

* Introduction: Introduction<11>.
* Interface: Interface<6>.
* Implementation: Implementation<5>.

Interface

* Types: Types<3>.
* Classes::
* Keyword arguments: Keyword arguments<3>.

Finalization

* Overview: Overview<2>.
* Requirements: Requirements<8>.
* Implementation: Implementation<6>.
* External interface::
* Internal interface::

Free list allocator

* Introduction: Introduction<12>.
* Overview: Overview<3>.
* Requirements: Requirements<9>.
* Interface: Interface<7>.
* Implementation: Implementation<7>.
* Testing: Testing<2>.
* Opportunities for improvement::

Interface

* Types: Types<4>.
* Classes: Classes<2>.
* Keyword arguments: Keyword arguments<4>.

New developer guide

* Introduction: Introduction<13>.
* What to read first::
* References: References<4>.

Transliterating the alphabet into hexadecimal

* Introduction: Introduction<14>.
* Transliteration::
* Justification::
* Notes::
* References: References<5>.

C Style – formatting

* Introduction: Introduction<15>.
* General formatting conventions::

General formatting conventions

* Line width::
* White space::
* Sections and paragraphs::
* Statements::
* Indentation::
* Positioning of braces::
* Switch statements::
* Comments::
* Macros: Macros<2>.

C Style – naming

* Introduction: Introduction<16>.
* Capitalization::
* Prefixes::
* Suffixes::

Review checklist

* Introduction: Introduction<17>.
* Checklist::

C interface design

* Introduction: Introduction<18>.
* Analysis::
* Architecture: Architecture<2>.
* Naming conventions::
* Type conventions::
* Checking::
* Binary compatibility issues::
* Constraints::
* Implementation: Implementation<8>.
* Notes: Notes<2>.

Analysis

* Goals::
* Requirements: Requirements<10>.

Keyword arguments in the MPS

* Introduction: Introduction<19>.
* Overview: Overview<4>.
* Internals::
* The varargs legacy::
* References: References<6>.

Lands

* Introduction: Introduction<20>.
* Definitions: Definitions<2>.
* Requirements: Requirements<11>.
* Interface: Interface<8>.
* Implementations::
* Testing: Testing<3>.

Interface

* Types: Types<5>.
* Generic functions::

Lock module

* Introduction: Introduction<21>.
* Background::
* Requirements: Requirements<12>.
* Interface: Interface<9>.
* Implementation: Implementation<9>.
* Example: Example<2>.
* References: References<7>.

Client message protocol

* Introduction: Introduction<22>.
* Requirements: Requirements<13>.
* Design: Design<3>.
* External interface: External interface<2>.
* Internal interface: Internal interface<2>.
* Message life cycle::
* References: References<8>.

External interface

* Functions: Functions<2>.
* Types of messages::

Internal interface

* Types: Types<6>.
* Functions: Functions<3>.

Monitor

* Introduction: Introduction<23>.
* Requirements: Requirements<14>.
* Installation and usage::
* References: References<9>.

Nailboards for ambiguously referenced segments

* Introduction: Introduction<24>.
* Requirements: Requirements<15>.
* Implementation: Implementation<10>.
* Future::
* References: References<10>.

Pool classes

* Introduction: Introduction<25>.
* Classes and structures::
* Fields::
* Methods::

Mutator context

* Introduction: Introduction<26>.
* Requirements: Requirements<16>.
* Interface: Interface<10>.
* Implementations: Implementations<2>.

Implementations

* Generic implementation::
* Posix implementation::
* Windows implementation::
* macOS implementation::

Memory protection

* Introduction: Introduction<27>.
* Requirements: Requirements<17>.
* Design: Design<4>.
* Interface: Interface<11>.
* Implementations: Implementations<3>.

POSIX implementation of protection module

* Introduction: Introduction<28>.
* Requirements: Requirements<18>.
* Data structures::
* Functions: Functions<4>.
* Threads: Threads<3>.

Ranges of addresses

* Introduction: Introduction<29>.
* Requirements: Requirements<19>.
* Interface: Interface<12>.

Ring data structure

* Introduction: Introduction<30>.
* Description::
* Interface: Interface<13>.
* Naming::
* Deques::
* Defects::

Interface

* Init / Finish::
* Checking: Checking<2>.
* Iteration::
* Element access::
* Append / Remove::

Shield

* Introduction: Introduction<31>.
* Overview: Overview<5>.
* Interface: Interface<14>.
* Mechanism::
* Implementation: Implementation<11>.
* Initial ideas::
* Improvement Ideas::
* References: References<11>.

Interface

* Mutator access::
* Entering the shield::
* Collector access to segments::
* Collector access to the unprotectable::

Implementation

* Definitions: Definitions<3>.
* Properties::
* Invariants::
* Proof Hints::

Improvement Ideas

* Mass exposure::
* Segment independence::
* Concurrent collection::
* Early Resume::
* Expose modes::

Signatures in the MPS

* Introduction: Introduction<32>.
* Overview: Overview<6>.
* Definitions: Definitions<4>.
* Init and Finish::
* Checking: Checking<3>.
* Rules::
* Tools::
* References: References<12>.

Stack probe

* Introduction: Introduction<33>.
* Requirements: Requirements<20>.
* Design: Design<5>.
* Interface: Interface<15>.
* Issues::
* Implementations: Implementations<4>.

Splay trees

* Introduction: Introduction<34>.
* Overview: Overview<7>.
* Definitions: Definitions<5>.
* Requirements: Requirements<21>.
* Generic binary tree interface::
* Splay tree interface::
* Client-determined properties::
* Usage::
* Implementation: Implementation<12>.
* Testing: Testing<4>.
* Error Handling::
* Future: Future<2>.
* References: References<13>.

Generic binary tree interface

* Types: Types<7>.
* Functions: Functions<5>.

Splay tree interface

* Types: Types<8>.
* Functions: Functions<6>.

Implementation

* Top-down splaying::
* Top-level operations::

Stack and register scanning

* Introduction: Introduction<35>.
* Requirements: Requirements<22>.
* Design: Design<6>.
* Analysis: Analysis<2>.
* Interface: Interface<16>.
* Implementations: Implementations<5>.
* References: References<14>.

Tests

* Introduction: Introduction<36>.
* Running tests::
* Test targets::
* Test features::
* Test list::
* Test database::
* Test runner::
* Performance test::
* Adding a new test::
* Continuous integration::
* MMQA tests::
* Other tests::
* References: References<15>.

Multi-threaded testing

* Introduction: Introduction<37>.
* Requirements: Requirements<23>.
* Implementation: Implementation<13>.
* Interface: Interface<17>.
* References: References<16>.

Thread manager

* Introduction: Introduction<38>.
* Requirements: Requirements<24>.
* Design: Design<7>.
* Interface: Interface<18>.
* Implementations: Implementations<6>.

Implementations

* Generic implementation: Generic implementation<2>.
* POSIX threads implementation::
* Windows implementation: Windows implementation<2>.
* macOS implementation: macOS implementation<2>.

Thread safety in the MPS

* Introduction: Introduction<39>.
* Requirements: Requirements<25>.
* Analysis: Analysis<3>.
* Design: Design<8>.
* Fork safety: Fork safety<3>.

Analysis

* Performance cost of locking::
* Recursive vs binary locks::
* Fork safety: Fork safety<2>.

Transforms

* Introduction: Introduction<40>.
* Background: Background<2>.
* Overview: Overview<8>.
* Not yet written::
* References: References<17>.

General MPS types

* Introduction: Introduction<41>.
* Rationale::
* Concrete types::
* Abstract types::

Library version mechanism

* Introduction: Introduction<42>.
* Readership::
* Source::
* Overview: Overview<9>.
* Architecture: Architecture<3>.
* Implementation: Implementation<14>.

Virtual mapping

* Introduction: Introduction<43>.
* Requirements: Requirements<26>.
* Design: Design<9>.
* Interface: Interface<19>.
* Implementations: Implementations<7>.
* Testing: Testing<5>.

Implementations

* Generic implementation: Generic implementation<3>.
* Unix implementation::
* Windows implementation: Windows implementation<3>.

Walking formatted objects

* Introduction: Introduction<44>.
* Use cases::
* Requirements: Requirements<27>.
* Design: Design<10>.
* References: References<18>.

Write barrier

* Introduction: Introduction<45>.
* Overview: Overview<10>.
* Write Barrier Processes::
* Write barrier deferral::
* Improvements::
* References: References<19>.

The WriteF function

* Introduction: Introduction<46>.
* Design: Design<11>.
* References: References<20>.

Old design

* Allocation frame protocol::
* Arena::
* Virtual Memory Arena::
* Bit tables::
* Allocation buffers and allocation points::
* Checking: Checking<4>.
* Collection framework::
* Diagnostic feedback::
* The generic fix function::
* I/O subsystem::
* Library interface::
* Locus manager::
* GC messages::
* Debugging features for client objects::
* AMC pool class::
* AMS pool class::
* AWL pool class::
* LO pool class::
* MFS pool class::
* MRG pool class::
* Manual Variable Temporal (MVT) pool design: Manual Variable Temporal MVT pool design.
* MVFF pool class::
* Protocol inheritance::
* POSIX thread extensions::
* Root manager::
* The generic scanner::
* Segment data structure::
* MPS Strategy::
* Telemetry: Telemetry<3>.
* Tracer::

Allocation frame protocol

* Introduction: Introduction<47>.
* Definitions: Definitions<6>.
* Purpose::
* Requirements: Requirements<28>.
* Overview: Overview<11>.
* Operations::
* Interface: Interface<20>.
* Lightweight frames::

Requirements

* Known requirements::
* Proto-requirements::

Interface

* External types: External types<2>.
* External functions::
* Internal types::

Lightweight frames

* Overview: Overview<12>.
* Synchronization::
* Implementation: Implementation<15>.

Arena

* Introduction: Introduction<48>.
* Overview: Overview<13>.
* Definitions: Definitions<7>.
* Requirements: Requirements<29>.
* Architecture: Architecture<4>.
* Implementation: Implementation<16>.

Requirements

* Block management::
* Address translation::
* Arena partition::
* Constraints: Constraints<2>.

Architecture

* Statics::
* Arena classes::
* Chunks::
* Tracts::
* Control pool::
* Polling::
* Commit limit::
* Spare committed (aka “hysteresis”): Spare committed aka “hysteresis”.
* Pause time control::
* Locks::
* Location dependencies::
* Finalization: Finalization<4>.

Implementation

* Tract cache::
* Control pool: Control pool<2>.
* Traces::
* Polling: Polling<2>.
* Location dependencies: Location dependencies<2>.
* Roots: Roots<3>.

Virtual Memory Arena

* Introduction: Introduction<49>.
* Overview: Overview<14>.
* Notes: Notes<3>.
* Requirements: Requirements<30>.
* Architecture: Architecture<5>.
* Solution ideas::
* Data structures: Data structures<2>.
* Notes: Notes<4>.

Requirements

* Placement::
* Arena partition: Arena partition<2>.

Bit tables

* Introduction: Introduction<50>.
* Definitions: Definitions<8>.
* Requirements: Requirements<31>.
* Non requirements::
* Background: Background<3>.
* Clients::
* Overview: Overview<15>.
* Interface: Interface<21>.
* Detailed design::
* Testing: Testing<6>.
* References: References<21>.

Detailed design

* Data structures: Data structures<3>.
* Functions: Functions<7>.

Allocation buffers and allocation points

* Introduction: Introduction<51>.
* Glossary::
* Source: Source<2>.
* Requirements: Requirements<32>.
* Classes: Classes<3>.
* Logging::
* Measurement::
* Notes from the whiteboard::
* Synchronization: Synchronization<2>.
* Interface: Interface<22>.
* Diagrams::

Checking

* Introduction: Introduction<52>.
* Implementation: Implementation<17>.
* Common assertions::

Collection framework

* Introduction: Introduction<53>.
* Overview: Overview<16>.
* Collection abstractions::
* The tracer::
* Barriers::

Collection abstractions

* Colours, scanning and fixing: Colours scanning and fixing.
* Reference sets::

The tracer

* The condemn phase::
* The grey mutator phase::
* The flip phase::
* The black mutator phase::
* The reclaim phase::

Barriers

* Hardware barriers::
* Software barriers::

Diagnostic feedback

* Introduction: Introduction<54>.
* Overview: Overview<17>.
* Requirements: Requirements<33>.
* Usage: Usage<2>.
* How to write a diagnostic::
* How the MPS diagnostic system works::
* References: References<22>.

How to write a diagnostic

* Compile away in non-diag varieties; no side effects::
* Writing good paragraph text::

How the MPS diagnostic system works

* Parts of the MPS diagnostic system::
* Statistics::
* Related systems::

The generic fix function

* Introduction: Introduction<55>.
* Was-marked protocol::
* Implementation: Implementation<18>.

I/O subsystem

* Introduction: Introduction<56>.
* Background: Background<4>.
* Purpose: Purpose<2>.
* Requirements: Requirements<34>.
* Architecture: Architecture<6>.
* Interface: Interface<23>.
* I/O module implementations::
* Notes: Notes<5>.
* Attachments::

Requirements

* General::
* Functional::

Architecture

* Example configurations::

Interface

* I/O module state::
* Message types: Message types<2>.
* Limits::
* Interface set-up and tear-down::
* Message send and receive::

I/O module implementations

* Routeing::

Library interface

* Introduction: Introduction<57>.
* Goals: Goals<2>.
* Description: Description<2>.
* Implementation: Implementation<19>.

Description

* Overview: Overview<18>.

Locus manager

* Introduction: Introduction<58>.
* Overview: Overview<19>.
* Definitions: Definitions<9>.
* Requirements: Requirements<35>.
* Analysis: Analysis<4>.
* Interface: Interface<24>.
* Architecture: Architecture<7>.
* Implementation: Implementation<20>.
* Notes: Notes<6>.

Overview

* Why is it important to manage address space?::
* Discovering the layout::

Interface

* Loci::
* Peaks::

Architecture

* Data objects::
* Overview of strategy::
* Allocation: Allocation<3>.
* Deallocation::
* Region placement recomputation::

GC messages

* Introduction: Introduction<59>.
* Overview: Overview<20>.
* Introduction: Introduction<60>.
* Purpose: Purpose<3>.
* Names and parts::
* Lifecycle::
* Testing: Testing<7>.

Lifecycle

* Requirements: Requirements<36>.
* Storage::
* Creating and Posting::
* Getting and discarding::
* Final clearup::

Testing

* Coverage::

Debugging features for client objects

* Introduction: Introduction<61>.
* Overview: Overview<21>.
* Requirements: Requirements<37>.
* Solution ideas: Solution ideas<2>.
* Architecture: Architecture<8>.
* Client interface::
* Examples::
* Implementation: Implementation<21>.

AMC pool class

* Guide Introduction::
* Guide: Guide<2>.
* Initial design::

Guide

* Segment states::
* Pads::
* Placement pads are okay::
* Retained pads could be a problem::
* Small, medium, and large segments: Small medium and large segments.
* The LSP payoff calculation::
* Retained pages::
* Feedback about retained pages::

Initial design

* Introduction: Introduction<62>.
* Overview: Overview<22>.
* Definitions: Definitions<10>.
* Segments::
* Fixing and nailing::
* Emergency tracing::
* Buffers::
* Types: Types<9>.
* Generations::
* Ramps::
* Headers: Headers<2>.
* Old and aging notes below here::

AMS pool class

* Introduction: Introduction<63>.
* Overview: Overview<23>.
* Requirements: Requirements<38>.
* Architecture: Architecture<9>.
* Implementation: Implementation<22>.
* Testing: Testing<8>.
* Notes: Notes<7>.

Architecture

* Subclassing::
* Allocation: Allocation<4>.
* Colours::
* Scanning: Scanning<2>.

Implementation

* Colour::
* Iteration: Iteration<2>.
* Scanning Algorithm::
* Allocation: Allocation<5>.
* Initialization::
* Condemnation::
* Reclaim::
* Segment merging and splitting::

AWL pool class

* Introduction: Introduction<64>.
* Requirements: Requirements<39>.
* Definitions: Definitions<11>.
* Overview: Overview<24>.
* Interface: Interface<25>.
* Data structures: Data structures<4>.
* Functions: Functions<8>.
* Test::

Functions

* External::
* Internal::

LO pool class

* Introduction: Introduction<65>.
* Definitions: Definitions<12>.
* Requirements: Requirements<40>.
* Overview: Overview<25>.
* Interface: Interface<26>.
* Data structures: Data structures<5>.
* Functions: Functions<9>.
* Attachment::

Functions

* External: External<2>.
* Internal: Internal<2>.

MFS pool class

* Overview: Overview<26>.
* Implementation: Implementation<23>.

MRG pool class

* Introduction: Introduction<66>.
* Goals: Goals<3>.
* Requirements: Requirements<41>.
* Terminology: Terminology<2>.
* Overview: Overview<27>.
* Protocols::
* Data structures: Data structures<6>.
* Functions: Functions<10>.
* Transgressions::
* Future: Future<3>.
* Tests: Tests<2>.
* Notes: Notes<8>.

Protocols

* Object Registration::
* Finalizer execution::
* Setup / destroy::

Tests

* Functionality::
* Attributes::
* Implementation: Implementation<24>.

Manual Variable Temporal (MVT) pool design

* Introduction: Introduction<67>.
* Definitions: Definitions<13>.
* Abbreviations::
* Overview: Overview<28>.
* Requirements: Requirements<42>.
* Architecture: Architecture<10>.
* Analysis: Analysis<5>.
* Ideas::
* Implementation: Implementation<25>.
* Testing: Testing<9>.
* Text::

Requirements

* Critical requirements::
* Essential requirements::
* Nice requirements::

Ideas

* Strategy::
* Policy::
* Mechanism: Mechanism<2>.

Implementation

* Splay Tree::
* Coalescing Block Structure::
* Fail-over to address-ordered free list::
* Available Block Queue::
* Pool implementation::
* AP Dispatch::

MVFF pool class

* Introduction: Introduction<68>.
* Overview: Overview<29>.
* Methods: Methods<2>.
* Implementation: Implementation<26>.
* Details::

Protocol inheritance

* Introduction: Introduction<69>.
* Purpose: Purpose<4>.
* Requirements: Requirements<43>.
* Overview: Overview<30>.
* Interface: Interface<27>.
* Implementation: Implementation<27>.
* Common instance methods::
* References: References<23>.

Interface

* Class declaration::
* Class definition::
* Class access::
* Single inheritance::
* Specialization::
* Extension::
* Methods: Methods<3>.
* Conversion::
* Introspection::
* Protocol guidelines::
* Example: Example<3>.

POSIX thread extensions

* Introduction: Introduction<70>.
* Definitions: Definitions<14>.
* Requirements: Requirements<44>.
* Analysis: Analysis<6>.
* Interface: Interface<28>.
* Implementation: Implementation<28>.
* Attachments: Attachments<2>.
* References: References<24>.

Root manager

* Basics::
* Details: Details<2>.

Details

* Creation::
* Destruction::
* Invariants: Invariants<2>.
* Scanning: Scanning<3>.

The generic scanner

* Summaries::

Summaries

* Scanned summary::
* Partial scans::

Segment data structure

* Introduction: Introduction<71>.
* Overview: Overview<31>.
* Data Structure::
* Interface: Interface<29>.
* Extensibility::

Interface

* Splitting and merging::

Extensibility

* Allocation: Allocation<6>.
* Garbage collection: Garbage collection<2>.
* Splitting and merging: Splitting and merging<2>.

MPS Strategy

* Introduction: Introduction<72>.
* Overview: Overview<32>.
* Requirements: Requirements<45>.
* Generations: Generations<2>.
* Policy: Policy<2>.
* References: References<25>.

Generations

* General data structures::
* AMC data structures::
* Collections::
* Zones::
* Parameters::
* Accounting::
* Ramps: Ramps<2>.

Policy

* Assignment of zones::
* Deciding whether to collect the world::
* Starting a trace::
* Trace progress::

Telemetry

* Introduction: Introduction<73>.
* Overview: Overview<33>.
* Requirements: Requirements<46>.
* Architecture: Architecture<11>.
* Analysis: Analysis<7>.
* Ideas: Ideas<2>.
* Implementation: Implementation<29>.

Implementation

* Annotation::
* Registration::
* Control::
* Debugging::
* Dumper tool::
* Allocation replayer tool::

Tracer

* Introduction: Introduction<74>.
* Architecture: Architecture<12>.
* Analysis: Analysis<8>.
* Ideas: Ideas<3>.
* Implementation: Implementation<30>.
* Life cycle of a trace object::
* References: References<26>.

Implementation

* Speed::

Life cycle of a trace object

* Making progress; scanning grey segments: Making progress scanning grey segments.

Memory Management Glossary

* Memory Management Glossary; A: Memory Management Glossary A.
* Memory Management Glossary; B: Memory Management Glossary B.
* Memory Management Glossary; C: Memory Management Glossary C.
* Memory Management Glossary; D: Memory Management Glossary D.
* Memory Management Glossary; E: Memory Management Glossary E.
* Memory Management Glossary; F: Memory Management Glossary F.
* Memory Management Glossary; G: Memory Management Glossary G.
* Memory Management Glossary; H: Memory Management Glossary H.
* Memory Management Glossary; I: Memory Management Glossary I.
* Memory Management Glossary; K: Memory Management Glossary K.
* Memory Management Glossary; L: Memory Management Glossary L.
* Memory Management Glossary; M: Memory Management Glossary M.
* Memory Management Glossary; N: Memory Management Glossary N.
* Memory Management Glossary; O: Memory Management Glossary O.
* Memory Management Glossary; P: Memory Management Glossary P.
* Memory Management Glossary; Q: Memory Management Glossary Q.
* Memory Management Glossary; R: Memory Management Glossary R.
* Memory Management Glossary; S: Memory Management Glossary S.
* Memory Management Glossary; T: Memory Management Glossary T.
* Memory Management Glossary; U: Memory Management Glossary U.
* Memory Management Glossary; V: Memory Management Glossary V.
* Memory Management Glossary; W: Memory Management Glossary W.
* Memory Management Glossary; Z: Memory Management Glossary Z.
* All::

Index to source code

* External MPS interface::
* Plinth: Plinth<2>.
* Configuration::
* Core MPS::
* Platform interfaces::
* Pool classes: Pool classes<3>.
* Auxiliary programs::
* Benchmarks::
* Test support::
* Interactive test cases::
* Automated test cases::
* Build infrastructure::

Memory Pool System Kit Open Source License

* License::

Contributing to the MPS

* Review::
* Licensing::
* Thank you::

Release notes

* Release 1.118.0: Release 1 118 0.
* Release 1.117.0: Release 1 117 0.
* Release 1.116.0: Release 1 116 0.
* Release 1.115.0: Release 1 115 0.
* Release 1.114.0: Release 1 114 0.
* Release 1.113.0: Release 1 113 0.
* Release 1.112.0: Release 1 112 0.
* Release 1.111.0: Release 1 111 0.
* Release 1.110.0: Release 1 110 0.

Release 1.118.0

* New features::
* Interface changes::
* Other changes::

Release 1.117.0

* New features: New features<2>.
* Interface changes: Interface changes<2>.
* Other changes: Other changes<2>.

Release 1.116.0

* New features: New features<3>.
* Interface changes: Interface changes<3>.
* Other changes: Other changes<3>.

Release 1.115.0

* New features: New features<4>.
* Interface changes: Interface changes<4>.
* Other changes: Other changes<4>.

Release 1.114.0

* New features: New features<5>.
* Interface changes: Interface changes<5>.
* Other changes: Other changes<5>.

Release 1.113.0

* New features: New features<6>.
* Interface changes: Interface changes<6>.
* Other changes: Other changes<6>.

Release 1.112.0

* New features: New features<7>.
* Interface changes: Interface changes<7>.
* Other changes: Other changes<7>.

Release 1.111.0

* New features: New features<8>.
* Interface changes: Interface changes<8>.
* Other changes: Other changes<8>.

Release 1.110.0

* New features: New features<9>.
* Interface changes: Interface changes<9>.

Introduction to memory management

* Overview: Overview<34>.
* Allocation techniques::
* Recycling techniques::
* Memory management in various languages::

Overview

* Hardware memory management::
* Operating system memory management::
* Application memory management::
* Memory management problems::
* Manual memory management::
* Automatic memory management::
* More information::

Allocation techniques

* First fit::
* Buddy system::
* Suballocators::

Recycling techniques

* Tracing collectors::
* Reference counts::

Tracing collectors

* Mark-sweep collection::
* Copying collection::
* Incremental collection::
* Conservative garbage collection::

Reference counts

* Simple reference counting::
* Deferred reference counting::
* One-bit reference counting::
* Weighted reference counting::

Frequently Asked Questions

* C-specific questions::
* C++-specific questions::
* Common objections to garbage collection::
* Miscellaneous::

C-specific questions

* Can I use garbage collection in C?::
* Why do I need to test the return value from malloc? Surely it always succeeds?::
* What’s the point of having a garbage collector? Why not use malloc and free?::
* What’s wrong with ANSI malloc in the C library?::

C++-specific questions

* Can I use garbage collection in C++?::
* Why is delete so slow?::
* What happens if you use class libraries that leak memory?::
* Can’t I get all the benefits of garbage collection using C++ constructors and destructors?::

Common objections to garbage collection

* What languages use garbage collection?::
* What’s the advantage of garbage collection?::
* Programs with GC are huge and bloated; GC isn’t suitable for small programs or systems::
* I can’t use GC because I can’t afford to have my program pause::
* Isn’t it much cheaper to use reference counts rather than garbage collection?::
* Isn’t GC unreliable? I’ve heard that GCs often kill the program::
* I’ve heard that GC uses twice as much memory::
* Doesn’t garbage collection make programs slow?::
* Manual memory management gives me control—it doesn’t pause::

Miscellaneous

* Why does my disk rattle so much?::
* Where can I find out more about garbage collection?::
* Where can I get a garbage collector?::
* Why does my program use so much memory?::
* I use a library, and my program grows every time I call it. Why?: I use a library and my program grows every time I call it Why?.
* Should I write my own memory allocator to make my program fast?::
* Why can’t I just use local data on the stack or in global variables?::
* Why should I worry about virtual memory? Can’t I just use as much memory as I want?::



File: MemoryPoolSystem.info,  Node: Guide,  Next: Reference,  Prev: Top,  Up: Top

1 Guide
*******

* Menu:

* Overview of the Memory Pool System::
* Building the Memory Pool System::
* Garbage collecting a language with the Memory Pool System::
* The stretchy vector problem::
* Debugging with the Memory Pool System::
* Tuning the Memory Pool System for performance::
* Advanced topics::
* Implementing malloc and free::


File: MemoryPoolSystem.info,  Node: Overview of the Memory Pool System,  Next: Building the Memory Pool System,  Up: Guide

1.1 Overview of the Memory Pool System
======================================

The Memory Pool System is a very general, adaptable, flexible, reliable,
and efficient memory management system.  It permits the flexible
combination of memory management techniques, supporting *note manual: 8.
and *note automatic memory management: 9, *note inline allocation: a,
*note finalization: b, *note weakness: c, and multiple concurrent
co-operating *note incremental: d. *note generational: e. *note garbage
collections: f.  It also includes a library of *note memory pool
classes: 10. implementing specialized memory management policies.

The MPS has been in development since 1994 and deployed in successful
commercial products since 1997.  Bugs are almost unknown in production.
It is under continuous development and support by Ravenbrook(1).

The MPS is distributed under the BSD 2-clause *note open source license:
11.

* Menu:

* Supported target platforms::
* Technical introduction::
* What next?::

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/


File: MemoryPoolSystem.info,  Node: Supported target platforms,  Next: Technical introduction,  Up: Overview of the Memory Pool System

1.1.1 Supported target platforms
--------------------------------

The MPS is currently supported for deployment on:

   - Windows Vista or later, on IA-32 and x86-64, using Microsoft Visual
     C/C++;

   - Linux 2.6 or later, on IA-32 using GCC and on x86-64 or ARM64 using
     GCC or Clang/LLVM;

   - FreeBSD 7 or later, on IA-32 and x86-64, using GCC or Clang/LLVM;

   - macOS 10.4 or later, on x86-64 or ARM64, using Clang/LLVM.

The MPS is highly portable and has run on many other processors and
operating systems in the past (see *note Building the Memory Pool
System: 14.).  Most of the MPS is written in very pure ANSI C and
compiles without warnings on anything.

     Warning: If you are running a multi-threaded 32-bit application on
     64-bit Windows 7 via the WOW64 emulator, then you must install this
     hotfix from Microsoft(1).  See WOW64 bug: GetThreadContext() may
     return stale contents(2) for a description of the problem.

   ---------- Footnotes ----------

   (1) https://support.microsoft.com/kb/2864432/en-us

   (2) 
https://zachsaw.blogspot.com/2010/11/wow64-bug-getthreadcontext-may-return.html


File: MemoryPoolSystem.info,  Node: Technical introduction,  Next: What next?,  Prev: Supported target platforms,  Up: Overview of the Memory Pool System

1.1.2 Technical introduction
----------------------------

The figure below gives a simplified picture of a program’s memory from
the point of view of the Memory Pool System.

 [image src="MemoryPoolSystem-figures/overview.svg" alt="Diagram: Overview of the Memory Pool System." ]


Figure: Overview of the Memory Pool System.

The 'arena' is the top-level data structure in the MPS. An *note arena:
16. is responsible for requesting *note memory (3): 17. from the
operating system (and returning it), for making memory available to
*note pools: 18, and for *note garbage collection: f.  Multiple arenas
are supported, but it’s usually best to have only one arena in your
program, because the MPS can’t collect cyclic structures that span
multiple arenas.  See *note Arenas: 19.

The MPS is designed to co-operate with other memory managers (for
example *note malloc: 1a. and *note free (2): 1b. in *note C: 1c, or
operators ‘new’ and ‘delete’ in *note C++: 1d.), so you need not move
all your memory management to the MPS at once, and you can co-operate
with libraries that use other allocation mechanisms.

Within the arena you create one or more 'pools'.  A *note pool: 18. is
responsible for requesting memory from the *note arena: 16. and making
it available to your program.  See *note Pools: 1e.

Pools belong to 'pool classes' that specify policies for how their
memory is managed.  Some pools are *note manually managed: 8. (you must
explicitly return memory to the pool, for example by calling *note
mps_free(): 1f.) and others are *note automatically managed: 9. (the
*note garbage collector: 20. reclaims *note unreachable: 21. blocks).
See *note Pool reference: 22.

*note Formatted: 23. pools need you to tell them how to 'scan' for *note
references: 24. to allocated blocks.  See *note Scanning: 25.

The arena needs you to tell it how to find your 'roots': references to
allocated blocks that are stored in static data, in memory not managed
by the MPS, in your program’s *note registers: 26, or on its *note
control stack: 27.  See *note Roots: 28.

The MPS is designed to work with multi-threaded programs.  Functions in
the C interface are thread safe, except in a few documented cases.  See
*note Threads: 29.  The *note allocation point protocol: 2a. provides
fast lock-free allocation on multiple threads simultaneously.  See *note
Allocation: 2b.

The garbage collector is *note incremental: d.: it proceeds in small
steps interleaved with the execution of your program, so there are no
long waits.  The garbage collector is designed to work efficiently with
multiple pools, and in cases where there are many references between
objects in different pools.  See *note Garbage collection: 2c.


File: MemoryPoolSystem.info,  Node: What next?,  Prev: Technical introduction,  Up: Overview of the Memory Pool System

1.1.3 What next?
----------------

For a much more detailed technical overview of the MPS, see *note
Brooksby (2002): 2e.

If you’re going to try it out, see *note Building the Memory Pool
System: 14.

If you have a program in need of memory management, then you’ll want to
learn how to integrate it with the Memory Pool System.  See *note
Garbage collecting a language with the Memory Pool System: 2f.

If you want to know more technical details, they appear in the *note
Reference: 30.


File: MemoryPoolSystem.info,  Node: Building the Memory Pool System,  Next: Garbage collecting a language with the Memory Pool System,  Prev: Overview of the Memory Pool System,  Up: Guide

1.2 Building the Memory Pool System
===================================

* Menu:

* Introduction::
* Getting hold of the MPS Kit::
* Compiling the MPS for your project::
* Building the MPS manual::
* Building the MPS for development::
* Installing the Memory Pool System::


File: MemoryPoolSystem.info,  Node: Introduction,  Next: Getting hold of the MPS Kit,  Up: Building the Memory Pool System

1.2.1 Introduction
------------------

This document describes the various ways in which you can build the MPS,
its manual, its libraries, and the tests and tools that come with it.

You may be building the MPS for a number of different purposes.


File: MemoryPoolSystem.info,  Node: Getting hold of the MPS Kit,  Next: Compiling the MPS for your project,  Prev: Introduction,  Up: Building the Memory Pool System

1.2.2 Getting hold of the MPS Kit
---------------------------------

Download the latest MPS Kit release from
‘https://www.ravenbrook.com/project/mps/release/’.


File: MemoryPoolSystem.info,  Node: Compiling the MPS for your project,  Next: Building the MPS manual,  Prev: Getting hold of the MPS Kit,  Up: Building the Memory Pool System

1.2.3 Compiling the MPS for your project
----------------------------------------

It is easy to compile the MPS. You can do it separately, or include the
source in your own project’s build system.  This section describes
compilation in terms of command lines, but you can equally add the files
to a project in an IDE.

The MPS also comes with Makefiles and IDE project files for building
libraries, tools, and tests.  See “Building the MPS for development”.

* Menu:

* Compiling for production::
* Compiling for debugging::
* Optimizing for your object format::
* Compiling without the C library::


File: MemoryPoolSystem.info,  Node: Compiling for production,  Next: Compiling for debugging,  Up: Compiling the MPS for your project

1.2.3.1 Compiling for production
................................

In the simplest case, you can compile the MPS to an object file with
just:

     cc -c mps.c           (Unix/macOS)
     cl /c mps.c           (Windows)

This will build a “hot” variety (for production) object file for use
with ‘mps.h’.  You can greatly improve performance by allowing global
optimization, for example:

     cc -O2 -c mps.c       (Unix/macOS)
     cl /O2 /c mps.c       (Windows)


File: MemoryPoolSystem.info,  Node: Compiling for debugging,  Next: Optimizing for your object format,  Prev: Compiling for production,  Up: Compiling the MPS for your project

1.2.3.2 Compiling for debugging
...............................

You can get a “cool” variety MPS (with more internal checking, for
debugging and development) with:

     cc -g -DCONFIG_VAR_COOL -c mps.c    (Unix/macOS)
     cl /Zi /DCONFIG_VAR_COOL /c mps.c   (Windows)


File: MemoryPoolSystem.info,  Node: Optimizing for your object format,  Next: Compiling without the C library,  Prev: Compiling for debugging,  Up: Compiling the MPS for your project

1.2.3.3 Optimizing for your object format
.........................................

If you are using your own *note object format: 39, you will also get
improved performance by allowing the compiler to do global optimizations
between it and the MPS. So if your format implementation is in, say,
‘myformat.c’, then you could make a file ‘mymps.c’ containing:

     #include "mps.c"
     #include "myformat.c"

then:

     cc -O2 -c mymps.c     (Unix/macOS)
     cl /O2 /c mymps.c     (Windows)

This will get your format code inlined with the MPS garbage collector.


File: MemoryPoolSystem.info,  Node: Compiling without the C library,  Prev: Optimizing for your object format,  Up: Compiling the MPS for your project

1.2.3.4 Compiling without the C library
.......................................

If you’re building the MPS for an environment without the standard C
library, you can exclude *note the plinth: 3b. component of the MPS
with:

     cc -DCONFIG_PLINTH_NONE -c mps.c
     cl /Gs /DCONFIG_PLINTH_NONE /c mps.c

but you must then provide your own implementation of ‘mpslib.h’.  You
can base this on the ANSI plinth in ‘mpsliban.c’.

If you want to do anything beyond these simple cases, use the MPS build
as described in the section “Building the MPS for development” below.


File: MemoryPoolSystem.info,  Node: Building the MPS manual,  Next: Building the MPS for development,  Prev: Compiling the MPS for your project,  Up: Building the Memory Pool System

1.2.4 Building the MPS manual
-----------------------------

Builds of the MPS manual from the main MPS repo should be available at
‘https://memory-pool-system.readthedocs.io/’.

If that’s not available, or if you have a variant of the MPS Kit, or are
making modifications to the MPS itself, then you should build the manual
for yourself.  This uses Sphinx ‘https://www.sphinx-doc.org/’.

On Unix-like platforms (including macOS), the Makefile in the manual
directory can fetch and install a local copy of Sphinx and build the
manual, like this:

     cd manual
     make html

then open manual/html/index.html.

On Windows platforms, follow the Sphinx installation instructions(1) for
Windows, then invoke Sphinx as shown in the Makefile in the manual
directory.

   ---------- Footnotes ----------

   (1) https://www.sphinx-doc.org/en/master/usage/installation.html


File: MemoryPoolSystem.info,  Node: Building the MPS for development,  Next: Installing the Memory Pool System,  Prev: Building the MPS manual,  Up: Building the Memory Pool System

1.2.5 Building the MPS for development
--------------------------------------

If you’re making modifications to the MPS itself, want to build MPS
libraries for linking, or want to build MPS tests and tools, you should
use the MPS build.  This uses makefiles or Xcode projects.

* Menu:

* Prerequisites::
* Platforms::
* Running make::


File: MemoryPoolSystem.info,  Node: Prerequisites,  Next: Platforms,  Up: Building the MPS for development

1.2.5.1 Prerequisites
.....................

For Unix-like platforms you will need the GNU Make tool.  Some platforms
(such as Linux) have GNU Make as their default make tool.  For others
you will need to get and install it.  (It’s available free from
‘ftp://ftp.gnu.org/gnu/make/’.)  On FreeBSD this can be done as root
with ‘pkg_add -r gmake’.

On Windows platforms the NMAKE tool is used.  This comes with Microsoft
Visual Studio C++ or the Microsoft Windows SDK.

On macOS the MPS is built using Xcode, either by opening ‘mps.xcodeproj’
with the Xcode app, or using the command-line “xcodebuild” tool,
installed from Xcode → Preferences → Downloads → Components → Command
Line Tools.


File: MemoryPoolSystem.info,  Node: Platforms,  Next: Running make,  Prev: Prerequisites,  Up: Building the MPS for development

1.2.5.2 Platforms
.................

The MPS uses a six-character platform code to express a combination of
operating system, CPU architecture, and compiler toolchain.  Each
six-character code breaks down into three pairs of characters, like
this:

     OSARCT

Where ‘OS’ denotes the operating system, ‘AR’ the CPU architecture, and
‘CT’ the compiler toolchain.  Here are the platforms that we have
regular access to and on which the MPS works well:

Platform       OS            Architecture      Compiler         Makefile
                                                                
--------------------------------------------------------------------------------------
                                                                
‘fri3gc’       FreeBSD       IA-32             GCC              ‘fri3gc.gmk’
                                                                
                                                                
‘fri3ll’       FreeBSD       IA-32             Clang            ‘fri3ll.gmk’
                                                                
                                                                
‘fri6gc’       FreeBSD       x86-64            GCC              ‘fri6gc.gmk’
                                                                
                                                                
‘fri6ll’       FreeBSD       x86-64            Clang            ‘fri6ll.gmk’
                                                                
                                                                
‘lia6gc’       Linux         ARM64             GCC              ‘lia6gc.gmk’
                                                                
                                                                
‘lia6ll’       Linux         ARM64             Clang            ‘lia6ll.gmk’
                                                                
                                                                
‘lii3gc’       Linux         IA-32             GCC              ‘lii3gc.gmk’
                                                                
                                                                
‘lii6gc’       Linux         x86-64            GCC              ‘lii6gc.gmk’
                                                                
                                                                
‘lii6ll’       Linux         x86-64            Clang            ‘lii6ll.gmk’
                                                                
                                                                
‘w3i3mv’       Windows       IA-32             Microsoft C      ‘w3i3mv.nmk’
                                                                
                                                                
‘w3i6mv’       Windows       x86-64            Microsoft C      ‘w3i6mv.nmk’
                                                                
                                                                
‘xca6ll’       macOS         ARM64             Clang            ‘mps.xcodeproj’
                                                                
                                                                
‘xci6ll’       macOS         x86-64            Clang            ‘mps.xcodeproj’
                                                                

Historically, the MPS worked on a much wider variety of platforms, and
still could: IRIX, OSF/1 (Tru64), Solaris, SunOS, Classic Mac OS; MIPS,
PowerPC, ALPHA, SPARC v8, SPARC v9; Metrowerks Codewarrior, SunPro C,
Digital C, EGCS, Pelles C. If you are interested in support on any of
these platforms or any new platforms, please contact Ravenbrook at
<mps-questions@ravenbrook.com>.


File: MemoryPoolSystem.info,  Node: Running make,  Prev: Platforms,  Up: Building the MPS for development

1.2.5.3 Running make
....................

To build all MPS targets on Unix-like platforms, change to the ‘code’
directory and run the command:

     make -f <makefile>

where ‘make’ is the command for GNU Make.  (Sometimes this will be
‘gmake’ or ‘gnumake’.)

To build just one target, run:

     make -f <makefile> <target>

To build a restricted set of targets for just one variety, run:

     make -f <makefile> 'VARIETY=<variety>' <target>

For example, to build just the “cool” variety of the ‘amcss’ test on
64-bit Linux with Clang:

     gmake -f lii6ll.gmk VARIETY=cool amcss

On Windows platforms you need to run the “Visual Studio Command Prompt”
from the Start menu.  Then run one of these commands:

     nmake /f w3i3mv.nmk         (32-bit)
     nmake /f w3i6mv.nmk         (64-bit)

You will need to switch your build environment between 32-bit and 64-bit
using Microsoft’s ‘setenv’ command, for example, ‘setenv /x86’ or
‘setenv /x64’.

To build just one target, run one of these commands:

     nmake /f w3i3mv.nmk <target>         (32-bit)
     nmake /f w3i6mv.nmk <target>         (64-bit)

On macOS (64-bit only), you can build from the command line with:

     xcodebuild

On most platforms, the output of the build goes to a directory named
after the platform (e.g.  ‘lii6ll’) so that you can share the source
tree across platforms.  On macOS the output goes in a directory called
‘xc’.  Building generates ‘mps.a’ or ‘mps.lib’ or equivalent, a library
of object code which you can link with your application, subject to the
*note MPS licensing conditions: 11.  It also generates a number of test
programs, such as ‘amcss’ (a stress test for the Automatic
Mostly-Copying pool class) and tools such as ‘mpseventcnv’ (for decoding
telemetry logs).


File: MemoryPoolSystem.info,  Node: Installing the Memory Pool System,  Prev: Building the MPS for development,  Up: Building the Memory Pool System

1.2.6 Installing the Memory Pool System
---------------------------------------

Unix-like platforms can use the GNU Autoconf ‘configure’ script in the
root directory of the MPS Kit to generate a Makefile that can build and
install the MPS. For example:

     ./configure --prefix=/opt/mps
     make install

will install the MPS public headers in ‘/opt/mps/include’, the libraries
in ‘/opt/mps/lib’ etc.

There is currently no automatic way to “install” the MPS on Windows.

On any platform, you can install by copying the libraries built by the
make to, for example, ‘/usr/local/lib’, and all the headers beginning
with ‘mps’ to ‘/usr/local/include’.

Note, however, that you may get better performance by using the method
described in the section “Optimizing for your object format” above.

* Menu:

* mpseventsql::


File: MemoryPoolSystem.info,  Node: mpseventsql,  Up: Installing the Memory Pool System

1.2.6.1 mpseventsql
...................

The MPS Kit can build a command-line program ‘mpseventsql’ that loads a
diagnostic stream of events into a SQLite3(1) database for processing.
In order to build this program, you need to install the SQLite3
development resources.

   * On macOS, SQLite3 is pre-installed, so this tool builds by default.

   * On Linux, you need to install the ‘libsqlite3-dev’ package:

          apt-get install libsqlite3-dev

     and then re-run ‘./configure’ and ‘make’ as described above.

   * On FreeBSD, you need to build and install the ‘databases/sqlite3’
     port from the ports collection:

          cd /usr/ports/databases/sqlite3
          make install clean

     and then re-run ‘./configure’ and ‘make’ as described above.

   * On Windows, you should visit the SQLite Download Page(2) and
     download the ‘sqlite-amalgamation’ ZIP archive.  (At time of
     writing this is the first download on the page.)  When you unzip
     the archive, you’ll find it contains files named ‘sqlite3.c’ and
     ‘sqlite3.h’.  Copy these two files into the ‘code’ directory in the
     MPS Kit.  Then in the “Visual Studio Command Prompt”, visit the
     ‘code’ directory and run one of these commands:

          nmake /f w3i3mv.nmk mpseventsql.exe         (32-bit)
          nmake /f w3i6mv.nmk mpseventsql.exe         (64-bit)

   ---------- Footnotes ----------

   (1) http://www.sqlite.org/

   (2) http://www.sqlite.org/download.html


File: MemoryPoolSystem.info,  Node: Garbage collecting a language with the Memory Pool System,  Next: The stretchy vector problem,  Prev: Building the Memory Pool System,  Up: Guide

1.3 Garbage collecting a language with the Memory Pool System
=============================================================

Have you written the lexer, parser, code generator and the runtime
system for your programming language, and come to the realization that
you are going to need a memory manager too?  If so, you’ve come to the
right place.

In this guide, I’ll explain how to use the MPS to add incremental,
moving, generational garbage collection to the runtime system for a
programming language.

I’m assuming that you are familiar with the overall architecture of the
MPS (see the chapter *note Overview of the Memory Pool System: 6.) and
that you’ve downloaded and built the MPS (see the chapter *note Building
the Memory Pool System: 14.).

* Menu:

* The Scheme interpreter::
* Choosing an arena class::
* Choosing a pool class::
* Describing your objects::
* Creating the pool::
* Roots::
* Threads::
* Allocation::
* Maintaining consistency::
* Tidying up::
* What next?: What next?<2>.


File: MemoryPoolSystem.info,  Node: The Scheme interpreter,  Next: Choosing an arena class,  Up: Garbage collecting a language with the Memory Pool System

1.3.1 The Scheme interpreter
----------------------------

As a running example throughout this guide, I’ll be using a small
interpreter for a subset of the *note Scheme: 46. programming language.
I’ll be quoting the relevant sections of code as needed, but you may
find it helpful to experiment with this interpreter yourself, in either
of its versions:

‘scheme-malloc.c’

     The toy Scheme interpreter before integration with the MPS, using
     *note malloc: 1a. and *note free (2): 1b. for memory management.

‘scheme.c’

     The toy Scheme interpreter after integration with the MPS.

This simple interpreter allocates two kinds of objects on the *note
heap: 47.:

  1. All Scheme objects (there are no *note unboxed: 48. objects).

  2. The global symbol table: a hash table consisting of a vector of
     pointers to strings.

A Scheme object (whose type is not necessarily known) is represented by
an ‘obj_t’, which is a pointer to a union of every type in the language:

     typedef union obj_u *obj_t;
     typedef union obj_u {
         type_s type;
         pair_s pair;
         symbol_s symbol;
         integer_s integer;
         special_s special;
         operator_s operator;
         string_s string;
         port_s port;
         character_s character;
         vector_s vector;
         table_s table;
         buckets_s buckets;
     } obj_s;

Each of these types is a structure whose first word is a number
specifying the type of the object (‘TYPE_PAIR’ for pairs, ‘TYPE_SYMBOL’
for symbols, and so on).  For example, pairs are represented by a
pointer to the structure ‘pair_s’ defined as follows:

     typedef struct pair_s {
         type_t type;        /* TYPE_PAIR */
         obj_t car, cdr;     /* first and second projections */
     } pair_s;

Because the first word of every object is its type, functions can
operate on objects generically, testing ‘TYPE(obj)’ as necessary (which
is a macro for ‘obj->type.type’).  For example, the ‘print’ function is
implemented like this:

     static void print(obj_t obj, unsigned depth, FILE *stream)
     {
         switch (TYPE(obj)) {
         case TYPE_INTEGER:
             fprintf(stream, "%ld", obj->integer.integer);
             break;

         case TYPE_SYMBOL:
             fputs(obj->symbol.string, stream);
             break;

         /* ... and so on for the other types ... */
         }
     }

Each constructor allocates memory for the new object by calling
‘malloc()’.  For example, ‘make_pair()’ is the constructor for pairs:

     static obj_t make_pair(obj_t car, obj_t cdr)
     {
         obj_t obj = (obj_t)malloc(sizeof(pair_s));
         if (obj == NULL) error("out of memory");
         obj->pair.type = TYPE_PAIR;
         CAR(obj) = car;
         CDR(obj) = cdr;
         return obj;
     }

Objects are never freed, because it is necessary to prove that they are
*note dead: 49. before their memory can be *note reclaimed: 4a.  To
prove that they are dead, we need a *note tracing: 4b. *note garbage
collector: 20, which the MPS will provide.


File: MemoryPoolSystem.info,  Node: Choosing an arena class,  Next: Choosing a pool class,  Prev: The Scheme interpreter,  Up: Garbage collecting a language with the Memory Pool System

1.3.2 Choosing an arena class
-----------------------------

You’ll recall from the *note Overview of the Memory Pool System: 6. that
the functionality of the MPS is divided between the *note arenas: 16,
which request memory from (and return it to) the operating system, and
*note pools: 18, which allocate blocks of memory for your program.

There are two main classes of arena: the *note client arena: 4d, *note
mps_arena_class_cl(): 4e, which gets its memory from your program, and
the *note virtual memory arena: 4f, *note mps_arena_class_vm(): 50,
which gets its memory from the operating system’s *note virtual memory:
51. interface.

The client arena is intended for use on embedded systems where there is
no virtual memory, and has a couple of disadvantages (you have to decide
how much memory you are going to use; and the MPS can’t return memory to
the operating system for use by other processes) so for general-purpose
programs you’ll want to use the virtual memory arena.

You’ll need a couple of headers: ‘mps.h’ for the MPS interface, and
‘mpsavm.h’ for the virtual memory arena class:

     #include "mps.h"
     #include "mpsavm.h"

There’s only one arena, and many MPS functions take an arena as an
argument, so it makes sense for the arena to be a global variable rather
than having to pass it around everywhere:

     static mps_arena_t arena;

Create an arena by calling *note mps_arena_create_k(): 52.  This
function takes a *note keyword argument: 53. when creating a virtual
memory arena: the size of virtual *note address space: 54. ('not' *note
RAM: 55.), in bytes, that the arena will reserve initially.  The MPS
will ask for more address space if it runs out, but the more times it
has to extend its address space, the less efficient garbage collection
will become.  The MPS works best if you reserve an address space that is
several times larger than your peak memory usage.

     Note: Functions in the MPS interface take *note keyword arguments:
     53. for arguments that are optional, or are only required in some
     circumstances.  These argument are passed in the form of an array
     of structures of type *note mps_arg_s: 56.  See *note Keyword
     arguments: 57. for the full details.

Let’s reserve 32 megabytes:

     mps_res_t res;
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_ARENA_SIZE, 32 * 1024 * 1024);
         res = mps_arena_create_k(&arena, mps_arena_class_vm(), args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create arena");

*note mps_arena_create_k(): 52. is typical of functions in the MPS
interface in that it stores its result in a location pointed to by an
*note out parameter: 58. (here, ‘&arena’) and returns a *note result
code: 59, which is *note MPS_RES_OK: 5a. if the function succeeded, or
some other value if it failed.

     Note: The MPS is designed to co-operate with other memory managers,
     so when integrating your language with the MPS you need not feel
     obliged to move all your memory management to the MPS: you can
     continue to use ‘malloc()’ and ‘free()’ to manage some of your
     memory, for example, while using the MPS for the rest.

     The toy Scheme interpreter illustrates this by continuing to use
     ‘malloc()’ and ‘free()’ to manage its global symbol table.

*note Arenas: 19, *note Error handing: 5b.


File: MemoryPoolSystem.info,  Node: Choosing a pool class,  Next: Describing your objects,  Prev: Choosing an arena class,  Up: Garbage collecting a language with the Memory Pool System

1.3.3 Choosing a pool class
---------------------------

Pool classes come with a policy for how their memory will be managed:
some pool classes use *note automatic memory management: 9. and others
use *note manual: 8.; some use *note moving collection: 5d. and others
*note non-moving: 5e.

The section *note Choosing a pool class: 5f. in the *note Pool
reference: 22. contains a procedure for choosing a pool class.  In the
case of the toy Scheme interpreter, the answers to the questions are (1)
yes, the MPS needs to automatically reclaim unreachable blocks; (2) yes,
it’s acceptable for the MPS to move blocks in memory and protect them
with *note barriers (1): 60.; and (3) the Scheme objects will contain
*note exact references: 61. to other Scheme objects in the same pool.

The recommended class is *note AMC (Automatic Mostly-Copying): 62.  This
pool class uses automatic memory management, moving garbage collection,
*note allocation points: 63. and *note formatted objects: 23, so it will
provide an introduction to these features of the MPS.

     Note: The MPS is designed for pools of different classes to
     co-exist in the same arena, so that objects requiring different
     memory management policies can be segregated into pools of suitable
     classes.

*note Pools: 1e.


File: MemoryPoolSystem.info,  Node: Describing your objects,  Next: Creating the pool,  Prev: Choosing a pool class,  Up: Garbage collecting a language with the Memory Pool System

1.3.4 Describing your objects
-----------------------------

In order for the MPS to be able to automatically manage your objects,
you need to tell it how to perform various operations on an object
(*note scan: 65. it for *note references: 24.; replace it with a *note
forwarding: 66. or *note padding object: 67, and so on).  You do this by
creating an *note object format: 39.  Here’s the code for creating the
object format for the toy Scheme interpreter:

     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_FMT_ALIGN, ALIGNMENT);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_SCAN, obj_scan);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_SKIP, obj_skip);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_FWD, obj_fwd);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_ISFWD, obj_isfwd);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_PAD, obj_pad);
         res = mps_fmt_create_k(&obj_fmt, arena, args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create obj format");

The keyword arguments specify the *note alignment: 68. and the *note
format methods: 69. required by the AMC pool class.  These are described
in the following sections.

*note Object formats: 6a.

* Menu:

* Alignment::
* The scan method::
* The skip method::
* The forward method::
* The is-forwarded method::
* The padding method::


File: MemoryPoolSystem.info,  Node: Alignment,  Next: The scan method,  Up: Describing your objects

1.3.4.1 Alignment
.................

The argument for the keyword ‘MPS_KEY_FMT_ALIGN’ is the *note alignment:
68. of objects belonging to this format.  Determining the alignment is
hard to do portably, because it depends on the target architecture and
on the way the compiler lays out its structures in memory.  Here are
some things you might try:

  1. Some modern compilers support the ‘alignof’ operator:

          #define ALIGNMENT alignof(obj_s)

  2. On older compilers you may be able to use this trick:

          #define ALIGNMENT offsetof(struct {char c; obj_s obj;}, obj)

     but this is not reliable because some compilers pack structures
     more tightly than their alignment requirements in some
     circumstances (for example, GCC if the ‘-fstruct-pack’ option is
     specified).

  3. The MPS interface provides the type *note mps_word_t: 6d, which is
     an unsigned integral type that is the same size as the platform’s
     *note object pointer: 6e. types.

     So if you know that all your objects can be word-aligned, you can
     use:

          #define ALIGNMENT sizeof(mps_word_t)

  4. The MPS interface provides the type *note MPS_PF_ALIGN: 6f, which
     is the *note natural alignment: 70. of the platform: the largest
     alignment that might be required.  So as a last resort, you can
     use:

          #define ALIGNMENT MPS_PF_ALIGN

     But this may be larger than necessary and so waste space.  For
     example, on Windows on x86-64, *note MPS_PF_ALIGN: 6f. is 16 bytes,
     but this is only necessary for SSE(1) types; ordinary types on this
     platform require no more than 8-byte alignment.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions


File: MemoryPoolSystem.info,  Node: The scan method,  Next: The skip method,  Prev: Alignment,  Up: Describing your objects

1.3.4.2 The scan method
.......................

The *note scan method: 73. is a function of type *note mps_fmt_scan_t:
74.  It is called by the MPS to *note scan: 65. a block of memory.  Its
task is to identify all references within the objects in the block of
memory, and “fix” them, by calling the macros *note MPS_FIX1(): 75. and
*note MPS_FIX2(): 76. on each reference (possibly via the convenience
macro *note MPS_FIX12(): 77.).

“Fixing” is a generic operation whose effect depends on the context in
which the scan method was called.  The scan method is called to discover
references and so determine which objects are *note alive: 78. and which
are *note dead: 49, and also to update references after objects have
been moved.

Here’s the scan method for the toy Scheme interpreter:

     static mps_res_t obj_scan(mps_ss_t ss, mps_addr_t base, mps_addr_t limit)
     {
         MPS_SCAN_BEGIN(ss) {
             while (base < limit) {
                 obj_t obj = base;
                 switch (TYPE(obj)) {
                 case TYPE_PAIR:
                     FIX(CAR(obj));
                     FIX(CDR(obj));
                     base = (char *)base + ALIGN_OBJ(sizeof(pair_s));
                     break;
                 case TYPE_INTEGER:
                     base = (char *)base + ALIGN_OBJ(sizeof(integer_s));
                     break;
                 /* ... and so on for the other types ... */
                 default:
                     assert(0);
                     fprintf(stderr, "Unexpected object on the heap\n");
                     abort();
                 }
             }
         } MPS_SCAN_END(ss);
         return MPS_RES_OK;
     }

The scan method receives a *note scan state: 79. (‘ss’) argument, and
the block of memory to scan, from ‘base’ (inclusive) to ‘limit’
(exclusive).  This block of memory is known to be packed with objects
belonging to the object format, and so the scan method loops over the
objects in the block, dispatching on the type of each object, and then
updating ‘base’ to point to the next object in the block.

For each reference in an object ‘obj_scan()’ fixes it by calling *note
MPS_FIX12(): 77. via the macro ‘FIX()’, which is defined as follows:

     #define FIX(ref)                                                        \
         do {                                                                \
             mps_addr_t _addr = (ref); /* copy to local to avoid type pun */ \
             mps_res_t res = MPS_FIX12(ss, &_addr);                          \
             if (res != MPS_RES_OK) return res;                              \
             (ref) = _addr;                                                  \
         } while (0)

Each call to *note MPS_FIX12(): 77. must appear between calls to the
macros *note MPS_SCAN_BEGIN(): 7a. and *note MPS_SCAN_END(): 7b.  It’s
usually most convenient to call *note MPS_SCAN_BEGIN(): 7a. at the start
of the function and *note MPS_SCAN_END(): 7b. at the end, as here.

     Note: 
       1. When the MPS calls your scan method, it may be part-way
          through moving your objects.  It is therefore essential that
          the scan method only examine objects in the range of addresses
          it is given.  Objects in other ranges of addresses are not
          guaranteed to be in a consistent state.

       2. Scanning is an operation on the *note critical path: 7c. of
          the MPS, which means that it is important that it runs as
          quickly as possible.

       3. If your reference is *note tagged: 7d, you must remove the tag
          before fixing it.  (This is not quite true, but see *note
          Tagged references: 7e. for the full story.)

       4. The “fix” operation may update the reference.  So if your
          reference is tagged, you must make sure that the tag is
          restored after the reference is updated.

       5. The “fix” operation may fail by returning a *note result code:
          59. other than *note MPS_RES_OK: 5a.  A scan function must
          propagate such a result code to the caller, and should do so
          as soon as practicable.

*note Object formats: 6a, *note Scanning: 25.


File: MemoryPoolSystem.info,  Node: The skip method,  Next: The forward method,  Prev: The scan method,  Up: Describing your objects

1.3.4.3 The skip method
.......................

The *note skip method: 81. is a function of type *note mps_fmt_skip_t:
82.  It is called by the MPS to skip over an object belonging to the
format, and also to determine its size.

Here’s the skip method for the toy Scheme interpreter:

     static mps_addr_t obj_skip(mps_addr_t base)
     {
         obj_t obj = base;
         switch (TYPE(obj)) {
         case TYPE_PAIR:
             base = (char *)base + ALIGN_OBJ(sizeof(pair_s));
             break;
         case TYPE_INTEGER:
             base = (char *)base + ALIGN_OBJ(sizeof(integer_s));
             break;
         /* ... and so on for the other types ... */
         default:
             assert(0);
             fprintf(stderr, "Unexpected object on the heap\n");
             abort();
         }
         return base;
     }

The argument ‘base’ is the address to the base of the object.  The skip
method must return the address of the base of the “next object”: in
formats of variant A like this one, this is the address just past the
end of the object, rounded up to the object format’s alignment.

*note Object formats: 6a.


File: MemoryPoolSystem.info,  Node: The forward method,  Next: The is-forwarded method,  Prev: The skip method,  Up: Describing your objects

1.3.4.4 The forward method
..........................

The *note forward method: 85. is a function of type *note mps_fmt_fwd_t:
86.  It is called by the MPS after it has moved an object, and its task
is to replace the old object with a *note forwarding object: 66.
pointing to the new location of the object.

 [image src="MemoryPoolSystem-figures/copying.svg" alt="Diagram: Copying garbage collection." ]


Figure: Copying garbage collection.

The forwarding object must satisfy these properties:

  1. It must be scannable and skippable, and so it will need to have a
     type field to distinguish it from other Scheme objects.

  2. It must contain a pointer to the new location of the object (a
     *note forwarding pointer: 87.).

  3. It must be the same size as the old object.  This means that the
     *note scan method: 71. and the *note skip method: 7f. will both
     need to know the length of the forwarding object.  This can be
     arbitrarily long (in the case of string objects, for example) so it
     must contain a length field.

This poses a problem, because the above analysis suggests that
forwarding objects need to contain at least three words, but Scheme
objects might be as small as two words (for example, integers).

This conundrum can be solved by having two types of forwarding object.
The first type is suitable for forwarding objects of three words or
longer:

     typedef struct fwd_s {
         type_t type;                  /* TYPE_FWD */
         obj_t fwd;                    /* forwarded object */
         size_t size;                  /* total size of this object */
     } fwd_s;

while the second type is suitable for forwarding objects of two words:

     typedef struct fwd2_s {
         type_t type;                  /* TYPE_FWD2 */
         obj_t fwd;                    /* forwarded object */
     } fwd2_s;

Here’s the forward method for the toy Scheme interpreter:

     static void obj_fwd(mps_addr_t old, mps_addr_t new)
     {
         obj_t obj = old;
         mps_addr_t limit = obj_skip(old);
         size_t size = (char *)limit - (char *)old;
         assert(size >= ALIGN_WORD(sizeof(fwd2_s)));
         if (size == ALIGN_WORD(sizeof(fwd2_s))) {
             TYPE(obj) = TYPE_FWD2;
             obj->fwd2.fwd = new;
         } else {
             TYPE(obj) = TYPE_FWD;
             obj->fwd.fwd = new;
             obj->fwd.size = size;
         }
     }

The argument ‘old’ is the old address of the object, and ‘new’ is the
location to which it has been moved.

The forwarding objects must be scannable and skippable, so the following
code must be added to ‘obj_scan()’ and ‘obj_skip()’:

     case TYPE_FWD:
         base = (char *)base + ALIGN_WORD(obj->fwd.size);
         break;
     case TYPE_FWD2:
         base = (char *)base + ALIGN_WORD(sizeof(fwd2_s));
         break;

     Note: Objects that consist of a single word present a problem for
     the design of the forwarding object.  In the toy Scheme
     interpreter, this happens on some 64-bit platforms, where a pointer
     is 8 bytes long, and a ‘character_s’ object (which consists of a
     4-byte ‘int’ and a 1-byte ‘char’) is also 8 bytes long.

     There are a couple of solutions to this problem:

       1. Allocate the small objects with enough padding so that they
          can be forwarded.  (This is how the problem is solved in the
          toy Scheme interpreter.)

       2. Use a *note tag: 88. to distinguish between the client object
          and a forwarding object that replaces it.  It might help to
          allocate the small objects in their own pool so that the
          number of types that the scan method has to distinguish is
          minimized.  Since these objects do not contain references,
          they could be allocated from the *note AMCZ (Automatic
          Mostly-Copying Zero-rank): 89. pool, and so the cost of
          scanning them could be avoided.

*note Object formats: 6a.


File: MemoryPoolSystem.info,  Node: The is-forwarded method,  Next: The padding method,  Prev: The forward method,  Up: Describing your objects

1.3.4.5 The is-forwarded method
...............................

The *note is-forwarded method: 8c. is a function of type *note
mps_fmt_isfwd_t: 8d.  It is called by the MPS to determine if an object
is a *note forwarding object: 66, and if it is, to determine the
location where that object was moved.

Here’s the is-forwarded method for the toy Scheme interpreter:

     static mps_addr_t obj_isfwd(mps_addr_t addr)
     {
         obj_t obj = addr;
         switch (TYPE(obj)) {
         case TYPE_FWD2:
             return obj->fwd2.fwd;
         case TYPE_FWD:
             return obj->fwd.fwd;
         }
         return NULL;
     }

It receives the address of an object, and returns the address to which
that object was moved, or ‘NULL’ if the object was not moved.

*note Object formats: 6a.


File: MemoryPoolSystem.info,  Node: The padding method,  Prev: The is-forwarded method,  Up: Describing your objects

1.3.4.6 The padding method
..........................

The *note padding method: 90. is a function of type *note mps_fmt_pad_t:
91.  It is called by the MPS to fill a block of memory with a *note
padding object: 67.: this is an object that fills gaps in a block of
*note formatted objects: 23, for example to enable the MPS to pack
objects into fixed-size units (such as operating system *note pages:
92.).

A padding object must be scannable and skippable, and not confusable
with a *note forwarding object: 66.  This means they need a type and a
size.  However, padding objects might need to be as small as the
alignment of the object format, which was specified to be a single word.
As with forwarding objects, this can be solved by having two types of
padding object.  The first type is suitable for padding objects of two
words or longer:

     typedef struct pad_s {
         type_t type;                  /* TYPE_PAD */
         size_t size;                  /* total size of this object */
     } pad_s;

while the second type is suitable for padding objects consisting of a
single word:

     typedef struct pad1_s {
         type_t type;                  /* TYPE_PAD1 */
     } pad1_s;

Here’s the padding method:

     static void obj_pad(mps_addr_t addr, size_t size)
     {
         obj_t obj = addr;
         assert(size >= ALIGN_OBJ(sizeof(pad1_s)));
         if (size == ALIGN_OBJ(sizeof(pad1_s))) {
             TYPE(obj) = TYPE_PAD1;
         } else {
             TYPE(obj) = TYPE_PAD;
             obj->pad.size = size;
         }
     }

The argument ‘addr’ is the address at which the padding object must be
created, and ‘size’ is its size in bytes: this will always be a multiple
of the alignment of the object format.

The padding objects must be scannable and skippable, so the following
code must be added to ‘obj_scan()’ and ‘obj_skip()’:

     case TYPE_PAD:
         base = (char *)base + ALIGN_OBJ(obj->pad.size);
         break;
     case TYPE_PAD1:
         base = (char *)base + ALIGN_OBJ(sizeof(pad1_s));
         break;

*note Object formats: 6a.


File: MemoryPoolSystem.info,  Node: Creating the pool,  Next: Roots,  Prev: Describing your objects,  Up: Garbage collecting a language with the Memory Pool System

1.3.5 Creating the pool
-----------------------

Now you know enough to create an *note AMC (Automatic Mostly-Copying):
62. pool!  Let’s review the pool creation code.  First, the header for
the AMC pool class:

     #include "mpscamc.h"

Second, the *note object format: 39.:

     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_FMT_ALIGN, ALIGNMENT);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_SCAN, obj_scan);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_SKIP, obj_skip);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_FWD, obj_fwd);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_ISFWD, obj_isfwd);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_PAD, obj_pad);
         res = mps_fmt_create_k(&obj_fmt, arena, args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create obj format");

And finally the *note pool: 18.:

     mps_pool_t obj_pool;
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_FORMAT, obj_fmt);
         res = mps_pool_create_k(&obj_pool, arena, mps_class_amc(), args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create obj pool");


File: MemoryPoolSystem.info,  Node: Roots,  Next: Threads,  Prev: Creating the pool,  Up: Garbage collecting a language with the Memory Pool System

1.3.6 Roots
-----------

The *note object format: 39. tells the MPS how to find *note references:
24. from one object to another.  This allows the MPS to extrapolate the
reachability property: if object 'A' is *note reachable: 96, and the
*note scan method: 73. fixes a reference from 'A' to another object 'B',
then 'B' is reachable too.

But how does this process get started?  How does the MPS know which
objects are reachable 'a priori'?  Such objects are known as *note
roots: 97, and you must register them with the MPS, creating root
descriptions of type *note mps_root_t: 98.

The most important root consists of the contents of the *note registers:
26. and the *note control stack: 27. of each *note thread: 99. in your
program: this is covered in *note Threads: 9a, below.

Other roots may be found in static variables in your program, or in
memory allocated by other memory managers.  For these roots you must
describe to the MPS how to *note scan: 65. them for references.

The toy Scheme interpreter has a number of static variables that point
to heap-allocated objects.  First, the special objects, including:

     static obj_t obj_empty;         /* (), the empty list */

Second, the predefined symbols, including:

     static obj_t obj_quote;         /* "quote" symbol */

And third, the global symbol table:

     static obj_t *symtab;
     static size_t symtab_size;

You tell the MPS how to scan these by writing root scanning functions of
type *note mps_root_scan_t: 9b.  These functions are similar to the
*note scan method: 71. in an *note object format: 39, described above.

In the case of the toy Scheme interpreter, the root scanning function
for the special objects and the predefined symbols could be written like
this:

     static mps_res_t globals_scan(mps_ss_t ss, void *p, size_t s)
     {
         MPS_SCAN_BEGIN(ss) {
             FIX(obj_empty);
             /* ... and so on for the special objects ... */
             FIX(obj_quote);
             /* ... and so on for the predefined symbols ... */
         } MPS_SCAN_END(ss);
         return MPS_RES_OK;
     }

but in fact the interpreter already has tables of these global objects,
so it’s simpler and more extensible for the root scanning function to
iterate over them:

     static mps_res_t globals_scan(mps_ss_t ss, void *p, size_t s)
     {
         MPS_SCAN_BEGIN(ss) {
             size_t i;
             for (i = 0; i < LENGTH(sptab); ++i)
                 FIX(*sptab[i].varp);
             for (i = 0; i < LENGTH(isymtab); ++i)
                 FIX(*isymtab[i].varp);
         } MPS_SCAN_END(ss);
         return MPS_RES_OK;
     }

Each root scanning function must be registered with the MPS by calling
*note mps_root_create(): 9c, like this:

     mps_root_t globals_root;
     res = mps_root_create(&globals_root, arena, mps_rank_exact(), 0,
                           globals_scan, NULL, 0);
     if (res != MPS_RES_OK) error("Couldn't register globals root");

The third argument (here *note mps_rank_exact(): 9d.) is the *note rank:
9e. of references in the root.  “*note Exact: 61.” means that:

  1. each reference in the root is a genuine pointer to another object
     managed by the MPS, or else a null pointer (unlike *note ambiguous
     references: 9f.); and

  2. each reference keeps the target of the reference alive (unlike
     *note weak references (1): c.).

The fourth argument is the *note root mode: a0, which tells the MPS
whether it is allowed to place a *note barrier (1): 60. on the root.
The root mode ‘0’ means that it is not allowed.

The sixth and seventh arguments (here ‘NULL’ and ‘0’) are passed to the
root scanning function where they are received as the parameters ‘p’ and
‘s’ respectively.  In this case there was no need to use them.

What about the global symbol table?  This is trickier, because it gets
rehashed from time to time, and during the rehashing process there are
two copies of the symbol table in existence.  Because the MPS is *note
asynchronous: a1, it might be scanning, moving, or collecting, at any
point in time, and if it is doing so during the rehashing of the symbol
table it had better scan both the old and new copies of the table.  This
is most conveniently done by registering a new root to refer to the new
copy, and then after the rehash has completed, de-registering the old
root by calling *note mps_root_destroy(): a2.

It would be possible to write a root scanning function of type *note
mps_root_scan_t: 9b, as described above, to fix the references in the
global symbol table, but the case of a table of references is
sufficiently common that the MPS provides a convenient (and optimized)
function, *note mps_root_create_table(): a3, for registering it:

     static mps_root_t symtab_root;

     /* ... */

     mps_addr_t ref = symtab;
     res = mps_root_create_table(&symtab_root, arena, mps_rank_exact(), 0,
                                 ref, symtab_size);
     if (res != MPS_RES_OK) error("Couldn't register new symtab root");
The root must be re-registered whenever the global symbol table changes
size:

     static void rehash(void) {
         obj_t *old_symtab = symtab;
         unsigned old_symtab_size = symtab_size;
         mps_root_t old_symtab_root = symtab_root;
         unsigned i;
         mps_addr_t ref;
         mps_res_t res;

         symtab_size *= 2;
         symtab = malloc(sizeof(obj_t) * symtab_size);
         if (symtab == NULL) error("out of memory");

         /* Initialize the new table to NULL so that "find" will work. */
         for (i = 0; i < symtab_size; ++i)
             symtab[i] = NULL;

         ref = symtab;
         res = mps_root_create_table(&symtab_root, arena, mps_rank_exact(), 0,
                                     ref, symtab_size);
         if (res != MPS_RES_OK) error("Couldn't register new symtab root");

         for (i = 0; i < old_symtab_size; ++i)
             if (old_symtab[i] != NULL) {
                 obj_t *where = find(old_symtab[i]->symbol.string);
                 assert(where != NULL);    /* new table shouldn't be full */
                 assert(*where == NULL);   /* shouldn't be in new table */
                 *where = old_symtab[i];
             }

         mps_root_destroy(old_symtab_root);
         free(old_symtab);
     }

     Note: 
       1. The old root description (referring to the old copy of the
          symbol table) is not destroyed until after the new root
          description has been registered.  This is because the MPS is
          *note asynchronous: a1.: it might be scanning, moving, or
          collecting, at any point in time.  If the old root description
          were destroyed before the new root description was registered,
          there would be a period during which:

            a. the symbol table was not reachable (at least as far as
               the MPS was concerned) and so all the objects referenced
               by it (and all the objects reachable from 'those'
               objects) might be dead; and

            b. if the MPS moved an object, it would not know that the
               object was referenced by the symbol table, and so would
               not update the reference there to point to the new
               location of the object.  This would result in out-of-date
               references in the old symbol table, and these would be
               copied into the new symbol table.

       2. The root might be scanned as soon as it is registered, so it
          is important to fill it with scannable references (‘NULL’ in
          this case) before registering it.

       3. The order of operations at the end is important: the old root
          must be de-registered before its memory is freed.

       4. When calling *note mps_root_create_table(): a3, take care to
          avoid undefined behaviour due to *note type punning: a5.  See
          the *note warning: a6.

*note Roots: 28.


File: MemoryPoolSystem.info,  Node: Threads,  Next: Allocation,  Prev: Roots,  Up: Garbage collecting a language with the Memory Pool System

1.3.7 Threads
-------------

In a multi-threaded environment where *note incremental garbage
collection: d. is used, you must register each of your *note threads:
99. with the MPS so that the MPS can examine their state.

Even in a single-threaded environment (like the toy Scheme interpreter)
it may also be necessary to register the (only) thread if either of
these conditions apply:

  1. you are using *note moving garbage collection: 5d. (as with the
     *note AMC (Automatic Mostly-Copying): 62. pool);

  2. the thread’s *note registers: 26. and *note control stack: 27.
     constitute a *note root: 97. (that is, objects may be kept alive
     via references in local variables: this is almost always the case
     for programs written in *note C: 1c.).

You register a thread with an *note arena: 16. by calling *note
mps_thread_reg(): a8.:

     mps_thr_t thread;
     res = mps_thread_reg(&thread, arena);
     if (res != MPS_RES_OK) error("Couldn't register thread");

You register the thread’s *note registers: 26. and *note control stack:
27. as a root by calling *note mps_root_create_thread(): a9.:

     void *marker = &marker;
     mps_root_t stack_root;
     res = mps_root_create_thread(&stack_root, arena, thread, marker);
     if (res != MPS_RES_OK) error("Couldn't create stack root");

In order to scan the control stack, the MPS needs to know where the
*note cold end: aa. of the stack is, and that’s the role of the ‘marker’
variable: the compiler places it on the stack, so its address is a
position within the stack.  As long as you don’t exit from this function
while the MPS is running, your program’s active local variables will
always be placed on the stack after ‘marker’, and so will be scanned for
references by the MPS.

*note Threads: 29.


File: MemoryPoolSystem.info,  Node: Allocation,  Next: Maintaining consistency,  Prev: Threads,  Up: Garbage collecting a language with the Memory Pool System

1.3.8 Allocation
----------------

It probably seemed a long journey to get here, but at last we’re ready
to start allocating.

*note Manual: 8. pools typically support *note malloc: 1a.-like
allocation using the function *note mps_alloc(): ad.  But *note
automatic: 9. pools cannot, because of the following problem:

     static obj_t make_pair(obj_t car, obj_t cdr)
     {
         obj_t obj;
         mps_addr_t addr;
         mps_res_t res;
         res = mps_alloc(&addr, pool, sizeof(pair_s));
         if (res != MPS_RES_OK) error("out of memory in make_pair");
         obj = addr;

         /* What happens if the MPS scans obj just now? */

         obj->pair.type = TYPE_PAIR;
         CAR(obj) = car;
         CDR(obj) = cdr;
         return obj;
     }

Because the MPS is *note asynchronous: a1, it might scan any reachable
object at any time, including immediately after the object has been
allocated.  In this case, if the MPS attempts to scan ‘obj’ at the
indicated point, the object’s ‘type’ field will be uninitialized, and so
the *note scan method: 73. may abort.

The MPS solves this problem via the fast, nearly lock-free *note
Allocation point protocol: ae.  This needs an additional structure, an
*note allocation point: 63, to be attached to the pool by calling *note
mps_ap_create_k(): af.:

     static mps_ap_t obj_ap;

     /* ... */

     res = mps_ap_create_k(&obj_ap, obj_pool, mps_args_none);
     if (res != MPS_RES_OK) error("Couldn't create obj allocation point");

And then the constructor can be implemented like this:

     static obj_t make_pair(obj_t car, obj_t cdr)
     {
         obj_t obj;
         mps_addr_t addr;
         size_t size = ALIGN_OBJ(sizeof(pair_s));
         do {
             mps_res_t res = mps_reserve(&addr, obj_ap, size);
             if (res != MPS_RES_OK) error("out of memory in make_pair");
             obj = addr;
             obj->pair.type = TYPE_PAIR;
             CAR(obj) = car;
             CDR(obj) = cdr;
         } while (!mps_commit(obj_ap, addr, size));
         return obj;
     }

The function *note mps_reserve(): b0. allocates a block of memory that
the MPS knows is uninitialized: the MPS promises not to scan this block
or move it until after it is *note committed (2): b1. by calling *note
mps_commit(): b2.  So the new object can be initialized safely.

However, there’s a second problem:

         CAR(obj) = car;
         CDR(obj) = cdr;

         /* What if the MPS moves car or cdr just now? */

     } while (!mps_commit(obj_ap, addr, size));

Because ‘obj’ is not yet committed, the MPS won’t scan it, and that
means that it won’t discover that it contains references to ‘car’ and
‘cdr’, and so won’t update these references to point to their new
locations.

In such a circumstance (that is, when objects have moved since you
called *note mps_reserve(): b0.), *note mps_commit(): b2. returns false,
and we have to initialize the object again (most conveniently done via a
‘while’ loop, as here).

     Note: 
       1. When using the *note Allocation point protocol: ae. it is up
          to you to ensure that the requested size is aligned, because
          *note mps_reserve(): b0. is on the MPS’s *note critical path:
          7c, and so it is highly optimized: in nearly all cases it is
          just an increment to a pointer and a test.

       2. It is very rare for *note mps_commit(): b2. to return false,
          but in the course of millions of allocations even very rare
          events occur, so it is important not to do anything you don’t
          want to repeat between calling *note mps_reserve(): b0. and
          *note mps_commit(): b2.  Also, the shorter the interval, the
          less likely *note mps_commit(): b2. is to return false.

*note Allocation: 2b.


File: MemoryPoolSystem.info,  Node: Maintaining consistency,  Next: Tidying up,  Prev: Allocation,  Up: Garbage collecting a language with the Memory Pool System

1.3.9 Maintaining consistency
-----------------------------

The MPS is *note asynchronous: a1.: this means that it might be
scanning, moving, or collecting, at any point in time (potentially,
between any pair of instructions in your program).  So you must make
sure that your data structures always obey these rules:

  1. A *note root: 97. must be scannable by its root scanning function
     as soon as it has been registered.

     See the discussion of the *note global symbol table: a4. in the toy
     Scheme interpreter.

  2. A *note formatted object: 23. must be scannable by the *note scan
     method: 73. as soon as it has been *note committed (2): b1. by
     calling *note mps_commit(): b2.

     See the discussion of the *note pair constructor: ac. in the toy
     Scheme interpreter.

  3. All objects in automatically managed pools that are *note
     reachable: 96. by your code must always be provably reachable from
     a root via a chain of *note references: 24. that are *note fixed:
     b4. by a scanning function.

     See the discussion of the *note global symbol table: a4. in the toy
     Scheme interpreter.

  4. Formatted objects must remain scannable throughout their *note
     lifetime: b5.

Examples of code that breaks these rules, together with tactics for
tracking down the causes, appear in the chapter *note Debugging with the
Memory Pool System: b6.


File: MemoryPoolSystem.info,  Node: Tidying up,  Next: What next?<2>,  Prev: Maintaining consistency,  Up: Garbage collecting a language with the Memory Pool System

1.3.10 Tidying up
-----------------

When your program is done with the MPS, you should *note park: b8. the
arena (by calling *note mps_arena_park(): b9.) to ensure that no
incremental garbage collection is in progress, and then tear down all
the MPS data structures.  This causes the MPS to check the consistency
of its data structures and report any problems it detects.  It also
causes the MPS to flush its *note telemetry stream: ba.

MPS data structures must be destroyed or deregistered in the reverse
order to that in which they were registered or created.  So you must
destroy all *note allocation points: 63. created in a *note pool: 18.
before destroying the pool; destroy all *note roots: 97. and pools, and
deregister all *note threads: 99, that were created in an *note arena:
16. before destroying the arena, and so on.

For example:

     mps_arena_park(arena);        /* ensure no collection is running */
     mps_ap_destroy(obj_ap);       /* destroy ap before pool */
     mps_pool_destroy(obj_pool);   /* destroy pool before fmt */
     mps_root_destroy(stack_root); /* destroy root before thread */
     mps_thread_dereg(thread);     /* deregister thread before arena */
     mps_fmt_destroy(obj_fmt);     /* destroy fmt before arena */
     mps_arena_destroy(arena);     /* last of all */


File: MemoryPoolSystem.info,  Node: What next?<2>,  Prev: Tidying up,  Up: Garbage collecting a language with the Memory Pool System

1.3.11 What next?
-----------------

This article has covered the basic knowledge needed to add incremental,
moving, generational garbage collection to the runtime system for a
programming language.

If everything is working for your language, then the next step is the
chapter *note Tuning the Memory Pool System for performance: bc.

But in the more likely event that things don’t work out quite as
smoothly for your language as they did in the toy Scheme interpreter,
then you’ll be more interested in the chapter *note Debugging with the
Memory Pool System: b6.


File: MemoryPoolSystem.info,  Node: The stretchy vector problem,  Next: Debugging with the Memory Pool System,  Prev: Garbage collecting a language with the Memory Pool System,  Up: Guide

1.4 The stretchy vector problem
===============================

The *note previous chapter: 94. pointed out that:

     Because the MPS is *note asynchronous: a1, it might be scanning,
     moving, or collecting, at any point in time.

The consequences of this can take a while to sink in, so this chapter
discusses a particular instance that catches people out: the 'stretchy
vector' problem (named after the <stretchy-vector>(1) abstract class in
Dylan).

A 'stretchy vector' is a vector that can change length dynamically.
Such a vector is often implemented using two objects: an array, and a
header object that stores the length and a pointer to an array.
Stretching (or shrinking) such a vector involves five steps:

  1. allocate a new array;

  2. copy elements from the old array to the new array;

  3. clear unused elements in the new array (if stretching);

  4. update the pointer to the array in the header;

  5. update the length in the header.

For example:

     typedef struct vector_s {
         type_t type;                /* TYPE_VECTOR */
         size_t length;              /* number of elements */
         obj_t *array;               /* array of elements */
     } vector_s, *vector_t;

     void resize_vector(vector_t vector, size_t new_length) {
         obj_t *new_array = realloc(vector->array, new_length * sizeof(obj_t));
         if (new_array == NULL)
             error("out of memory in resize_vector");
         if (vector->length < new_length) {
             memset(&vector->array[vector->length], 0,
                    (new_length - vector->length) * sizeof(obj_t));
         }
         vector->array = new_array;
         vector->length = new_length;
     }

When adapting this code to the MPS, the following problems must be
solved:

  1. During step 2, the new array must be *note reachable: 96. from the
     roots, and *note scannable: 65.  (If it’s not reachable, then it
     may be collected; if it’s not scannable, then references it
     contains will not be updated when they are moved by the collector.)

     This can solved by storing the new array in a *note root: 97. until
     the header has been updated.  If the thread’s stack has been
     registered as a root by calling *note mps_root_create_thread(): a9.
     then any local variable will do.

  2. References in the new array must not be scanned until they have
     been copied or cleared.  (Otherwise they will be invalid.)

     This can be solved by clearing the new array before calling *note
     mps_commit(): b2.

  3. The old array must be scanned at the old length (otherwise the scan
     may run off the end of the old array when the vector grows), and
     the new array must be scanned at the new length (otherwise the scan
     may run off the end of the old array when the vector shrinks).

  4. The array object must be scannable without referring to the header
     object.  (Because the header object may have been protected by the
     MPS: see *note Cautions: c0.)

Problems 3 and 4 can be solved by storing the length in the array.  The
revised data structures and resizing code might look like this:

     typedef struct vector_s {
         type_t type;                /* TYPE_VECTOR */
         obj_t array;                /* TYPE_ARRAY object */
     } vector_s, *vector_t;

     typedef struct array_s {
         type_t type;                /* TYPE_ARRAY */
         size_t length;              /* number of elements */
         obj_t array[0];             /* array of elements */
     } array_s, *array_t;

     void resize_vector(vector_t vector, size_t new_length) {
         size_t size = ALIGN_OBJ(offsetof(array_s, array) + new_length * sizeof(obj_t));
         mps_addr_t addr;
         array_t array;

         do {
             mps_res_t res = mps_reserve(&addr, ap, size);
             if (res != MPS_RES_OK) error("out of memory in resize_vector");
             array = addr;
             array->type = TYPE_ARRAY;
             array->length = new_length;
             memset(array->array, 0, new_length * sizeof(obj_t));
             /* Now the new array is scannable, and it is reachable via the
              * local variable 'array', so it is safe to commit it. */
         } while(!mps_commit(ap, addr, size));

         /* Copy elements after committing, so that the collector will
          * update them if they move. */
         memcpy(array->array, vector->array->array,
                min(vector->array->length, new_length) * sizeof(obj_t));
         vector->array = array;
     }

Similar difficulties can arise even when adapting code written for other
garbage collectors.  For example, here’s the function
setarrayvector()(2) from Lua(3):

     static void setarrayvector (lua_State *L, Table *t, int size) {
         int i;
         luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
         for (i=t->sizearray; i<size; i++)
             setnilvalue(&t->array[i]);
         t->sizearray = size;
     }

Lua’s garbage collector is *note synchronous: c1, so it can be assumed
that there cannot be a garbage collection between the assignment to
‘t->array’ (resulting from the expansion of the luaM_reallocvector()(4)
macro) and the assignment to ‘t->sizearray’, and so the collector will
always consistently see either the old array or the new array, with the
correct size.  This assumption will no longer be correct if this code is
adapted to the MPS.

   ---------- Footnotes ----------

   (1) 
https://opendylan.org/books/drm/Collection_Classes#stretchy-vector

   (2) https://www.lua.org/source/5.2/ltable.c.html#setarrayvector

   (3) https://www.lua.org/

   (4) https://www.lua.org/source/5.2/lmem.h.html#luaM_reallocvector


File: MemoryPoolSystem.info,  Node: Debugging with the Memory Pool System,  Next: Tuning the Memory Pool System for performance,  Prev: The stretchy vector problem,  Up: Guide

1.5 Debugging with the Memory Pool System
=========================================

Memory management errors are some of the most stubborn and difficult to
track down, because the effect so often appears at a distant point in
the program that is seemingly unrelated to the cause, and by the time
the error is revealed, the information needed to reconstruct the cause
has long vanished.  Immediately after an *note overwriting error: c5,
the block that overran its bounds is fine, and the block that was
overwritten may not be visited for a long time.  A failure to *note fix:
b4. a *note reference: 24. does not necessarily cause the object pointed
to by the missed reference to die immediately: there may be other
references to that object, or a garbage collection may be delayed.  And
even if it does die, the space it occupies may not be re-allocated for
some time.

* Menu:

* General debugging advice::
* Address space layout randomization::
* Example; underscanning: Example underscanning.
* Example; allocating with wrong size: Example allocating with wrong size.
* What next?: What next?<3>.


File: MemoryPoolSystem.info,  Node: General debugging advice,  Next: Address space layout randomization,  Up: Debugging with the Memory Pool System

1.5.1 General debugging advice
------------------------------

  1. Compile with debugging information turned on (‘-g’ on the GCC or
     Clang command line).

  2. 
     Build the *note cool: c8. *note variety: c9. of the MPS (by
     defining the preprocessor constant *note CONFIG_VAR_COOL: ca, for
     example by setting ‘-DCONFIG_VAR_COOL’ on the GCC or Clang command
     line).  This variety contains many internal consistency checks
     (including such checks on the *note critical path: 7c, which make
     it too slow for use in production), and can generate profiling
     output in the form of the *note telemetry stream: ba.

  3. If your program triggers an assertion failure in the MPS, consult
     *note Common assertions and their causes: cb. for suggestions as to
     the possible cause.

  4. Prepare a reproducible test case if possible.  The MPS may be *note
     asynchronous: a1, but it is deterministic, so in single-threaded
     applications you should be able to get consistent results.

     However, you need to beware of *note address space layout
     randomization: cc.: if you perform computation based on the
     addresses of objects, for example, hashing objects by their
     address, then ASLR will cause your hash tables to be laid out
     differently on each run, which may affect the order of memory
     management operations.  See *note Address space layout
     randomization: cd. below.

     A fact that assists with reproducibility is that the more
     frequently the collector runs, the sooner and more reliably errors
     are discovered.  So if you have a bug that’s hard to reproduce, or
     which manifests itself in different ways on different runs, you may
     be able to provoke it more reliably, or get a more consistent
     result, by having a mode for testing in which you run frequent
     collections (by calling *note mps_arena_collect(): ce. followed by
     *note mps_arena_release(): cf.), perhaps as frequently as every
     allocation.  (This will of course make the system run very slowly,
     but it ensures that if there are roots or references that are not
     being scanned then the failure will occur close in time to the
     cause, making it easier to diagnose.)

  5. 
     Run your test case inside the debugger.  Use ‘assert()’ and
     ‘abort()’ in your error handler (rather than ‘exit()’) so that you
     can enter the debugger with the contents of the control stack
     available for inspection.

  6. 
     If you are using GDB on FreeBSD or Linux, you may want to avoid
     stopping on *note barrier (1): 60. hits, because the MPS uses
     barriers to protect parts of memory, and barrier hits are common
     and expected.  To avoid stopping on a barrier hit, run:

          handle SIGSEGV pass nostop noprint

     You can add this command to your ‘.gdbinit’ if you always want it
     to be run.

     On macOS and Windows, barrier hits do not use signals and so do not
     enter the debugger.

  7. 
     Similarly, if you are using GDB on FreeBSD or Linux, and if the
     *note client program: d0. is multi-threaded, you may want to avoid
     stopping when the MPS suspends and resumes threads by delivering
     signals to them.  To avoid stopping on thread suspension and
     resumption, run:

          handle SIGXCPU pass nostop noprint
          handle SIGXFSZ pass nostop noprint

     If you have configured these signals as described under *note
     Signal and exception handling issues: d1, you will need to adjust
     the signal names accordingly.

     On macOS and Windows, thread suspension and resumption does not use
     signals and so does not enter the debugger.

  8. 
     If the *note client program: d0. is stopped in the debugger with
     the MPS part of the way through execution of an operation in an
     *note arena: 16. (for example, a crash inside a *note scan method:
     73.), it will not be possible to call introspection functions, such
     as *note mps_arena_has_addr(): d2. or *note mps_addr_pool(): d3.
     (because the MPS is not re-entrant), and it may not be possible to
     examine some regions of memory (because they are *note protected:
     d4. by the MPS).

     If you are in this situation and would like to be able to call MPS
     functions or examine regions of memory from the debugger, then you
     can put the arena into the *note postmortem state: d5. by calling
     *note mps_arena_postmortem(): d6. from the debugger.  This unlocks
     the arena and turns off protection.

          Warning: After calling *note mps_arena_postmortem(): d6,
          MPS-managed memory is not in a consistent state, and so it is
          not safe to continue running the client program.


File: MemoryPoolSystem.info,  Node: Address space layout randomization,  Next: Example underscanning,  Prev: General debugging advice,  Up: Debugging with the Memory Pool System

1.5.2 Address space layout randomization
----------------------------------------

*note Address space layout randomization: cc. (ASLR) makes it hard to
prepare a repeatable test case for a program that performs computation
based on the addresses of objects, for example, hashing objects by their
address.  If this is affecting you, you’ll find it useful to disable
ASLR when testing.

Here’s a small program that you can use to check if ASLR is enabled on
your system.  It outputs addresses from four key memory areas in a
program (data segment, text segment, stack and heap):

     #include <stdio.h>
     #include <stdlib.h>

     int data;

     int main() {
         void *heap = malloc(4);
         int stack = 0;
         printf("data: %p text: %p stack: %p heap: %p\n",
                &data, (void *)main, &stack, heap);
         return 0;
     }

When ASLR is turned on, running this program outputs different addresses
on each run.  For example, here are four runs on macOS 10.9.3:

     data: 0x10a532020 text: 0x10a531ed0 stack: 0x7fff556ceb1c heap: 0x7f9f80c03980
     data: 0x10d781020 text: 0x10d780ed0 stack: 0x7fff5247fb1c heap: 0x7fe498c03980
     data: 0x10164b020 text: 0x10164aed0 stack: 0x7fff5e5b5b1c heap: 0x7fb783c03980
     data: 0x10c7f8020 text: 0x10c7f7ed0 stack: 0x7fff53408b1c heap: 0x7f9740403980

By contrast, here are four runs on FreeBSD 8.3:

     data: 0x8049728 text: 0x8048470 stack: 0xbfbfebfc heap: 0x28201088
     data: 0x8049728 text: 0x8048470 stack: 0xbfbfebfc heap: 0x28201088
     data: 0x8049728 text: 0x8048470 stack: 0xbfbfebfc heap: 0x28201088
     data: 0x8049728 text: 0x8048470 stack: 0xbfbfebfc heap: 0x28201088

Here’s the situation on each of the operating systems supported by the
MPS:

   * 'FreeBSD' (as of version 10.0) does not support ASLR, so there’s
     nothing to do.

   * On 'Windows' (Vista or later), ASLR is a property of the
     executable, and it can be turned off at link time using the
     /DYNAMICBASE:NO linker option(1).

   * On 'Linux' (kernel version 2.6.12 or later), ASLR can be turned off
     for a single process by running setarch(2) with the ‘-R’ option:

          -R, --addr-no-randomize
                 Disables randomization of the virtual address space

     For example:

          $ setarch $(uname -m) -R ./myprogram

   * On 'macOS' (10.7 or later), ASLR can be disabled for a single
     process by starting the process using ‘posix_spawn()’, passing the
     undocumented attribute ‘0x100’, like this:

          #include <spawn.h>

          pid_t pid;
          posix_spawnattr_t attr;

          posix_spawnattr_init(&attr);
          posix_spawnattr_setflags(&attr, 0x100);
          posix_spawn(&pid, argv[0], NULL, &attr, argv, environ);

     The MPS provides the source code for a command-line tool
     implementing this (‘tool/noaslr.c’).  We’ve confirmed that this
     works on macOS 10.9.3, but since the technique is undocumented, it
     may well break in future releases.  (If you know of a documented
     way to achieve this, please *note contact us: d8.)

   ---------- Footnotes ----------

   (1) https://docs.microsoft.com/en-us/cpp/build/reference/dynamicbase

   (2) http://man7.org/linux/man-pages/man8/setarch.8.html


File: MemoryPoolSystem.info,  Node: Example underscanning,  Next: Example allocating with wrong size,  Prev: Address space layout randomization,  Up: Debugging with the Memory Pool System

1.5.3 Example: underscanning
----------------------------

An easy mistake to make is to omit to *note fix: b4. a *note reference:
24. when *note scanning: 65. a *note formatted object: 23.  For example,
in the Scheme interpreter’s *note scan method: 71, I might have
forgotten to fix the first element of a pair:

     case TYPE_PAIR:
     case TYPE_PROMISE:
       /* oops, forgot: FIX(CAR(obj)); */
       FIX(CDR(obj));
       base = (char *)base + ALIGN_OBJ(sizeof(pair_s));
       break;

This means that as far as the MPS is concerned, the first element of the
pair is *note unreachable: 21. and so *note dead: 49, so after
collecting the region of memory containing this object, the space will
be reused for other objects.  So ‘CAR(obj)’ might end up pointing to the
start of a valid object (but the wrong one), or to the middle of a valid
object, or to an unused region of memory, or into an MPS internal
control structure.

The reproducible test case is simple.  Run a garbage collection by
calling ‘(gc)’ and then evaluate any expression:

     $ gdb -q ./scheme
     Reading symbols from ./scheme...done.
     (gdb) run
     Starting program: /home/grees/github.com/mps/example/scheme/scheme
     MPS Toy Scheme Example
     The prompt shows total allocated bytes and number of collections.
     Try (vector-length (make-vector 100000 1)) to see the MPS in action.
     You can force a complete garbage collection with (gc).
     If you recurse too much the interpreter may crash from using too much C stack.
     13248, 0> (gc)
     Collection started.
       Why: Client requests: immediate full collection.
       Clock: 1819
     Collection finished.
         live 5272
         condemned 16384
         not_condemned 0
         clock: 1987
     13272, 1> foo
     scheme: scheme.c:1421: lookup_in_frame: Assertion `TYPE(CAAR(frame)) == TYPE_SYMBOL' failed.

     Program received signal SIGABRT, Aborted.
     __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
     51  ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.

What’s going on?

     (gdb) backtrace
     #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
     #1  0x00007ffff78058b1 in __GI_abort () at abort.c:79
     #2  0x00007ffff77f542a in __assert_fail_base (fmt=0x7ffff797ca38 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=assertion@entry=0x555555604050 "TYPE(CAAR(frame)) == TYPE_SYMBOL", file=file@entry=0x555555603bb2 "scheme.c", line=line@entry=1421, function=function@entry=0x555555605390 <__PRETTY_FUNCTION__.3661> "lookup_in_frame") at assert.c:92
     #3  0x00007ffff77f54a2 in __GI___assert_fail (assertion=0x555555604050 "TYPE(CAAR(frame)) == TYPE_SYMBOL", file=0x555555603bb2 "scheme.c", line=1421, function=0x555555605390 <__PRETTY_FUNCTION__.3661> "lookup_in_frame") at assert.c:101
     #4  0x000055555555d0d8 in lookup_in_frame (frame=0x7ffff5900bb8, symbol=0x7ffff5883418) at scheme.c:1421
     #5  0x000055555555d16c in lookup (env=0x7ffff5880180, symbol=0x7ffff5883418) at scheme.c:1440
     #6  0x000055555555d2d1 in eval (env=0x7ffff5880180, op_env=0x7ffff5880198, exp=0x7ffff5883418) at scheme.c:1487
     #7  0x0000555555564f29 in start (argc=0, argv=0x7fffffffe0d0) at scheme.c:4341
     #8  0x0000555555565717 in main (argc=0, argv=0x7fffffffe0d0) at scheme.c:4489
     (gdb) frame 4
     #4  0x000055555555d0d8 in lookup_in_frame (frame=0x7ffff5900bb8, symbol=0x7ffff5883418) at scheme.c:1421
     1421            assert(TYPE(CAAR(frame)) == TYPE_SYMBOL);
     (gdb) print (char *)symbol->symbol.string
     $1 = 0x7ffff5883428 "foo"

The backtrace shows that the interpreter is in the middle of looking up
the symbol ‘foo’ in the environment.  The Scheme interpreter implements
the environment as a list of 'frames', each of which is a list of
'bindings', each binding being a pair of a symbol and its value, as
shown here:

 [image src="MemoryPoolSystem-figures/scheme-env.svg" alt="Diagram: The environment data structure in the Scheme interpreter." ]


Figure: The environment data structure in the Scheme interpreter.

In this case, because the evaluation is taking place at top level, there
is only one frame in the environment (the global frame).  And it’s this
frame that’s corrupt:

     (gdb) list
     1416        static obj_t lookup_in_frame(obj_t frame, obj_t symbol)
     1417        {
     1418          while(frame != obj_empty) {
     1419            assert(TYPE(frame) == TYPE_PAIR);
     1420            assert(TYPE(CAR(frame)) == TYPE_PAIR);
     1421            assert(TYPE(CAAR(frame)) == TYPE_SYMBOL);
     1422            if(CAAR(frame) == symbol)
     1423              return CAR(frame);
     1424            frame = CDR(frame);
     1425          }
     (gdb) print CAAR(frame)->type.type
     $3 = 13

The number 13 is the value ‘TYPE_PAD’.  So instead of the expected
symbol, ‘CAAR(frame)’ points to a *note padding object: 67.

You might guess at this point that the symbol had not been fixed, and
since you know that the frame is referenced by the ‘car’ of the first
pair in the environment, that’s the suspect reference.  But in a more
complex situation this might not yet be clear.  In such a situation it
can be useful to look at the sequence of events leading up to the
detection of the error.  See *note Telemetry: db.


File: MemoryPoolSystem.info,  Node: Example allocating with wrong size,  Next: What next?<3>,  Prev: Example underscanning,  Up: Debugging with the Memory Pool System

1.5.4 Example: allocating with wrong size
-----------------------------------------

Here’s another kind of mistake: an off-by-one error in ‘make_string()’
leading to the allocation of string objects with the wrong size:

     static obj_t make_string(size_t length, const char *string)
     {
       obj_t obj;
       mps_addr_t addr;
       size_t size = ALIGN_OBJ(offsetof(string_s, string) + length /* oops, forgot +1 */);
       do {
         mps_res_t res = mps_reserve(&addr, obj_ap, size);
         if (res != MPS_RES_OK) error("out of memory in make_string");
         obj = addr;
         obj->string.type = TYPE_STRING;
         obj->string.length = length;
         if (string) memcpy(obj->string.string, string, length+1);
         else memset(obj->string.string, 0, length+1);
       } while(!mps_commit(obj_ap, addr, size));
       total += size;
       return obj;
     }

Here’s a test case that exercises this bug:

     (define (church n f a) (if (eqv? n 0) a (church (- n 1) f (f a))))
     (church 1000 (lambda (s) (string-append s "x")) "")

And here’s how it shows up in the debugger:

     $ gdb -q ./scheme
     Reading symbols from ./scheme...done.
     (gdb) run < test.scm
     Starting program: /home/grees/github.com/mps/example/scheme/scheme < test.scm
     [Thread debugging using libthread_db enabled]
     Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
     MPS Toy Scheme Example
     The prompt shows total allocated bytes and number of collections.
     Try (vector-length (make-vector 100000 1)) to see the MPS in action.
     You can force a complete garbage collection with (gc).
     If you recurse too much the interpreter may crash from using too much C stack.
     13248, 0> church
     14104, 0> scheme: scheme.c:4067: obj_skip: Assertion `0' failed.

     Program received signal SIGABRT, Aborted.
     __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
     51  ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
     (gdb) backtrace
     #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
     #1  0x00007ffff78058b1 in __GI_abort () at abort.c:79
     #2  0x00007ffff77f542a in __assert_fail_base (fmt=0x7ffff797ca38 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", assertion=assertion@entry=0x555555603e0f "0", file=file@entry=0x555555603c32 "scheme.c", line=line@entry=4067, function=function@entry=0x555555605568 <__PRETTY_FUNCTION__.4815> "obj_skip") at assert.c:92
     #3  0x00007ffff77f54a2 in __GI___assert_fail (assertion=0x555555603e0f "0", file=0x555555603c32 "scheme.c", line=4067, function=0x555555605568 <__PRETTY_FUNCTION__.4815> "obj_skip") at assert.c:101
     #4  0x000055555556434b in obj_skip (base=0x7ffff58af898) at scheme.c:4067
     #5  0x00005555555e15bf in amcSegScanNailedRange (totalReturn=0x7fffffffd4a0, moreReturn=0x7fffffffd4a4, ss=0x7fffffffd5f0, amc=0x7ffff57f73f8, board=0x7ffff57f8a40, base=0x7ffff58ae000, limit=0x7ffff58afff0) at ../../code/poolamc.c:1278
     #6  0x00005555555e177b in amcSegScanNailedOnce (totalReturn=0x7fffffffd4a0, moreReturn=0x7fffffffd4a4, ss=0x7fffffffd5f0, seg=0x7ffff57f89a8, amc=0x7ffff57f73f8) at ../../code/poolamc.c:1325
     #7  0x00005555555e187c in amcSegScanNailed (totalReturn=0x7fffffffd5d0, ss=0x7fffffffd5f0, pool=0x7ffff57f73f8, seg=0x7ffff57f89a8, amc=0x7ffff57f73f8) at ../../code/poolamc.c:1355
     #8  0x00005555555e1bd3 in amcSegScan (totalReturn=0x7fffffffd5d0, seg=0x7ffff57f89a8, ss=0x7fffffffd5f0) at ../../code/poolamc.c:1413
     #9  0x0000555555599188 in SegScan (totalReturn=0x7fffffffd5d0, seg=0x7ffff57f89a8, ss=0x7fffffffd5f0) at ../../code/seg.c:778
     #10 0x000055555558c926 in traceScanSegRes (ts=1, rank=1, arena=0x7ffff7ff7000, seg=0x7ffff57f89a8) at ../../code/trace.c:1148
     #11 0x000055555558cb2d in traceScanSeg (ts=1, rank=1, arena=0x7ffff7ff7000, seg=0x7ffff57f89a8) at ../../code/trace.c:1223
     #12 0x000055555558e24d in TraceAdvance (trace=0x7ffff7ff7ac0) at ../../code/trace.c:1664
     #13 0x000055555558e792 in TracePoll (workReturn=0x7fffffffd7b0, collectWorldReturn=0x7fffffffd78c, globals=0x7ffff7ff7008, collectWorldAllowed=1) at ../../code/trace.c:1784
     #14 0x000055555557c990 in ArenaPoll (globals=0x7ffff7ff7008) at ../../code/global.c:760
     #15 0x00005555555690ed in mps_ap_fill (p_o=0x7fffffffd940, mps_ap=0x7ffff57f7928, size=24) at ../../code/mpsi.c:1111
     #16 0x0000555555559c93 in make_pair (car=0x7ffff58afbf0, cdr=0x7ffff5880000) at scheme.c:457
     #17 0x000055555555d605 in eval_list (env=0x7ffff58afed0, op_env=0x7ffff58afee8, list=0x7ffff5883828, message=0x5555556041f8 "eval: badly formed argument list") at scheme.c:1564
     #18 0x000055555555d94b in eval_args_rest (name=0x555555604e02 "string-append", env=0x7ffff58afed0, op_env=0x7ffff58afee8, operands=0x7ffff5883828, restp=0x7fffffffdb00, n=0) at scheme.c:1637
     #19 0x0000555555562870 in entry_string_append (env=0x7ffff58afed0, op_env=0x7ffff58afee8, operator=0x7ffff5882340, operands=0x7ffff5883828) at scheme.c:3396
     #20 0x000055555555d420 in eval (env=0x7ffff58afed0, op_env=0x7ffff58afee8, exp=0x7ffff5883810) at scheme.c:1511
     #21 0x000055555555dbc8 in entry_interpret (env=0x7ffff58af9e0, op_env=0x7ffff58af9f8, operator=0x7ffff5883700, operands=0x7ffff5883670) at scheme.c:1713
     #22 0x000055555555d420 in eval (env=0x7ffff58af9e0, op_env=0x7ffff58af9f8, exp=0x7ffff5883598) at scheme.c:1511
     #23 0x0000555555564fab in start (argc=0, argv=0x7fffffffe0d0) at scheme.c:4341
     #24 0x0000555555565799 in main (argc=0, argv=0x7fffffffe0d0) at scheme.c:4489
     (gdb) frame 4
     #4  0x000055555556434b in obj_skip (base=0x7ffff58af898) at scheme.c:4067
     4067            assert(0);
     (gdb) list
     4062            break;
     4063          case TYPE_PAD1:
     4064            base = (char *)base + ALIGN_WORD(sizeof(pad1_s));
     4065            break;
     4066          default:
     4067            assert(0);
     4068            fflush(stdout);
     4069            fprintf(stderr, "Unexpected object on the heap\n");
     4070            abort();
     4071          }

The object being skipped is corrupt:

     (gdb) print obj->type.type
     $1 = -175623000

What happened to it?  It’s often helpful in these situations to have a
look at nearby memory.

     (gdb) x/20gx obj
     0x7ffff58af898:     0x00007ffff58834a8      0x00007ffff58af7c8
     0x7ffff58af8a8:     0x0000000000000000      0x00007ffff58af890
     0x7ffff58af8b8:     0x00007ffff58af660      0x0000000000000000
     0x7ffff58af8c8:     0x00007ffff58836e8      0x00007ffff5880000
     0x7ffff58af8d8:     0x0000000000000000      0x00007ffff58af5d0
     0x7ffff58af8e8:     0x00007ffff58af8c0      0x0000000000000000
     0x7ffff58af8f8:     0x00007ffff58af5b8      0x00007ffff58af8d8
     0x7ffff58af908:     0x0000000000000000      0x00007ffff5880090
     0x7ffff58af918:     0x00007ffff58af8f0      0x0000000000000000
     0x7ffff58af928:     0x00007ffff58834f0      0x00007ffff5880000

You can see that this is a region of memory containing pairs, which have
type ‘TYPE_PAIR’ = 0 and consist of three words.  But what’s that at the
start of the region, where ‘obj’'s tag should be?  It looks like a
pointer.  So what’s in the memory just below ‘obj’?  Let’s look at the
previous region of memory:

     (gdb) x/30gx (mps_word_t*)obj-28
     0x7ffff58af7b8:     0x00007ffff5883840      0x00007ffff5880000
     0x7ffff58af7c8:     0x0000000000000005      0x00000000000000b8
     0x7ffff58af7d8:     0x7878787878787878      0x7878787878787878
     0x7ffff58af7e8:     0x7878787878787878      0x7878787878787878
     0x7ffff58af7f8:     0x7878787878787878      0x7878787878787878
     0x7ffff58af808:     0x7878787878787878      0x7878787878787878
     0x7ffff58af818:     0x7878787878787878      0x7878787878787878
     0x7ffff58af828:     0x7878787878787878      0x7878787878787878
     0x7ffff58af838:     0x7878787878787878      0x7878787878787878
     0x7ffff58af848:     0x7878787878787878      0x7878787878787878
     0x7ffff58af858:     0x7878787878787878      0x7878787878787878
     0x7ffff58af868:     0x7878787878787878      0x7878787878787878
     0x7ffff58af878:     0x7878787878787878      0x7878787878787878
     0x7ffff58af888:     0x7878787878787878      0x0000000000000000
     0x7ffff58af898:     0x00007ffff58834a8      0x00007ffff58af7c8

In this region we can see a string starting at address ‘0x7ffff58af7c8’.
Its type is ‘TYPE_STRING’ = 5, its length is 0xb8 = 184, and its
contents is 184 repetitions of the byte 0x78 (ASCII for “x”) resulting
from the repeated ‘(string-append s "x")’ in the test code.  The string
is followed by a pair (with type 0) at the address ‘0x7ffff58af890’,
which is one word before ‘obj’.  So it looks as though ‘obj’ should be
pointing at the pair, but its value is one word too low.

The value in ‘obj’ comes from skipping the string object:

     (gdb) print obj_skip(0x7ffff58af7c8)
     $3 = (void *) 0x7ffff58af898

So either ‘obj_skip()’ has skipped one word too far, or the string
object is one word too short.  This should be enough evidence to track
down the cause.


File: MemoryPoolSystem.info,  Node: What next?<3>,  Prev: Example allocating with wrong size,  Up: Debugging with the Memory Pool System

1.5.5 What next?
----------------

If you tracked down all your bugs, then the next step is the chapter
*note Tuning the Memory Pool System for performance: bc.

But if you’re still struggling, please *note contact us: d8. and see if
we can help.


File: MemoryPoolSystem.info,  Node: Tuning the Memory Pool System for performance,  Next: Advanced topics,  Prev: Debugging with the Memory Pool System,  Up: Guide

1.6 Tuning the Memory Pool System for performance
=================================================

     Note: When developing a benchmark to profile your program against,
     bear in mind that the benchmark should allocate several times the
     amount of physical memory that you expect to be available to the
     process.  If the total allocation fits into the available memory,
     there’s no point running a garbage collector at all: you might as
     well just allocate and never collect.

The most important aspect of tuning the MPS is to choose good sizes for
the *note generations: e1. in your *note generation chain: e2.  The
ideal size of a generation should be such that when it is collected,
most of the blocks allocated in that generation should be found to be
*note dead: 49. (and so the cost of *note scanning: 65. and *note
copying: e3. them can be avoided entirely).  If a generation is
collected when its blocks are mostly alive, that is a waste of time.

In the tables below I give the execution time of ‘test-leaf.scm’ in the
toy Scheme interpreter under different settings for its generation
chain.  (This test case allocates hundreds of millions of small
short-lived objects.)

First, the effect of varying the capacity of a chain with a single
generation.

Capacity     Execution time (user+sys)
             
-------------------------------------------
             
100          362.6
             
             
200          354.9
             
             
400          349.7
             
             
800          314.4
             
             
1600         215.7
             
             
3200         94.0
             
             
6400         53.5
             
             
12800        79.6
             
             
25600        77.6
             

Second, the effect of varying the number of generations (all generations
being identical).

Generations     Capacity     Execution time (user+sys)
                             
-----------------------------------------------------------
                             
1               6400         53.5
                             
                             
2               6400         42.4
                             
                             
3               6400         42.1
                             
                             
4               6400         42.2
                             
                             
5               6400         42.2
                             

These tables suggest that:

  1. The improvement in performance to be gained by getting generation
     sizes right is dramatic: much bigger than the small improvements to
     gained from other techniques.

  2. You can make generations too big as well as too small.

  3. There are rapidly diminishing returns to be gained from adding
     generations.

     Note: *note Telemetry: db. can be used to discover when generations
     are being collected and what proportion of blocks were found to be
     alive.

The table below shows the effect of varying the initial allocation of
address space to the arena (using three generations each with capacity
6400 kB).

Address space     Extensions     Collections     Execution time (user+sys)
                                                 
-------------------------------------------------------------------------------
                                                 
2                 32             371             52.0
                                                 
                                                 
4                 21             370             47.0
                                                 
                                                 
8                 0              (1)             (2)
                                                 
                                                 
14                0              (3)             (4)
                                                 
                                                 
16                0              2436            160.5
                                                 
                                                 
18                0              1135            89.1
                                                 
                                                 
20                0              673             60.6
                                                 
                                                 
22                0              484             48.7
                                                 
                                                 
24                0              400             43.1
                                                 
                                                 
32                0              368             41.2
                                                 
                                                 
64                0              368             43.1
                                                 
                                                 
128               0              368             46.4
                                                 
                                                 
256               0              368             46.3
                                                 
                                                 
512               0              368             49.3
                                                 
                                                 
1024              0              368             42.0
                                                 
                                                 
2048              0              368             43.2
                                                 
                                                 
4096              0              368             43.5
                                                 
                                                 
8192              0              368             46.1
                                                 
                                                 
16384             0              368             49.2
                                                 
                                                 
32768             0              368             57.1
                                                 
                                                 
65536             0              368             71.1
                                                 
                                                 
131072            0              368             101.3
                                                 
                                                 
262144            0              368             161.3
                                                 
                                                 
524288            0              368             273.0
                                                 
                                                 
1048576           0              368             504.6
                                                 

     Note: 
The lesson here is that the allocation of address space has to be
comfortably larger than the working set of the program, but that a very
large address space is ruinous to performance.

   ---------- Footnotes ----------

   (1) With this initial allocation of address space, the test case
failed to run to completion after thousands of seconds and tens of
thousands of garbage collection cycles.

   (2) With this initial allocation of address space, the test case
failed to run to completion after thousands of seconds and tens of
thousands of garbage collection cycles.

   (3) With this initial allocation of address space, the test case
failed to run to completion after thousands of seconds and tens of
thousands of garbage collection cycles.

   (4) With this initial allocation of address space, the test case
failed to run to completion after thousands of seconds and tens of
thousands of garbage collection cycles.


File: MemoryPoolSystem.info,  Node: Advanced topics,  Next: Implementing malloc and free,  Prev: Tuning the Memory Pool System for performance,  Up: Guide

1.7 Advanced topics
===================

* Menu:

* Finalization::
* Location dependency::
* Weak hash tables::
* Global symbol table::
* Segregation of objects::


File: MemoryPoolSystem.info,  Node: Finalization,  Next: Location dependency,  Up: Advanced topics

1.7.1 Finalization
------------------

In Scheme, an open file is represented by a 'port'.  In the toy Scheme
interpreter, a port is a wrapper around a standard C file handle:

     typedef struct port_s {
         type_t type;                    /* TYPE_PORT */
         obj_t name;                     /* name of stream */
         FILE *stream;
     } port_s;

Operating systems limit the number of files that a process can have open
simultaneously, so to avoid running out of file handles, it is necessary
to close ports when you are done with them.  If a Scheme program fails
to call ‘close-input-file’, then the underlying file handle should still
be closed when the port object *note dies: 49.  This procedure is known
as *note finalization: b.

Any block in an *note automatically managed: 9. *note pool: 18. can be
registered for finalization by calling *note mps_finalize(): e8.  In the
toy Scheme interpreter, this can be done in ‘make_port()’:

      static obj_t make_port(obj_t name, FILE *stream)
      {
          mps_addr_t port_ref;
          obj_t obj;
          mps_addr_t addr;
          size_t size = ALIGN_OBJ(sizeof(port_s));
          do {
              mps_res_t res = mps_reserve(&addr, obj_ap, size);
              if (res != MPS_RES_OK) error("out of memory in make_port");
              obj = addr;
              obj->port.type = TYPE_PORT;
              obj->port.name = name;
              obj->port.stream = stream;
          } while(!mps_commit(obj_ap, addr, size));
          total += sizeof(port_s);

          port_ref = obj;
          mps_finalize(arena, &port_ref);

          return obj;
      }

The MPS implements finalization by posting a *note message: e9. to the
arena’s *note message queue: ea. when an object that has been registered
for finalization is about to die.

If you want to finalize your objects, you must first enable finalization
messages by calling *note mps_message_type_enable(): eb.:

     mps_message_type_enable(arena, mps_message_type_finalization());

You must then poll the arena’s message queue at times that are
convenient for you, call *note mps_message_get(): ec. to pick up a
finalization message from the queue, call *note
mps_message_finalization_ref(): ed. to access the finalized object, and
finally call *note mps_message_discard(): ee. on the finalization
message.  The finalized object is then subject to the normal rules of
life and death: it continues to live as long as it is strongly
reachable.

In the toy Scheme interpreter, the most convenient moment to process the
message queue is at the start of the read–eval–print loop.  When a
finalization message is found, the associated file handle is closed
(unless it has been closed already), and the message is discarded.

      mps_message_type_t type;

      while (mps_message_queue_type(&type, arena)) {
          mps_message_t message;
          mps_bool_t b;
          b = mps_message_get(&message, arena, type);
          assert(b); /* we just checked there was one */

          if (type == mps_message_type_finalization()) {
              mps_addr_t port_ref;
              obj_t port;
              mps_message_finalization_ref(&port_ref, arena, message);
              port = port_ref;
              assert(TYPE(port) == TYPE_PORT);
              if(port->port.stream) {
                  printf("Port to file \"%s\" is dying. Closing file.\n",
                         port->port.name->string.string);
                  (void)fclose(port->port.stream);
                  port->port.stream = NULL;
              }
          } else {
              /* ... handle other message types ... */
          }

          mps_message_discard(arena, message);
      }

Here’s an example session showing finalization taking place:

      MPS Toy Scheme Example
      9960, 0> (open-input-file "scheme.c")
      #[port "scheme.c"]
      10064, 0> (gc)
      Collection started.
        Why: Client requests: immediate full collection.
        Clock: 3401
      Port to file "scheme.c" is dying. Closing file.
      Collection finished.
          live 10040
          condemned 10088
          not_condemned 0
          clock: 3807

It’s wise not to depend on finalization as the only method for releasing
resources (see the *note Cautions: ef. section in *note Finalization:
f0.), because the garbage collector does not promise to collect
particular objects at particular times, and in any case it does so only
when it can prove that the object is *note dead: 49.  So it is best to
provide a reliable mechanism for releasing the resource (here, the
Scheme function ‘close-input-port’), and use finalization as a backup
strategy.

But this raises the possibility that a port will be closed twice: once
via ‘close-input-port’ and a second time via finalization.  So it’s
necessary to make ports robust against being closed multiple times.  The
toy Scheme interpreter does so by setting ‘stream’ to ‘NULL’: this
ensures that the file handle won’t be closed more than once.

     static void port_close(obj_t port)
     {
         assert(TYPE(port) == TYPE_PORT);
         if(port->port.stream != NULL) {
             fclose(port->port.stream);
             port->port.stream = NULL;
         }
     }

Note that because finalization messages are processed synchronously via
the message queue (and the Scheme interpreter is single-threaded) there
is no need for a lock here.

It’s still possible that the toy Scheme interpreter might run out of
open file handles despite having some or all of its port objects being
finalizable.  That’s because the arena’s message queue is only polled
after evaluating an expression at top level: if the expression itself
opens too many file handles, the finalization messages will queue up and
not be processed in time.  For example:

     MPS Toy Scheme Example
     9960, 0> (define (repeat n f _) (if (eqv? n 0) '() (repeat (- n 1) f (f))))
     repeat
     10840, 0> (repeat 300 (lambda () (open-input-file "scheme.c")) 0)
     open-input-file: cannot open input file

A less naïve interpreter might process finalization messages on a more
regular schedule, or might take emergency action in the event of running
out of open file handles by carrying out a full garbage collection and
processing any finalization messages that are posted as a result.

*note Finalization: f0, *note Messages: f1.


File: MemoryPoolSystem.info,  Node: Location dependency,  Next: Weak hash tables,  Prev: Finalization,  Up: Advanced topics

1.7.2 Location dependency
-------------------------

The toy Scheme interpreter contains an address-based (‘eq?’) hash table
implementation.  It hashes the addresses of its keys, and so needs to
take account of the possibility that a *note moving garbage collector:
5d. might move the keys.  If it fails to take account of this, the hash
table might become invalid after a garbage collection.

In the interaction shown below (with a naïve version of the code) you’ll
see that although the keys remain present in the table after garbage
collection, they cannot be found.  This is because their locations (and
hence their hashes) have changed, but their positions in the table have
not been updated to match.

     MPS Toy Scheme Example
     10240, 0> (define ht (make-eq-hashtable))
     ht
     10584, 0> (hashtable-set! ht 'one 1)
     10768, 0> (hashtable-set! ht 'two 2)
     10952, 0> (hashtable-set! ht 'three 3)
     11136, 0> ht
     #[hashtable (two 2) (three 3) (one 1)]
     11136, 0> (hashtable-ref ht 'two #f)
     2
     11280, 0> (gc)
     11304, 1> (hashtable-ref ht 'one #f)
     #f
     11448, 1> (hashtable-ref ht 'two #f)
     #f
     11592, 1> (hashtable-ref ht 'three #f)
     #f
     11736, 1> ht
     #[hashtable (two 2) (three 3) (one 1)]

The MPS solves this problem with its 'location dependency' feature: a
structure of type *note mps_ld_s: f4. encapsulates a set of dependencies
on the locations of blocks.  You add addresses to the location
dependency, and then later test an address to see if it is 'stale': that
is, if the block at that address might have moved since its location was
depended upon.

You need to provide space for the *note mps_ld_s: f4. structure.  In the
case of a hash table, it is most convenient to inline it in the hash
table’s metadata:

     typedef struct table_s {
       type_t type;                  /* TYPE_TABLE */
       hash_t hash;                  /* hash function */
       cmp_t cmp;                    /* comparison function */
       mps_ld_s ld;                  /* location dependency */
       obj_t buckets;                /* hash buckets */
     } table_s;

Before being used, the location dependency must be reset to indicate
that nothing is depended upon, by calling *note mps_ld_reset(): f5.

For example:

     static obj_t make_table(size_t length, hash_t hashf, cmp_t cmpf)
     {
         obj_t obj;
         mps_addr_t addr;
         size_t l, size = ALIGN_OBJ(sizeof(table_s));
         do {
             mps_res_t res = mps_reserve(&addr, obj_ap, size);
             if (res != MPS_RES_OK) error("out of memory in make_table");
             obj = addr;
             obj->table.type = TYPE_TABLE;
             obj->table.buckets = NULL;
         } while(!mps_commit(obj_ap, addr, size));
         total += size;
         obj->table.hash = hashf;
         obj->table.cmp = cmpf;
         /* round up to next power of 2 */
         for(l = 1; l < length; l *= 2);
         obj->table.buckets = make_buckets(l);
         mps_ld_reset(&obj->table.ld, arena);
         return obj;
     }

'Before' the hash table becomes dependent on the location of a block,
the address of the block must be added to its location dependency by
calling *note mps_ld_add(): f6.  In particular, you must call *note
mps_ld_add(): f6. before computing the hash of the address.  (If you
wait until afterwards, it might be too late: a garbage collection might
have taken place after the hash was computed but before you added the
dependency.)

In the toy Scheme interpreter, this is done just before the computation
of the hash of the address.

     static unsigned long eq_hash(obj_t obj, mps_ld_t ld)
     {
         union {char s[sizeof(obj_t)]; obj_t addr;} u;
         if (ld) mps_ld_add(ld, arena, obj);
         u.addr = obj;
         return hash(u.s, sizeof(obj_t));
     }

By adding the dependency at this point in the code, the implementation
avoids adding unnecessary dependencies on a location.  For example, an
‘eqv?’ hash table does not need to depend on the location of numbers and
characters:

     static unsigned long eqv_hash(obj_t obj, mps_ld_t ld)
     {
         switch(TYPE(obj)) {
             case TYPE_INTEGER:
                 return obj->integer.integer;
             case TYPE_CHARACTER:
                 return obj->character.c;
             default:
                 return eq_hash(obj, ld);
         }
     }

and a ‘string=?’ hash table does not need to depend on the location of
any of its keys.

     Note: The garbage collector may run at any time, so a key may
     become stale at any time after calling *note mps_ld_add(): f6,
     perhaps even before you’ve added it!

     It’s best to postpone worrying about this until this key is
     actually looked up, when the staleness will be discovered.  After
     all, it may never be looked up.

If you look up a key in an address-based hash table and fail to find it
there, that might be because the table’s dependency on the location of
the key is stale: that is, if the garbage collector moved the key.  The
function *note mps_ld_isstale(): f7. tells you if a block whose location
you depended upon since the last call to *note mps_ld_reset(): f5. might
have moved.

In the toy Scheme interpreter this behaviour is encapsulated into
‘table_find()’:

     static struct bucket_s *table_find(obj_t tbl, obj_t key, int add)
     {
         struct bucket_s *b;
         assert(TYPE(tbl) == TYPE_TABLE);
         b = buckets_find(tbl, tbl->table.buckets, key, add);
         if ((b == NULL || b->key == NULL || b->key == obj_deleted)
             && mps_ld_isstale(&tbl->table.ld, arena, key))
         {
             b = table_rehash(tbl, tbl->table.buckets->buckets.length, key);
         }
         return b;
     }

It’s important to test *note mps_ld_isstale(): f7. only in case of
failure.  The function may report a false positive (returning true
despite the block not having moved).  So if ‘key’ has not moved, then if
you tested *note mps_ld_isstale(): f7. first, it might return true and
so you’d end up unnecessarily rehashing the whole table.  (It’s crucial,
however, to actually test that ‘key’ appears in the table, not just that
some key with the same hash does.)

When a table is rehashed, call *note mps_ld_reset(): f5. to clear the
location dependency, and then *note mps_ld_add(): f6. for each key
before it is added back to the table.

     Note: After *note mps_ld_isstale(): f7. has returned true, and
     after rehashing the table, I don’t just repeat the usual lookup by
     calling ‘buckets_find()’.  That’s because the table might have
     become stale again already.

     Instead, ‘table_rehash()’ finds and returns the bucket containing
     ‘key’.  (Since it has to loop over all the entries in the table
     anyway, it might as well find this bucket too.)

By adding the line:

     puts("stale!");

in ‘table_find()’ after *note mps_ld_isstale(): f7. returns true, it’s
possible to see when the location dependency becomes stale and the table
has to be rehashed:

     MPS Toy Scheme Example
     10240, 0> (define ht (make-eq-hashtable))
     ht
     10584, 0> (hashtable-set! ht 'one 1)
     10768, 0> ht
     #[hashtable (one 1)]
     10768, 0> (gc)
     10792, 1> (hashtable-ref ht 'one #f)
     stale!
     1
     11080, 1> (hashtable-set! ht 'two 2)
     11264, 1> (gc)
     11288, 2> (hashtable-ref ht 'one #f)
     stale!
     1
     11576, 2> (hashtable-set! ht 'three 3)
     11760, 2> (hashtable-ref ht 'two #f)
     2
     11904, 2> (gc)
     11928, 3> (hashtable-ref ht 'one #f)
     1
     12072, 3> (hashtable-ref ht 'two #f)
     stale!
     2
     12360, 3> (hashtable-ref ht 'three #f)
     3

     Note: In case you’re puzzled by the highlighted lines: the symbol
     ‘'one’ must not have been moved by the collection, and so was found
     in the table at the correct location.  Thus *note mps_ld_isstale():
     f7. was not called.  The symbol ‘'two’ did move in the collection,
     so it’s not found in the table, and that causes *note
     mps_ld_isstale(): f7. to be tested.

Don’t forget to check the location dependency for staleness when setting
a value for key in a hash table, and when deleting a key from a hash
table.  Here’s an interaction with the toy Scheme interpreter showing a
key being found to be stale when setting and when deleting it:

     MPS Toy Scheme Example
     13248, 0> (define ht (make-eq-hashtable))
     ht
     13624, 0> (hashtable-set! ht 'a 1)
     13808, 0> (gc)
     13832, 1> (hashtable-set! ht 'a 2)
     stale!
     13832, 1> (hashtable-delete! ht 'one)
     stale!
     14152, 1> (gc)
     14176, 2> (hashtable-delete! ht 'a)
     stale!
     14456, 2> ht
     #[hashtable]

     Note: If the hash table is being used to implement a 'set' (that
     is, there are no values, only keys), and if it doesn’t matter that
     the same key appears twice in the table (under the hashes of its
     old and new addresses) then you may be able to skip the staleness
     check when adding a key.  This is a delicate optimization, however:
     if you needed to iterate over the keys, or maintain a count of
     keys, then it would not work.

*note Location dependency: f8.


File: MemoryPoolSystem.info,  Node: Weak hash tables,  Next: Global symbol table,  Prev: Location dependency,  Up: Advanced topics

1.7.3 Weak hash tables
----------------------

A *note weak-key hash table: fb. has *note weak references (1): c. to
its keys.  If the key dies, the value corresponding to that key is
automatically deleted from the table too.  Similarly, a *note weak-value
hash table: fc. has weak references to its values, and a *note doubly
weak hash table: fd. has weak references to both.

In this section, I’ll describe how to add all three types of weak hash
table to the toy Scheme interpreter.  This requires a few far-reaching
changes to the code, so in order to keep the basic integration
understandable by newcomers to the MPS, I’ve made these changes in a
separate version of the code:

‘scheme-advanced.c’

     The Scheme interpreter after a number of “advanced” features,
     including weak hash tables, have been implemented.

The MPS supports weak references only in *note roots: 97. and in blocks
allocated in pools belonging to the *note AWL (Automatic Weak Linked):
fe. pool class.  Roots aren’t convenient for this use case: it’s
necessary for hash tables to be automatically reclaimed when they die.
So AWL it is.

     Note: This isn’t a design limitation of the MPS: it’s just that up
     until now the only uses our customers have had for weak references
     are the ones supported by AWL. (In particular, AWL was designed
     around the requirements of weak hash tables in Open Dylan(1).)  If
     you need more general handling of weak references, *note contact
     us: d8.

All the references in a *note formatted object: 23. belong to the same
*note rank: 9e.: that is, they are all *note exact: 61, *note weak: c,
or *note ambiguous references: 9f.  In AWL, the rank of references is
specified when creating an *note allocation point: 63.  This has
consequences for the design of the hash table data structure: in
weak-key strong-value hash tables, the keys need to be in one object and
the values in another (and the same is true in the strong-key weak-value
case).  So instead of having one vector of buckets with alternate keys
and values, hash tables must have two vectors, one for the keys and the
other for the values, to allow keys and values to have different ranks.

These vectors will be allocated from an AWL pool with two allocation
points, one for strong references, and one for weak references:

     static mps_pool_t buckets_pool; /* pool for hash table buckets */
     static mps_ap_t strong_buckets_ap; /* allocation point for strong buckets */
     static mps_ap_t weak_buckets_ap; /* allocation point for weak buckets */

     Note: It’s not necessary to allocate the strong buckets from the
     same pool as the weak buckets, but we’ll see below that they have
     to be allocated in a 'non-moving' pool such as AWL.

The MPS 'splats' a weak reference in a *note formatted object: 23. by
replacing it with a null pointer when it is *note fixed: b4. by the
object format’s *note scan method: 73.  So the scan method for the
buckets is going to have the following structure.  (See below for the
actual code.)

     static mps_res_t buckets_scan(mps_ss_t ss, mps_addr_t base, mps_addr_t limit)
     {
         MPS_SCAN_BEGIN(ss) {
             while (base < limit) {
                 buckets_t buckets = base;
                 size_t length = buckets->length;
                 for (i = 0; i < length; ++i) {
                     mps_addr_t p = buckets->bucket[i];
                     if (MPS_FIX1(ss, p)) {
                         mps_res_t res = MPS_FIX2(ss, &p);
                         if (res != MPS_RES_OK) return res;
                         if (p == NULL) {
                             /* TODO: key/value was splatted: splat value/key too */
                         }
                         buckets->bucket[i] = p;
                     }
                 }
                 base = (char *)base +
                     ALIGN_OBJ(offsetof(buckets_s, bucket) +
                               length * sizeof(buckets->bucket[0]));
             }
         } MPS_SCAN_END(ss);
         return MPS_RES_OK;
     }

But how can the corresponding key/value be splatted?  A format method is
not normally allowed to access memory managed by the MPS in pools that
might protect their objects (see the *note Cautions: c0. section in
*note Object formats: 6a.).  The AWL pool class relaxes this constraint
by allowing each object in the pool to have a *note dependent object:
ff.  When *note scanning: 65. an object in an AWL pool, the MPS ensures
that the dependent object is not protected.  The dependent object does
not have to be in the same pool as the original object, but must be in a
non-moving pool.  See *note Dependent objects: 100.

So the value buckets will be the dependent object of the key buckets,
and vice versa.

The AWL pool determines an object’s dependent object by calling a
function that you supply when creating the pool.  This means that each
object needs to have a reference to its dependent object:

     static mps_addr_t buckets_find_dependent(mps_addr_t addr)
     {
         buckets_t buckets = addr;
         return buckets->dependent;
     }

There’s one final requirement to take into account before revealing the
new buckets structure, which is that each word in an object in an AWL
pool must either be a valid word-aligned reference, or else the bottom
bits of the word must be non-zero so that it does not look like an
aligned pointer.  So the sizes stored in the buckets structure (the
length of the array of buckets, and the counts of used and deleted
buckets) must be tagged so that they cannot be mistaken for pointers.
See the *note Caution: 101. section in *note AWL (Automatic Weak
Linked): fe.

A one-bit tag suffices here:

     #define TAG_COUNT(i) (((i) << 1) + 1)
     #define UNTAG_COUNT(i) ((i) >> 1)

     typedef struct buckets_s {
         struct buckets_s *dependent;  /* the dependent object */
         size_t length;                /* number of buckets (tagged) */
         size_t used;                  /* number of buckets in use (tagged) */
         size_t deleted;               /* number of deleted buckets (tagged) */
         obj_t bucket[1];              /* hash buckets */
     } buckets_s, *buckets_t;

Now the full details of the scan method can be given, with the revised
code highlighted:

     static mps_res_t buckets_scan(mps_ss_t ss, mps_addr_t base, mps_addr_t limit)
     {
         MPS_SCAN_BEGIN(ss) {
             while (base < limit) {
                 buckets_t buckets = base; /* see note 1 */
                 size_t i, length = UNTAG_COUNT(buckets->length);
                 FIX(buckets->dependent);
                 if(buckets->dependent != NULL)
                     assert(buckets->dependent->length == buckets->length);
                 for (i = 0; i < length; ++i) {
                     mps_addr_t p = buckets->bucket[i];
                     if (MPS_FIX1(ss, p)) {
                         mps_res_t res = MPS_FIX2(ss, &p);
                         if (res != MPS_RES_OK) return res;
                         if (p == NULL) {
                             /* key/value was splatted: splat value/key too */
                             p = obj_deleted; /* see note 3 */
                             buckets->deleted = TAG_COUNT(UNTAG_COUNT(buckets->deleted) + 1);
                             if (buckets->dependent != NULL) { /* see note 2 */
                                 buckets->dependent->bucket[i] = p;
                                 buckets->dependent->deleted
                                     = TAG_COUNT(UNTAG_COUNT(buckets->dependent->deleted) + 1);
                             }
                         }
                         buckets->bucket[i] = p;
                     }
                 }
                 base = (char *)base + ALIGN_OBJ(offsetof(buckets_s, bucket) +
                                                 length * sizeof(buckets->bucket[0]));
             }
         } MPS_SCAN_END(ss);
         return MPS_RES_OK;
     }

     Note: 
       1. There’s no need to dispatch on the type of the buckets object
          (or even to store a type at all) because buckets are the only
          objects to be stored in this pool.

       2. The dependent object must be *note fixed: b4, and because the
          reference to it might be weak, it might be splatted.  This
          means that even if you are confident that you will always
          initialize this field, you still have to guard access to it,
          as here.

       3. This hash table implementation uses ‘NULL’ to mean “never
          used” and ‘obj_deleted’ to mean “formerly used but then
          deleted”.  So when a key is splatted it is necessary to
          replace it with ‘obj_deleted’.

The *note skip method: 81. is straightforward:

     static mps_addr_t buckets_skip(mps_addr_t base)
     {
         buckets_t buckets = base;
         size_t length = UNTAG_SIZE(buckets->length);
         return (char *)base + ALIGN_OBJ(offsetof(buckets_s, bucket) +
                                         length * sizeof(buckets->bucket[0]));
     }

Now we can create the object format, the pool and the allocation points:

     /* Create the buckets format. */
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_FMT_ALIGN, ALIGNMENT);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_SCAN, buckets_scan);
         MPS_ARGS_ADD(args, MPS_KEY_FMT_SKIP, buckets_skip);
         res = mps_fmt_create_k(&buckets_fmt, arena, args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create buckets format");

     /* Create an Automatic Weak Linked (AWL) pool to manage the hash table
        buckets. */
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_FORMAT, buckets_fmt);
         MPS_ARGS_ADD(args, MPS_KEY_AWL_FIND_DEPENDENT, buckets_find_dependent);
         res = mps_pool_create_k(&buckets_pool, arena, mps_class_awl(), args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create buckets pool");

     /* Create allocation points for weak and strong buckets. */
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_RANK, mps_rank_exact());
         res = mps_ap_create_k(&strong_buckets_ap, buckets_pool, args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create strong buckets allocation point");
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_RANK, mps_rank_weak());
         res = mps_ap_create_k(&weak_buckets_ap, buckets_pool, args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create weak buckets allocation point");

By adding the line:

     puts("splat!");

at the point in ‘buckets_scan()’ where the splatting of a weak reference
is detected, we can see this happening:

     MPS Toy Scheme Example
     24624, 0> (define ht (make-doubly-weak-hashtable string-hash string=?))
     ht
     25264, 0> (hashtable-set! ht "one" 1)
     25456, 0> (hashtable-set! ht "two" 2)
     25648, 0> (hashtable-set! ht "three" 3)
     25840, 0> ht
     #[hashtable ("two" 2) ("one" 1) ("three" 3)]
     25864, 0> (gc)
     splat!
     splat!
     splat!
     25912, 1> ht
     #[hashtable]

*note Weak references: 102, *note AWL (Automatic Weak Linked): fe.

   ---------- Footnotes ----------

   (1) https://opendylan.org/


File: MemoryPoolSystem.info,  Node: Global symbol table,  Next: Segregation of objects,  Prev: Weak hash tables,  Up: Advanced topics

1.7.4 Global symbol table
-------------------------

In the original (non-MPS) version of the toy Scheme interpreter, the
global symbol table was implemented as a key-only hash table, and each
symbol stored its own name.

But now that we have weak hash tables, it makes sense to re-implement
the global symbol table as a strong-key weak-value hash table mapping
strings to symbols.  Each symbol will now contain a reference to its
name as a string object, instead of containing the name itself.

 [image src="MemoryPoolSystem-figures/symbol-table.svg" alt="Diagram: Global symbol table design (weak references shown as dashed lines)." ]


Figure: Global symbol table design (weak references shown as dashed
lines).

This design depends on the string object containing the symbol name
being immutable.  As it happens, all strings are immutable, because the
toy Scheme interpreter doesn’t implement ‘string-set!’, but if it did
then some care would need to be taken.  (Either by marking these strings
as immutable in some way, or by ensuring that these strings are
“private”: that is, that Scheme programs never get hold of references to
them.)

When there are no more strong references to a symbol:

  1. the reference to the symbol from the “values” array may be
     splatted;

  2. that’s detected by the buckets scan method, which deletes the
     corresponding entry in the “keys” array;

  3. which may in turn cause the symbol name to die, unless there are
     other strong references keeping it alive.

Here’s the new symbol structure:

     typedef struct symbol_s {
         type_t type;                  /* TYPE_SYMBOL */
         obj_t name;                   /* its name (a string) */
     } symbol_s;

and the new implementation of ‘intern()’:

     static obj_t intern_string(obj_t name)
     {
         obj_t symbol;
         assert(TYPE(name) == TYPE_STRING);
         symbol = table_ref(symtab, name);
         if(symbol == NULL) {
             symbol = make_symbol(name);
             table_set(symtab, name, symbol);
         }
         return symbol;
     }

     static obj_t intern(char *string)
     {
         return intern_string(make_string(strlen(string), string));
     }

The symbol table now becomes a very simple *note root: 97, that only has
to be registered once (not *note every time it is rehashed: 94, as
previously):

     mps_addr_t ref;
     symtab = NULL;
     ref = &symtab;
     res = mps_root_create_table(&symtab_root, arena, mps_rank_exact(), 0,
                                 ref, 1);
     if(res != MPS_RES_OK) error("Couldn't register symtab root");
     symtab = make_table(16, string_hash, string_equalp, 0, 1);

     Note: The order of operations is important here.  The global
     variable ‘symtab’ must be registered as a root before creating the
     symbol table, otherwise the symbol table might be collected in the
     interval between creation and registration.  But we must also
     ensure that ‘symtab’ is valid (that is, scannable) before
     registering it (in this case, by setting it to ‘NULL’).

By printing ‘splat!’ when the splatting of a weak reference is detected
by the scan method, we can see when symbols are dying:

     MPS Toy Scheme Example
     24624, 0> (define a 1)
     a
     24832, 0> '(a b c d)
     (a b c d)
     25144, 0> (gc)
     splat!
     splat!
     splat!

Here, the symbols ‘b’, ‘c’ and ‘d’ died, but ‘a’ was kept alive by the
reference from the environment.


File: MemoryPoolSystem.info,  Node: Segregation of objects,  Prev: Global symbol table,  Up: Advanced topics

1.7.5 Segregation of objects
----------------------------

When objects of different types have different properties (different
sizes, lifetimes, references, layouts) it makes sense to segregate them
into pools of appropriate classes.  The garbage collector in the MPS is
designed to work efficiently with many pools: it traces references
between objects in different pools, and it coordinates the scanning of
the *note registers: 26. and *note control stacks: 27. (see *note Thread
roots: 106.).

For example, the toy Scheme interpreter has a mixture of object types,
some of which contain references to other objects (for example, pairs)
that must be *note scanned: 65, and some of which do not (for example,
strings).  If the *note leaf objects: 107. are segregated into a pool of
an appropriate class, the cost of scanning them can be avoided.

Here the appropriate class is *note AMCZ (Automatic Mostly-Copying
Zero-rank): 89, and the necessary code changes are straightforward.
First, global variables for the new pool and its *note allocation point:
63.:

     static mps_pool_t leaf_pool;    /* pool for leaf objects */
     static mps_ap_t leaf_ap;        /* allocation point for leaf objects */

Second, the leaf objects must be allocated on ‘leaf_ap’ instead of
‘obj_ap’.  And third, the pool and its allocation point must be created:

     /* Create an Automatic Mostly-Copying Zero-rank (AMCZ) pool to
        manage the leaf objects. */
     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_CHAIN, obj_chain);
         MPS_ARGS_ADD(args, MPS_KEY_FORMAT, obj_fmt);
         res = mps_pool_create_k(&leaf_pool, arena, mps_class_amcz(), args);
     } MPS_ARGS_END(args);
     if (res != MPS_RES_OK) error("Couldn't create leaf pool");

     /* Create allocation point for leaf objects. */
     res = mps_ap_create_k(&leaf_ap, leaf_pool, mps_args_none);
     if (res != MPS_RES_OK) error("Couldn't create leaf objects allocation point");

Note that the new pool shares a *note generation chain: e2. with the old
pool.  This is important, because the leaf objects live and die along
with the non-leaf objects of similar ages.

As an initial step in making this change, the new pool uses the same
*note object format: 39.  However, we normally wouldn’t stop there: we’d
take advantage of the segregation to simplify the scanning of the
objects that have been left behind.

*note AMCZ (Automatic Mostly-Copying Zero-rank): 89.


File: MemoryPoolSystem.info,  Node: Implementing malloc and free,  Prev: Advanced topics,  Up: Guide

1.8 Implementing malloc and free
================================

The MPS function *note mps_free(): 1f. is unlike the Standard C Library
function ‘free()’ in that it takes a ‘size’ argument.  That’s because
it’s nearly always the case that either the size of a block is known
statically based on its type (for example, a structure), or else the
size of the block is easily computed from information that needs to be
stored anyway (for example, a vector), and so memory can be saved by not
storing the size separately.  It’s also better for virtual memory
performance, as a block does not have to be touched in order to free it.

But sometimes you need to interact with *note foreign code: 10b. which
requires ‘malloc()’ and ‘free()’ (or a pair of functions with the same
interface).  In this situation you can implement this interface using a
global pool variable, and putting the size of each block into its
header, like this:

     #include "mps.h"

     static mps_pool_t malloc_pool;

     typedef union {
         size_t size;
         char alignment[MPS_PF_ALIGN]; /* see note below */
     } header_u;

     void *malloc(size_t size) {
         mps_res_t res;
         mps_addr_t p;
         header_u *header;
         size += sizeof *header;
         res = mps_alloc(&p, malloc_pool, size);
         if (res != MPS_RES_OK)
             return NULL;
         header = p;
         header->size = size;
         return header + 1;
     }

     void free(void *p) {
         if (p) {
             header_u *header = ((header_u *)p) - 1;
             mps_free(malloc_pool, header, header->size);
         }
     }

The ‘alignment’ member of the ‘header_u’ union ensures that allocations
are aligned to the platform’s *note natural alignment: 70. (see *note
Alignment: 6c.).

The pool needs to belong to a *note manually managed: 8. pool class, for
example *note MVFF (Manual Variable First Fit): 10c. (or its *note
debugging counterpart: 10d.):

     #include "mpscmvff.h"

     void malloc_pool_init(mps_arena_t arena) {
         mps_res_t res;
         res = mps_pool_create_k(&malloc_pool, arena, mps_class_mvff(), mps_args_none);
         if (res != RES_OK)
             abort();
     }


File: MemoryPoolSystem.info,  Node: Reference,  Next: Pool reference,  Prev: Guide,  Up: Top

2 Reference
***********

* Menu:

* Interface conventions::
* Keyword arguments::
* Error handing::
* Arenas::
* Pools::
* Allocation: Allocation<2>.
* Object formats::
* Scanning::
* Threads: Threads<2>.
* Roots: Roots<2>.
* Garbage collection::
* Messages::
* Finalization: Finalization<2>.
* Location dependency: Location dependency<2>.
* Segregated allocation caches::
* Allocation patterns::
* Allocation frames::
* Debugging pools::
* Telemetry::
* Weak references::
* Transforms::
* Plinth::
* Platforms: Platforms<2>.
* Porting the MPS::
* Deprecated interfaces::
* Security issues::


File: MemoryPoolSystem.info,  Node: Interface conventions,  Next: Keyword arguments,  Up: Reference

2.1 Interface conventions
=========================

This document describes the conventions used in the programming
interface to the Memory Pool System.  It also contains our *note policy
for support for the public identifiers: 113. and *note definitions of
general types: 114. that appear throughout the interface.

* Menu:

* Support policy::
* Language::
* Headers::
* Identifiers::
* Types::
* Functions::
* Type punning::
* Macros::
* General types::


File: MemoryPoolSystem.info,  Node: Support policy,  Next: Language,  Up: Interface conventions

2.1.1 Support policy
--------------------

  1. We support the documented behaviour of public symbols in the MPS
     interface.  We will only remove these symbols or change their
     behaviour in a new version, and not in a patch release.  Normally
     we will give one version’s notice before removing a symbol or
     changing a particular documented behaviour: that is, there will be
     a version in which the symbol (or reliance on some of its
     behaviour) is deprecated.

     Symbols may be deprecated in their old place in the reference
     manual, or they may be moved to the *note Deprecated interfaces:
     116. chapter.

          Note: If you are relying on a feature and you see that it’s
          deprecated, please *note contact us: d8.  It makes a
          difference if we know that someone is using a feature.

  2. Behaviour that is not documented in the *note Guide: 3, *note
     Reference: 30, or *note Pool reference: 22. is not supported and
     may change without notice in future releases.  In particular,
     private identifiers may disappear or their behaviour be changed
     without notice in future releases.


File: MemoryPoolSystem.info,  Node: Language,  Next: Headers,  Prev: Support policy,  Up: Interface conventions

2.1.2 Language
--------------

  1. The MPS public interface conforms to *note ANSI/ISO Standard C (IEC
     9899;1990): 118.


File: MemoryPoolSystem.info,  Node: Headers,  Next: Identifiers,  Prev: Language,  Up: Interface conventions

2.1.3 Headers
-------------

  1. The main interface is in the header ‘mps.h’.  This header contains
     all the core MPS interfaces.  In practice, you always need at least
     one arena class and one pool class header file as well.

  2. We will always prefix public header file names with ‘mps’ to avoid
     clashes.  We reserve the right to create new headers with names
     beginning with ‘mps’ in future versions.

  3. *note Pool class: 10. headers have names beginning with ‘mpsc’.
     For example, the header for *note AMC (Automatic Mostly-Copying):
     62. is ‘mpscamc.h’.

  4. *note Arena class: 11a. headers have names beginning with ‘mpsa’.
     For example, the header for the *note virtual memory arena: 4f.
     class is ‘mpsavm.h’.


File: MemoryPoolSystem.info,  Node: Identifiers,  Next: Types,  Prev: Headers,  Up: Interface conventions

2.1.4 Identifiers
-----------------

  1. Identifiers are in lower case, except for preprocessor constants
     and macros that do not behave like functions, which are in upper
     case.  Words are joined by underscores.

  2. All identifiers are either 'public' or 'private'.

  3. The names of public types, functions, variables, and macros start
     with ‘mps_’ or ‘MPS_’.  The names of public structure members start
     with any letter.

  4. Private identifiers start with an underscore ‘_’.

  5. Type names end with ‘_t’, except for structure and union types.

  6. The names of structure types and tags end with ‘_s’.

  7. The names of union types and tags end with ‘_u’.


File: MemoryPoolSystem.info,  Node: Types,  Next: Functions,  Prev: Identifiers,  Up: Interface conventions

2.1.5 Types
-----------

There are two kinds of types declared in the MPS interface: 'transparent
types' and 'opaque types'.

  1. A 'transparent type' is an alias defined using ‘typedef’, and this
     is documented so that the *note client program: d0. can rely on
     that fact.  For example, *note mps_addr_t: 11d. is a transparent
     alias for ‘void *’.  Transparent types express intentions in the
     interface: in the case of *note mps_addr_t: 11d. it represents a
     pointer that is under the control of the MPS.

  2. An 'opaque type' is a pointer to an incomplete structure type.  The
     client program must not rely on details of its implementation.  For
     example, the type *note mps_arena_t: 11e. is an alias for ‘struct
     mps_arena_s *’, but the implementation of ‘struct mps_arena_s’ is
     not public.

     There are a few structure types that are declared in ‘mps.h’ but
     whose implementation is not public.  These only exist so that code
     can be inlined using macros.  The most important of these is the
     *note scan state: 79. structure ‘mps_ss_s’, which is accessed by
     scanning macros such as *note MPS_SCAN_BEGIN: 7a. and *note
     MPS_FIX12(): 77.


File: MemoryPoolSystem.info,  Node: Functions,  Next: Type punning,  Prev: Types,  Up: Interface conventions

2.1.6 Functions
---------------

  1. Operations that might fail return a *note result code: 59, rather
     than a “special value” of the return type.  See *note Error
     handing: 5b.

  2. A function that needs to return a value as well as a result code
     returns the value via an *note out parameter: 58, a parameter that
     points to a location to store the result.

  3. A function that stores a result in the location pointed to by an
     out parameter only does so if the function is successful (that is,
     if the function returns *note MPS_RES_OK: 5a.).

  4. The value in the location pointed to by an out parameter is not
     read by the function.

  5. Out parameters have names ending with ‘_o’.

  6. A function that both needs to read a value stored in a location and
     update the value does so via an *note in/out parameter: 120, which
     is the same as an out parameter except that the location it points
     to is read by the function.  See for example *note MPS_FIX12(): 77.

  7. In/out parameters have names ending with ‘_io’.

  8. A function that takes optional arguments does so in the form of an
     array of keyword argument structures.  These functions have names
     ending with ‘_k’.  See *note Keyword arguments: 57.


File: MemoryPoolSystem.info,  Node: Type punning,  Next: Macros,  Prev: Functions,  Up: Interface conventions

2.1.7 Type punning
------------------

It’s tempting to use a type cast to change the type of an in/out or out
parameter, like this:

     /* allocate a struct foo */
     struct foo *fp;
     res = mps_alloc((mps_addr_t *)&fp, pool, sizeof(struct foo));

This is known as *note type punning: a5, and its behaviour is not
defined in ANSI/ISO Standard C. See *note ISO/IEC 9899;1990: 118.
§6.3.2.3, which defines the conversion of a pointer from one type to
another: the behaviour of this cast is not covered by any of the cases
in the standard.

Instead, we recommend this approach:

     mps_addr_t p;
     struct foo *fp;
     res = mps_alloc(&p, pool, sizeof(struct foo));
     if (res != MPS_RES_OK)
         /* handle error case */;
     fp = p;

This has defined behaviour because conversion from ‘void *’ to any other
*note object pointer: 6e. type is defined by *note ISO/IEC 9899;1990:
118. §6.3.2.3.1.


File: MemoryPoolSystem.info,  Node: Macros,  Next: General types,  Prev: Type punning,  Up: Interface conventions

2.1.8 Macros
------------

  1. For function-like macros, the MPS follows the same convention as
     the Standard C library.  To quote *note ISO/IEC 9899;1990: 118.
     §7.1.7:

          Any function declared in a header may additionally be
          implemented as a macro defined in the header, so a library
          function should not be declared explicitly if its header is
          included.  Any macro definition of a function can be
          suppressed locally by enclosing the name of the function in
          parentheses, because the name is then not followed by the left
          parenthesis that indicates expansion of a macro function name.
          […] Any invocation of a library function that is implemented
          as a macro shall expand to code that evaluates each of its
          arguments exactly once, fully protected by parentheses where
          necessary, so it is generally safe to use arbitrary
          expressions as arguments.

  2. Some function-like macros evaluate an argument more than once, so
     it is not safe to have a side effect in an argument of such a
     method.  These special cases are documented.  For example, *note
     mps_reserve(): b0.

  3. If you need the function rather than the macro, there are two
     approaches.  You can undefine the macro:

          #undef mps_reserve
          res = mps_reserve(...);  /* calls function */

     Or you can put the name in parentheses:

          res = (mps_reserve)(...);  /* calls function */

  4. Statement-like macros have names in uppercase, for example *note
     MPS_RESERVE_BLOCK: 124.  These macros behave like statements rather
     than expressions, so that you cannot write:

          (MPS_RESERVE_BLOCK(res, p, ap, size), 0)

  5. Details of the macro expansion, although visible in the header
     file, are not part of the MPS interface, and might change between
     releases.  Don’t rely on them, unless they are documented
     separately.


File: MemoryPoolSystem.info,  Node: General types,  Prev: Macros,  Up: Interface conventions

2.1.9 General types
-------------------

 -- C Type: type mps_addr_t

     The type of *note addresses: 126. managed by the MPS, and also the
     type of *note references: 24.

     It is a *note transparent alias: 127. for ‘void *’.

     It is used in the MPS interface for any pointer that is under the
     control of the MPS. In accordance with standard *note C: 1c.
     practice, null pointers of type *note mps_addr_t: 11d. will never
     be used to represent a reference to a block.

 -- C Type: type mps_align_t

     The type of an *note alignment: 68.

     It is a *note transparent alias: 127. for ‘size_t’.

     An alignment must be a positive power of 2.

 -- C Type: type mps_bool_t

     The type of a Boolean value.

     It is a *note transparent alias: 127. for ‘int’.

     When used as an input parameter to the MPS, a value of 0 means
     “false” and any other value means “true”.  As an output parameter
     or function return from the MPS, 0 means “false”, and 1 means
     “true”.

 -- C Type: type mps_clock_t

     The type of a processor time.

     It is a *note transparent alias: 127. for *note mps_word_t: 6d.

     This is the type returned by the plinth function *note mps_clock():
     12b.

 -- C Type: type mps_fun_t

     The type of a generic function pointer.

     It is a *note transparent alias: 127. for ‘void (*)(void)’.

 -- C Type: type mps_label_t

     The type of a *note telemetry label: 12e.

     It is an unsigned integral type.

 -- C Type: type mps_word_t

     An unsigned integral type that is the same size as an *note object
     pointer: 6e, so that ‘sizeof(mps_word_t) == sizeof(void *)’.

     The exact identity of this type is *note platform: 12f.-dependent.
     Typical identities are ‘unsigned long’ and ‘unsigned __int_64’.

     *note Platforms: 130.


File: MemoryPoolSystem.info,  Node: Keyword arguments,  Next: Error handing,  Prev: Interface conventions,  Up: Reference

2.2 Keyword arguments
=====================

Some functions in the MPS interface take *note keyword arguments: 53. in
order to pass values that might be optional, or are only required in
some circumstances.  For example, the function *note
mps_arena_create_k(): 52. creates any class of *note arena: 16, but
*note client arenas: 4d. require you to specify a base address.  These
arguments are passed in a keyword argument array, like this:

     mps_res_t res;
     mps_arena_t arena;
     mps_arg_s args[3];
     args[0].key = MPS_KEY_ARENA_SIZE;
     args[0].val.size = 6553600;
     args[1].key = MPS_KEY_ARENA_CL_BASE;
     args[1].val.addr = base_address;
     args[2].key = MPS_KEY_ARGS_END;
     res = mps_arena_create_k(&arena, mps_arena_class_cl(), args);

Each keyword argument in the array is a structure of type *note
mps_arg_s: 56.

For convenience and robustness, the MPS interface includes macros to
help with forming keyword argument lists:

     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_ARENA_SIZE, 6553600);
         MPS_ARGS_ADD(args, MPS_KEY_ARENA_CL_BASE, base_address);
         res = mps_arena_create_k(&arena, mps_arena_class_cl(), args);
     } MPS_ARGS_END(args);

The argument array must not be ‘NULL’, and must end with
‘MPS_KEY_ARGS_END’.  If you don’t want to pass any arguments, you can
pass *note mps_args_none: 133.

When a function that takes keyword arguments returns, the keyword
argument array has been 'modified' to remove any arguments that have
been used.  If all arguments have been used, the first element key is
now ‘MPS_KEY_ARGS_END’.

 -- C Type: type mps_arg_s

     The type of the structure used to represent a single *note keyword
     argument: 53. to a function.

          typedef struct mps_arg_s {
              mps_key_t key;
              union { /* many fields; see table below */ } val;
          } mps_arg_s;

     ‘key’ identifies the key.  It must be one of the values listed in
     the documentation for the type *note mps_key_t: 134.

     ‘val’ is the corresponding value.  This union contains many fields:
     one for each keyword argument type.  The table given in the
     documentation for *note mps_key_t: 134. below indicates which
     structure field is used by each keyword.

          Note: If you use the convenience macro *note MPS_ARGS_ADD:
          135. then you don’t need to know the name of the field.

 -- C Macro: mps_args_none

     An array of *note mps_arg_s: 56. representing the empty list of
     keyword arguments.  Equivalent to:

          mps_arg_s mps_args_none[] = {{MPS_KEY_ARGS_END}};

 -- C Type: type mps_key_t

     The type of *note keyword argument: 53. keys.  Must take one of the
     following values:

     Keyword                                      Type & field in ‘arg.val’                                     See
                                                                                                                
     ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                                                
     ‘MPS_KEY_ARGS_END’                           'none'                                                        'see above'
                                                                                                                
                                                                                                                
     ‘MPS_KEY_ALIGN’                              *note mps_align_t: 128. ‘align’                               *note mps_class_mvff(): 136, *note mps_class_mvt(): 137.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_AMS_SUPPORT_AMBIGUOUS’              *note mps_bool_t: 129. ‘b’                                    *note mps_class_ams(): 138.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_ARENA_CL_BASE’                      *note mps_addr_t: 11d. ‘addr’                                 *note mps_arena_class_cl(): 4e.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_ARENA_GRAIN_SIZE’                   ‘size_t’ ‘size’                                               *note mps_arena_class_vm(): 50, *note mps_arena_class_cl(): 4e.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_ARENA_SIZE’                         ‘size_t’ ‘size’                                               *note mps_arena_class_vm(): 50, *note mps_arena_class_cl(): 4e.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_AWL_FIND_DEPENDENT’                 ‘void *(*)(void *)’ ‘addr_method’                             *note mps_class_awl(): 139.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_CHAIN’                              *note mps_chain_t: 13a. ‘chain’                               *note mps_class_amc(): 13b, *note mps_class_amcz(): 13c, *note mps_class_ams(): 138, *note mps_class_awl(): 139, *note mps_class_lo(): 13d.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_COMMIT_LIMIT’                       ‘size_t’ ‘size’                                               *note mps_arena_class_vm(): 50, *note mps_arena_class_cl(): 4e.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_EXTEND_BY’                          ‘size_t’ ‘size’                                               *note mps_class_amc(): 13b, *note mps_class_amcz(): 13c, *note mps_class_mfs(): 13e, *note mps_class_mvff(): 136.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_ALIGN’                          *note mps_align_t: 128. ‘align’                               *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_CLASS’                          *note mps_fmt_class_t: 140. ‘fmt_class’                       *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_FWD’                            *note mps_fmt_fwd_t: 86. ‘fmt_fwd’                            *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_HEADER_SIZE’                    ‘size_t’ ‘size’                                               *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_ISFWD’                          *note mps_fmt_isfwd_t: 8d. ‘fmt_isfwd’                        *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_PAD’                            *note mps_fmt_pad_t: 91. ‘fmt_pad’                            *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_SCAN’                           *note mps_fmt_scan_t: 74. ‘fmt_scan’                          *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FMT_SKIP’                           *note mps_fmt_skip_t: 82. ‘fmt_skip’                          *note mps_fmt_create_k(): 13f.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_FORMAT’                             *note mps_fmt_t: 141. ‘format’                                *note mps_class_amc(): 13b, *note mps_class_amcz(): 13c, *note mps_class_ams(): 138, *note mps_class_awl(): 139, *note mps_class_lo(): 13d. ,
                                                                                                                *note mps_class_snc(): 142.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_GEN’                                ‘unsigned’ ‘u’                                                *note mps_class_ams(): 138, *note mps_class_awl(): 139, *note mps_class_lo(): 13d.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_INTERIOR’                           *note mps_bool_t: 129. ‘b’                                    *note mps_class_amc(): 13b, *note mps_class_amcz(): 13c.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MEAN_SIZE’                          ‘size_t’ ‘size’                                               *note mps_class_mvt(): 137, *note mps_class_mvff(): 136.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MFS_UNIT_SIZE’                      ‘size_t’ ‘size’                                               *note mps_class_mfs(): 13e.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MIN_SIZE’                           ‘size_t’ ‘size’                                               *note mps_class_mvt(): 137.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MVFF_ARENA_HIGH’                    *note mps_bool_t: 129. ‘b’                                    *note mps_class_mvff(): 136.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MVFF_FIRST_FIT’                     *note mps_bool_t: 129. ‘b’                                    *note mps_class_mvff(): 136.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MVFF_SLOT_HIGH’                     *note mps_bool_t: 129. ‘b’                                    *note mps_class_mvff(): 136.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MVT_FRAG_LIMIT’                     *note mps_word_t: 6d. ‘count’                                 *note mps_class_mvt(): 137.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_MVT_RESERVE_DEPTH’                  *note mps_word_t: 6d. ‘count’                                 *note mps_class_mvt(): 137.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_PAUSE_TIME’                         ‘double’ ‘d’                                                  *note mps_arena_class_vm(): 50, *note mps_arena_class_cl(): 4e.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_POOL_DEBUG_OPTIONS’                 *note mps_pool_debug_option_s: 143. ‘*pool_debug_options’     *note mps_class_ams_debug(): 144, *note mps_class_mvff_debug(): 145.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_RANK’                               *note mps_rank_t: 146. ‘rank’                                 *note mps_class_ams(): 138, *note mps_class_awl(): 139, *note mps_class_snc(): 142.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_SPARE’                              ‘double’ ‘d’                                                  *note mps_arena_class_vm(): 50, *note mps_class_mvff(): 136.
                                                                                                                
                                                                                                                
     *note MPS_KEY_SPARE_COMMIT_LIMIT: 147.       ‘size_t’ ‘size’                                               *note mps_arena_class_vm(): 50.
                                                                                                                
                                                                                                                
     ‘MPS_KEY_VMW3_TOP_DOWN’                      *note mps_bool_t: 129. ‘b’                                    *note mps_arena_class_vm(): 50.
                                                                                                                

 -- C Macro: MPS_ARGS_BEGIN (args)

     Start construction of a list of keyword arguments.  This macro must
     be used like this:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_ARENA_SIZE, 6553600);
              MPS_ARGS_ADD(args, MPS_KEY_ARENA_CL_BASE, base_address);
              res = mps_arena_create_k(&arena, mps_arena_class_cl(), args);
          } MPS_ARGS_END(args);

     That is, you must call *note MPS_ARGS_ADD: 135. (or *note
     MPS_ARGS_ADD_FIELD: 149.) zero or more times, and then pass the
     arguments to a function.

     ‘args’ is the name of the array that contains the keyword
     arguments.  The array is stack-allocated, and exists between *note
     MPS_ARGS_BEGIN: 148. and *note MPS_ARGS_END: 14a.

     It is safe to nest blocks created by *note MPS_ARGS_BEGIN: 148. and
     *note MPS_ARGS_END: 14a.

 -- C Macro: MPS_ARGS_ADD (args, key, value)

     Add an argument to a list of keyword arguments.  This macro must be
     used only between *note MPS_ARGS_BEGIN: 148. and *note
     MPS_ARGS_END: 14a.

     ‘args’ is the name of array that contains the keyword arguments.
     It must match the argument to the preceding call to *note
     MPS_ARGS_BEGIN: 148.

     ‘key’ is the keyword identifying this argument.  It must be one of
     the key names starting with ‘MPS_KEY_’ that are listed in the table
     in the documentation for *note mps_key_t: 134.

     ‘value’ is the value for this argument.

 -- C Macro: MPS_ARGS_ADD_FIELD (args, key, field, value)

     Add an argument to a list of keyword arguments.  This macro must be
     used only between *note MPS_ARGS_BEGIN: 148. and *note
     MPS_ARGS_END: 14a.

     ‘args’ is the name of array that contains the keyword arguments.
     It must match the argument to the preceding call to *note
     MPS_ARGS_BEGIN: 148.

     ‘key’ is the keyword identifying this argument.

     ‘field’ is the name of the field in the ‘val’ union in the
     structure ‘mps_args_s’.

     ‘value’ is the value for this argument.

          Note: You should prefer to use *note MPS_ARGS_ADD: 135,
          because then you don’t need to look up the name of the field.

 -- C Macro: MPS_ARGS_END (args)

     Finish using a list of keyword arguments whose construction was
     started by *note MPS_ARGS_BEGIN: 148.

     ‘args’ is the name of array that contains the keyword arguments.
     It must match the argument to the preceding call to *note
     MPS_ARGS_BEGIN: 148.


File: MemoryPoolSystem.info,  Node: Error handing,  Next: Arenas,  Prev: Keyword arguments,  Up: Reference

2.3 Error handing
=================

Operations in the Memory Pool System that might fail return a *note
result code: 59. of type *note mps_res_t: 14d.  Success is always
indicated by the result code *note MPS_RES_OK: 5a, which is defined to
be zero.  Other result codes indicate failure, and are non-zero.  The
MPS never uses a “special value” of some other type to indicate failure
(such as returning ‘NULL’ for a pointer result, or −1 for a size
result).

     Note: The MPS does not throw or catch exceptions.  (This is
     necessary for the MPS to be portable to systems that have only a
     *note freestanding: 14e. implementation of the C language.)

The modular nature of the MPS means that it is not usually possible for
a function description to list the possible error codes that it might
return.  A function in the public interface typically calls methods of
an *note arena class: 11a. and one or more *note pool classes: 10, any
of which might fail.  The MPS is extensible with new arena and pool
classes, which might fail in new and interesting ways, so the only
future-proof behaviour is for a *note client program: d0. to assume that
any MPS function that returns a result code can return 'any' result
code.

 -- C Type: type mps_res_t

     The type of *note result codes: 59.  It is a *note transparent
     alias: 127. for ‘int’, provided for convenience and clarity.

     A result code indicates the success or failure of an operation,
     along with the reason for failure.  As with error numbers in Unix,
     the meaning of a result code depends on the call that returned it.
     Refer to the documentation of the function for the exact meaning of
     each result code.

     The result codes are:

        * *note MPS_RES_OK: 5a.: operation succeeded.

        * *note MPS_RES_FAIL: 14f.: operation failed.

        * *note MPS_RES_IO: 150.: an input/output error occurred.

        * *note MPS_RES_LIMIT: 151.: an internal limitation was
          exceeded.

        * *note MPS_RES_MEMORY: 152.: needed memory could not be
          obtained.

        * *note MPS_RES_RESOURCE: 153.: a needed resource could not be
          obtained.

        * *note MPS_RES_UNIMPL: 154.: operation is not implemented.

        * *note MPS_RES_COMMIT_LIMIT: 155.: the arena’s *note commit
          limit: 156. would be exceeded.

        * *note MPS_RES_PARAM: 157.: an invalid parameter was passed.

* Menu:

* Result codes::
* Assertions::
* Varieties::


File: MemoryPoolSystem.info,  Node: Result codes,  Next: Assertions,  Up: Error handing

2.3.1 Result codes
------------------

 -- C Macro: MPS_RES_COMMIT_LIMIT

     A *note result code: 59. indicating that an operation could not be
     completed as requested without exceeding the *note commit limit:
     156.

     You need to deallocate something or allow the *note garbage
     collector: 20. to reclaim something to make more space, or increase
     the commit limit by calling *note mps_arena_commit_limit_set():
     15a.

 -- C Macro: MPS_RES_FAIL

     A *note result code: 59. indicating that something went wrong that
     does not fall under the description of any other result code.

 -- C Macro: MPS_RES_IO

     A *note result code: 59. indicating that an input/output error
     occurred in the *note telemetry system: 15b.

 -- C Macro: MPS_RES_LIMIT

     A *note result code: 59. indicating that an operation could not be
     completed as requested because of an internal limitation of the
     MPS.

 -- C Macro: MPS_RES_MEMORY

     A *note result code: 59. indicating that an operation could not be
     completed because there wasn’t enough memory available.

     You need to deallocate something or allow the *note garbage
     collector: 20. to reclaim something to free enough memory, or
     extend the *note arena: 16. (if you’re using an arena for which
     that does not happen automatically).

          Note: Failing to acquire enough memory because the *note
          commit limit: 156. would have been exceeded is indicated by
          returning *note MPS_RES_COMMIT_LIMIT: 155, not
          ‘MPS_RES_MEMORY’.

          Running out of *note address space: 54. (as might happen in
          *note virtual memory: 51. systems) is indicated by returning
          *note MPS_RES_RESOURCE: 153, not ‘MPS_RES_MEMORY’.

 -- C Macro: MPS_RES_OK

     A *note result code: 59. indicating that an operation succeeded.

     If a function takes an *note out parameter: 58. or an *note in/out
     parameter: 120, this parameter will only be updated if *note
     MPS_RES_OK: 5a. is returned.  If any other result code is returned,
     the parameter will be left untouched by the function.

     *note MPS_RES_OK: 5a. is zero.

 -- C Macro: MPS_RES_PARAM

     A *note result code: 59. indicating that an operation could not be
     completed as requested because an invalid parameter was passed to
     the operation.

 -- C Macro: MPS_RES_RESOURCE

     A *note result code: 59. indicating that an operation could not be
     completed as requested because the MPS could not obtain a needed
     resource.  It can be returned when the MPS runs out of *note
     address space: 54.  If this happens, you need to reclaim memory
     within your process (as for the result code *note MPS_RES_MEMORY:
     152.).

     Two special cases have their own result codes: when the MPS runs
     out of committed memory, it returns *note MPS_RES_MEMORY: 152, and
     when it cannot proceed without exceeding the *note commit limit:
     156, it returns *note MPS_RES_COMMIT_LIMIT: 155.

 -- C Macro: MPS_RES_UNIMPL

     A *note result code: 59. indicating that an operation, or some
     vital part of it, is not implemented.

     This might be returned by functions that are no longer supported,
     or by operations that are included for future expansion, but not
     yet supported.


File: MemoryPoolSystem.info,  Node: Assertions,  Next: Varieties,  Prev: Result codes,  Up: Error handing

2.3.2 Assertions
----------------

Bugs in the *note client program: d0. may violate the invariants that
the MPS relies on.  Most functions in the MPS (in most 'varieties'; see
below) assert the correctness of their data structures, so these bugs
will often be discovered by an assertion failure in the MPS. The section
*note Common assertions and their causes: cb. below lists commonly
encountered assertions and explains the kinds of client program bugs
that can provoke these assertions.

It is very rare for an assertion to indicate a bug in the MPS rather
than the client program, but it is not unknown, so if you have made
every effort to track down the cause (see *note Debugging with the
Memory Pool System: b6.) without luck, *note get in touch: d8.

* Menu:

* Assertion handling::
* Common assertions and their causes::


File: MemoryPoolSystem.info,  Node: Assertion handling,  Next: Common assertions and their causes,  Up: Assertions

2.3.2.1 Assertion handling
..........................

When the MPS detects an assertion failure, it calls the *note plinth:
160. function *note mps_lib_assert_fail(): 161.  Unless you have
replaced the plinth, this behaves as follows:

   - In the *note cool: c8. *note variety: c9, print the assertion
     message to standard error and terminate the program by calling
     ‘abort()’.

   - In the *note hot: 162. and *note rash: 163. varieties, print the
     assertion message to standard error and do 'not' terminate the
     program.

You can change this behaviour by providing your own plinth, or using
*note mps_lib_assert_fail_install(): 164.

In many applications, users don’t want their program terminated when the
MPS detects an error, no matter how severe.  A lot of MPS assertions
indicate that the program is going to crash very soon, but there still
may be a chance for a user to get some useful results or save their
work.  This is why the default assertion handler only terminates in the
*note cool: c8. *note variety: c9.


File: MemoryPoolSystem.info,  Node: Common assertions and their causes,  Prev: Assertion handling,  Up: Assertions

2.3.2.2 Common assertions and their causes
..........................................

This section lists some commonly encountered assertions and suggests
likely causes.  If you encounter an assertion not listed here (or an
assertion that is listed here but for which you discovered a different
cause), please *note let us know: d8. so that we can improve this
documentation.

‘arg.c: MPS_KEY_...’

     A required *note keyword argument: 53. was omitted from a call to
     *note mps_ap_create_k(): af, *note mps_arena_create_k(): 52, *note
     mps_fmt_create_k(): 13f, or *note mps_pool_create_k(): 166.

‘buffer.c: BufferIsReady(buffer)’

     The client program called *note mps_reserve(): b0. twice on the
     same *note allocation point: 63. without calling *note
     mps_commit(): b2.  See *note Allocation point protocol: ae.

‘dbgpool.c: fencepost check on free’

     The client program wrote to a location after the end, or before the
     beginning of an allocated block.  See *note Debugging pools: 10d.

‘dbgpool.c: free space corrupted on release’

     The client program used an object after it was reclaimed.  See
     *note Debugging pools: 10d.

‘format.c: SigCheck Format: format’

     The client program called *note mps_pool_create_k(): 166. for a
     *note pool class: 10. like *note AMC (Automatic Mostly-Copying):
     62. that requires a *note object format: 39, but passed something
     other than a *note mps_fmt_t: 141. for this argument.

‘format.c: format->poolCount == 0’

     The client program called *note mps_fmt_destroy(): 167. on a format
     that was still being used by a pool.  It is necessary to call *note
     mps_pool_destroy(): 168. first.

‘global.c: RingIsSingle(&arena->chainRing)’

     The client program called *note mps_arena_destroy(): 169. without
     destroying all the *note generation chains: e2. belonging to the
     arena.  It is necessary to call *note mps_chain_destroy(): 16a.
     first.

‘global.c: RingIsSingle(&arena->formatRing)’

     The client program called *note mps_arena_destroy(): 169. without
     destroying all the *note object formats: 39. belonging to the
     arena.  It is necessary to call *note mps_fmt_destroy(): 167.
     first.

‘global.c: RingIsSingle(&arenaGlobals->rootRing)’

     The client program called *note mps_arena_destroy(): 169. without
     destroying all the *note roots: 97. belonging to the arena.  It is
     necessary to call *note mps_root_destroy(): a2. first.

‘global.c: RingIsSingle(&arena->threadRing)’

     The client program called *note mps_arena_destroy(): 169. without
     deregistering all the *note threads: 99. belonging to the arena.
     It is necessary to call *note mps_thread_dereg(): 16b. first.

‘global.c: RingLength(&arenaGlobals->poolRing) ==
arenaGlobals->systemPools’

     The client program called *note mps_arena_destroy(): 169. without
     destroying all the *note pools: 18. belonging to the arena.  It is
     necessary to call *note mps_pool_destroy(): 168. first.

‘global.c: PoolHasAttr(pool, AttrGC)’

     The client program called *note mps_finalize(): e8. on a reference
     that does not belong to an *note automatically managed: 9. *note
     pool: 18.

‘lockix.c: res == 0’

‘lockw3.c: lock->claims == 0’

     The client program has made a re-entrant call into the MPS. Look at
     the backtrace to see what it was.  Common culprits are signal
     handlers, assertion handlers, and *note format methods: 69.

‘locus.c: gen->activeTraces == TraceSetEMPTY’

     The client program called *note mps_chain_destroy(): 16a, but there
     was a garbage collection in progress on that chain.  Park the arena
     before destroying the chain, by calling *note mps_arena_park(): b9.

‘mpsi.c: SizeIsAligned(size, BufferPool(buf)->alignment)’

     The client program reserved a block by calling *note mps_reserve():
     b0. but neglected to round the size up to the alignment required by
     the pool’s *note object format: 39.

‘poolams.c: AMS_ALLOCED(seg, i)’

     The client program tried to *note fix: b4. a *note reference: 24.
     to a block in an *note AMS (Automatic Mark and Sweep): 16c. pool
     that died.  This may mean that there was a previous collection in
     which a reference that should have kept the block alive failed to
     be scanned.  Perhaps a *note formatted object: 23. was updated in
     some way that has a race condition?

‘poolsnc.c: foundSeg’

     The client program passed an incorrect ‘frame’ argument to *note
     mps_ap_frame_pop(): 16d.  This argument must be the result from a
     previous call to *note mps_ap_frame_push(): 16e. on the same
     allocation point.

‘seg.c: gcseg->buffer == NULL’

     The client program destroyed a pool without first destroying all
     the allocation points created on that pool.  The allocation points
     must be destroyed first.

‘trace.c: ss->rank < RankEXACT’

     The client program destroyed a pool containing objects registered
     for finalization, and then continued to run the garbage collector.
     See *note Cautions: ef. under *note Finalization: f0, which says,
     “You must destroy these pools by following the ‘safe tear-down’
     procedure described under *note mps_pool_destroy(): 168.”

‘trace.c: RefSetSub(ScanStateUnfixedSummary(ss), SegSummary(seg))’

     The client program’s *note scan method: 73. failed to update a
     reference to an object that moved.  See *note Scanning protocol:
     16f, which says, “If *note MPS_FIX2(): 76. returns *note
     MPS_RES_OK: 5a, it may have updated the reference.  Make sure that
     the updated reference is stored back to the region being scanned.”


File: MemoryPoolSystem.info,  Node: Varieties,  Prev: Assertions,  Up: Error handing

2.3.3 Varieties
---------------

The MPS has three 'varieties' which have different levels of internal
checking, *note Assertions: 15d. and *note Telemetry: db.  The variety
can be selected at compile time, by defining one of the following
preprocessor constants.  If none is specified then *note CONFIG_VAR_HOT:
172. is the default.

 -- C Macro: CONFIG_VAR_COOL

     The 'cool variety' is intended for development and testing.

     All functions check the consistency of their data structures and
     may assert, including functions on the *note critical path: 7c.
     Furthermore, in the default ANSI Library the default assertion
     handler will terminate the program.  See *note
     mps_lib_assert_fail_install(): 164.

     All events are sent to the *note telemetry stream: ba, including
     events on the *note critical path: 7c.

 -- C Macro: CONFIG_VAR_HOT

     The 'hot variety' is intended for production and deployment.

     Some functions check the consistency of their data structures and
     may assert, namely those not on the *note critical path: 7c.
     However, in the default ANSI Library, the default assertion handler
     will not terminate the program.  See *note
     mps_lib_assert_fail_install(): 164.

     Some events are sent to the *note telemetry stream: ba, namely
     those not on the *note critical path: 7c.

 -- C Macro: CONFIG_VAR_RASH

     The 'rash variety' is intended for mature integrations, or for
     developers who like living dangerously.

     No functions check the consistency of their data structures and
     consequently there are no assertions.

     No events are sent to the *note telemetry stream: ba.


File: MemoryPoolSystem.info,  Node: Arenas,  Next: Pools,  Prev: Error handing,  Up: Reference

2.4 Arenas
==========

An arena is an object that encapsulates the state of the Memory Pool
System, and tells it where to get the memory it manages.  You typically
start a session with the MPS by creating an arena with *note
mps_arena_create_k(): 52. and end the session by destroying it with
*note mps_arena_destroy(): 169.  The only functions you might need to
call before making an arena are *note telemetry system: 15b. functions
like *note mps_telemetry_set(): 176. and the *note plinth: 160. function
*note mps_lib_assert_fail_install(): 164.

Before destroying an arena, you must first destroy all objects and data
in it, as usual for abstract data types in the MPS. If you can’t destroy
the arena properly (for example, because your program has crashed and
you are at the debugger prompt), you can still call *note
mps_telemetry_flush(): 177. explicitly.

Other types of objects in the MPS are created “in the arena”.  They are
part of the world within the arena, and may interact and affect each
other.

     Note: The MPS allows creation of multiple arenas, but you would
     only do this in unusual circumstances, for example during the
     integration of two pieces of software that each independently uses
     the MPS.

     Arenas do not normally interact, but they compete with each other
     for resources, and references from one arena to another are not
     traced, though you 'can' declare *note roots: 97. pointing from one
     arena to another.  It is not efficient to have multiple arenas
     containing *note automatically managed: 9. *note pools: 18.: if you
     find yourself in this situation it’s best to find a way to move all
     the automatically managed pools to one arena.

The open source MPS comes with two classes of arena, *note Client
arenas: 178. and *note Virtual memory arenas: 179.  These differ in the
way that they acquire the memory to be managed.

     Note: The MPS is designed to be extensible with new arena classes.
     If you need features that are not provided by any of the open
     source arena classes, *note contact us: d8.

 -- C Type: type mps_arena_t

     The type of *note arenas: 16.

     An arena is responsible for requesting *note memory (3): 17. from
     the operating system, making it available to *note pools: 18, and
     for *note garbage collection: f.

 -- C Type: type mps_arena_class_t

     The type of *note arena classes: 11a.

 -- C Function: *note mps_res_t: 14d. mps_arena_create_k (mps_arena_t
          *arena_o, mps_arena_class_t arena_class, mps_arg_s args[])

     Create an *note arena: 16.

     ‘arena_o’ points to a location that will hold a pointer to the new
     arena.

     ‘arena_class’ is the *note arena class: 11a.

     ‘args’ are *note keyword arguments: 53. specific to the arena
     class.  See the documentation for the arena class.

     Returns *note MPS_RES_OK: 5a. if the arena is created successfully,
     or another *note result code: 59. otherwise.

     The arena persists until it is destroyed by calling *note
     mps_arena_destroy(): 169.

 -- C Function: void mps_arena_destroy (mps_arena_t arena)

     Destroy an *note arena: 16.

     ‘arena’ is the arena to destroy.

     This function checks the consistency of the arena, flushes the
     *note telemetry stream: ba. and destroys the arena’s internal
     control structures.  Additionally, *note virtual memory arenas: 4f.
     return their reserved address space to the operating system if
     possible.

     It is an error to destroy an arena without first destroying all
     *note generation chains: e2, *note object formats: 39, *note pools:
     18. and *note roots: 97. created in the arena, and deregistering
     all *note threads: 99. registered with the arena.

* Menu:

* Client arenas::
* Virtual memory arenas::
* Arena properties::
* Arena states::
* Running garbage collections::
* Using idle time for collection::
* Arena introspection and debugging::
* Arena extension callbacks::


File: MemoryPoolSystem.info,  Node: Client arenas,  Next: Virtual memory arenas,  Up: Arenas

2.4.1 Client arenas
-------------------

     #include "mpsacl.h"

 -- C Function: *note mps_arena_class_t: 17a. mps_arena_class_cl (void)

     Return the *note arena class: 11a. for a *note client arena: 4d.

     A client arena gets its managed memory from the *note client
     program: d0.  This memory chunk is passed when the arena is
     created.

     When creating a client arena, *note mps_arena_create_k(): 52.
     requires two *note keyword arguments: 53.:

        * ‘MPS_KEY_ARENA_CL_BASE’ (type *note mps_addr_t: 11d.) is the
          *note address: 126. of the chunk of memory that will be
          managed by the arena.

        * ‘MPS_KEY_ARENA_SIZE’ (type ‘size_t’) is its size.

     It also accepts five optional keyword arguments:

        * ‘MPS_KEY_COMMIT_LIMIT’ (type ‘size_t’) is the maximum amount
          of memory, in *note bytes (1): 17c, that the MPS will use out
          of the provided chunk (or chunks, if the arena is extended).
          See *note mps_arena_commit_limit(): 17d. for details.  The
          default commit limit is the maximum value of the ‘size_t’
          type.

        * ‘MPS_KEY_ARENA_GRAIN_SIZE’ (type ‘size_t’, default 8192) is
          the granularity with which the arena will manage memory
          internally.  It must be a power of 2, and at least
          ‘sizeof(void *)’.  Larger granularity reduces overheads, but
          increases *note fragmentation: 17e. and *note retention: 17f.

        * ‘MPS_KEY_PAUSE_TIME’ (type ‘double’, default 0.1) is the
          maximum time, in seconds, that operations within the arena may
          pause the *note client program: d0. for.  See *note
          mps_arena_pause_time_set(): 180. for details.

        * ‘MPS_KEY_ARENA_EXTENDED’ (type *note mps_fun_t: 12c.) is a
          function that will be called immediately after the arena is
          'extended': that is, just after it acquires a new chunk of
          address space from the operating system.  See *note Arena
          extension callbacks: 181. for details.

        * ‘MPS_KEY_ARENA_CONTRACTED’ (type *note mps_fun_t: 12c.) is a
          function that will be called immediately before the arena is
          'contracted': that is, just before it finishes with a chunk of
          address space and returns it to the operating system.  See
          *note Arena extension callbacks: 181. for details.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_ARENA_CL_BASE, base);
              MPS_ARGS_ADD(args, MPS_KEY_ARENA_SIZE, size);
              res = mps_arena_create_k(&arena, mps_arena_class_cl(), args);
          } MPS_ARGS_END(args);

     If the chunk is too small to hold the internal arena structures,
     *note mps_arena_create_k(): 52. returns *note MPS_RES_MEMORY: 152.
     In this case, you need to use a (much) larger chunk.

          Note: You don’t have to provide all the memory up front: you
          can call *note mps_arena_extend(): 182. later on.

          Client arenas have no mechanism for returning unused memory.

 -- C Function: *note mps_res_t: 14d. mps_arena_extend (mps_arena_t
          arena, mps_addr_t base, size_t size)

     Extend a *note client arena: 4d. with another block of memory.

     ‘base’ is the *note address: 126. of the block of memory that will
     be managed by the arena.

     ‘size’ is its *note size: 183.

     Return *note MPS_RES_OK: 5a. if successful, or another *note result
     code: 59. if it fails.


File: MemoryPoolSystem.info,  Node: Virtual memory arenas,  Next: Arena properties,  Prev: Client arenas,  Up: Arenas

2.4.2 Virtual memory arenas
---------------------------

     #include "mpsavm.h"

 -- C Function: *note mps_arena_class_t: 17a. mps_arena_class_vm (void)

     Return the *note arena class: 11a. for a *note virtual memory
     arena: 4f.

     A virtual memory arena uses the operating system’s *note virtual
     memory: 51. interface to allocate memory.  The chief consequence of
     this is that the arena can manage many more virtual addresses than
     it needs to commit memory to.  This gives it flexibility as to
     where to place *note blocks: 185, which reduces *note
     fragmentation: 17e. and helps make *note garbage collection: f.
     more efficient.

     When creating a virtual memory arena, *note mps_arena_create_k():
     52. accepts five optional *note keyword arguments: 53. on all
     platforms:

        * ‘MPS_KEY_ARENA_SIZE’ (type ‘size_t’, default 256 *note
          megabytes: 186.) is the initial amount of virtual address
          space, in *note bytes (1): 17c, that the arena will reserve
          (this space is initially reserved so that the arena can
          subsequently use it without interference from other parts of
          the program, but most of it is not committed, so it doesn’t
          require any RAM or backing store).  The arena may allocate
          more virtual address space beyond this initial reservation as
          and when it deems it necessary.  The MPS is most efficient if
          you reserve an address space that is several times larger than
          your peak memory usage.

          If you specify a value for ‘MPS_KEY_ARENA_SIZE’ that’s too
          small for the virtual memory arena, then the MPS rounds it up
          to the minimum and continues.  The minimum size for the
          virtual memory arena is *note MPS_WORD_WIDTH: 187. ×
          ‘MPS_KEY_ARENA_GRAIN_SIZE’ bytes.  For example, on a 64-bit
          platform with a 4 *note kilobyte: 188. page size, this is
          256 *note kilobytes: 188.

               Note: The MPS asks for more address space if it runs out,
               but the more times it has to extend its address space,
               the less efficient garbage collection will become.

        * ‘MPS_KEY_COMMIT_LIMIT’ (type ‘size_t’) is the maximum amount
          of main memory, in *note bytes (1): 17c, that the MPS will
          obtain from the operating system.  See *note
          mps_arena_commit_limit(): 17d. for details.  The default
          commit limit is the maximum value of the ‘size_t’ type.

        * ‘MPS_KEY_ARENA_GRAIN_SIZE’ (type ‘size_t’) is the granularity
          with which the arena will manage memory internally.  It must
          be a power of 2.  If not provided, the operating system’s page
          size is used.  Larger granularity reduces overheads, but
          increases *note fragmentation: 17e. and *note retention: 17f.

          If you specify a value of ‘MPS_KEY_ARENA_GRAIN_SIZE’ that’s
          smaller than the operating system page size, the MPS rounds it
          up to the page size and continues.

        * ‘MPS_KEY_SPARE’ (type ‘double’, default 0.75) is the maximum
          proportion of committed memory that the arena will keep spare
          for future allocations.  If the proportion of spare committed
          memory exceeds this, then the arena will return some of it to
          the operating system for use by other processes.  See *note
          mps_arena_spare(): 189. for details.

        * ‘MPS_KEY_PAUSE_TIME’ (type ‘double’, default 0.1) is the
          maximum time, in seconds, that operations within the arena may
          pause the *note client program: d0. for.  See *note
          mps_arena_pause_time_set(): 180. for details.

     A sixth optional *note keyword argument: 53. may be passed, but it
     only has any effect on the Windows operating system:

        * ‘MPS_KEY_VMW3_TOP_DOWN’ (type *note mps_bool_t: 129, default
          false).  If true, the arena will allocate address space
          starting at the highest possible address and working downwards
          through memory.

               Note: This causes the arena to pass the ‘MEM_TOP_DOWN’
               flag to VirtualAlloc(1).

     If the MPS fails to reserve adequate address space to place the
     arena in, *note mps_arena_create_k(): 52. returns *note
     MPS_RES_RESOURCE: 153.  Possibly this means that other parts of the
     program are reserving too much virtual memory.

     If the MPS fails to allocate memory for the internal arena
     structures, *note mps_arena_create_k(): 52. returns *note
     MPS_RES_MEMORY: 152.  Either ‘MPS_KEY_ARENA_SIZE’ was far too small
     or the operating system refused to provide enough memory.

     For example:

          MPS_ARGS_BEGIN(args) {
              MPS_ARGS_ADD(args, MPS_KEY_ARENA_SIZE, size);
              res = mps_arena_create_k(&arena, mps_arena_class_vm(), args);
          } MPS_ARGS_END(args);

   ---------- Footnotes ----------

   (1) 
http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887%28v=vs.85%29.aspx


File: MemoryPoolSystem.info,  Node: Arena properties,  Next: Arena states,  Prev: Virtual memory arenas,  Up: Arenas

2.4.3 Arena properties
----------------------

 -- C Function: *note mps_word_t: 6d. mps_collections (mps_arena_t
          arena)

     Return the number of garbage collections (technically, the number
     of *note flips: 18c.) in which objects might have moved, that have
     taken place in an *note arena: 16. since it was created.

     ‘arena’ is the arena.

          Note: If you are only using non-moving pool classes like *note
          AMS (Automatic Mark and Sweep): 16c, then *note
          mps_collections(): 18b. will always return 0.  To find out
          about these collections, consider enabling garbage collection
          messages: see *note mps_message_type_gc(): 18d.

 -- C Function: size_t mps_arena_commit_limit (mps_arena_t arena)

     Return the current *note commit limit: 156. for an arena.

     ‘arena’ is the arena to return the commit limit for.

     Returns the commit limit in *note bytes (1): 17c.

     For a *note client arena: 4d, this this the maximum amount of
     memory, in *note bytes (1): 17c, that the MPS will use out of the
     chunks provided by the client to the arena.

     For a *note virtual memory arena: 4f, this is the maximum amount of
     memory that the MPS will map to RAM via the operating system’s
     virtual memory interface.

     The commit limit can be set by passing the ‘MPS_KEY_COMMIT_LIMIT’
     *note keyword argument: 53. to *note mps_arena_create_k(): 52.  It
     can be changed by calling *note mps_arena_commit_limit_set(): 15a.
     The commit limit cannot be set to a value that is lower than the
     number of bytes that the MPS is using.  If an attempt is made to
     set the commit limit to a value greater than or equal to that
     returned by *note mps_arena_committed(): 18e. then it will succeed.
     If an attempt is made to set the commit limit to a value less than
     that returned by *note mps_arena_committed(): 18e. then it will
     succeed only if the amount committed by the MPS can be reduced by
     reducing the amount of spare committed memory; in such a case the
     spare committed memory will be reduced appropriately and the
     attempt will succeed.

          Note: The commit limit puts a limit on all memory committed by
          the MPS. The *note spare committed memory: 18f. (that is,
          memory committed by the MPS but not currently in use, neither
          by the *note client program: d0, or by the MPS itself) can be
          limited separately; see *note mps_arena_spare(): 189.  Note
          that “spare committed” memory is subject to both limits; the
          proportion of spare committed memory can’t exceed the spare
          commit limit, and there can’t be so much spare committed
          memory that there is more committed memory than the commit
          limit.

 -- C Function: *note mps_res_t: 14d. mps_arena_commit_limit_set
          (mps_arena_t arena, size_t limit)

     Change the *note commit limit: 156. for an *note arena: 16.

     ‘arena’ is the arena to change the commit limit for.

     ‘limit’ is the new commit limit in *note bytes (1): 17c.

     Returns *note MPS_RES_OK: 5a. if successful, or another *note
     result code: 59. if not.

     To effectively remove any commit limit, pass the maximum value of
     the ‘size_t’ type for the *note limit: 15a. argument, that is,
     ‘((size_t)-1)’, or ‘SIZE_MAX’ in C99 or later.

     See *note mps_arena_commit_limit(): 17d. for details.

 -- C Function: size_t mps_arena_committed (mps_arena_t arena)

     Return the total *note committed: 190. memory for an *note arena:
     16.

     ‘arena’ is the arena.

     Returns the total amount of memory that has been committed for use
     by the MPS, in *note bytes (1): 17c.

     For a *note virtual memory arena: 4f, this is the amount of memory
     mapped to RAM by the operating system’s virtual memory interface.

     For a *note client arena: 4d, this is the amount of memory marked
     as in use in the arena’s page tables.  This is not particularly
     meaningful by itself, but it corresponds to the amount of mapped
     memory that the MPS would use if switched to a virtual memory
     arena.

     The committed memory is generally larger than the sum of the sizes
     of the allocated *note blocks: 185.  The reasons for this are:

        * some memory is used internally by the MPS to manage its own
          data structures and to record information about allocated
          blocks (such as free lists, page tables, colour tables,
          statistics, and so on);

        * operating systems (and hardware) typically restrict programs
          to requesting and releasing memory with a certain granularity
          (for example, *note pages: 92.), so extra memory is committed
          when this rounding is necessary;

        * there might also be *note spare committed memory: 18f.: see
          *note mps_arena_spare_committed(): 191.

     The amount of committed memory is a good measure of how much
     virtual memory resource (“swap space”) the MPS is using from the
     operating system.

     The function *note mps_arena_committed(): 18e. may be called
     whatever state the arena is in.  If it is called when the arena is
     in the *note unclamped state: 192. then the value may change after
     this function returns.  A possible use might be to call it just
     after *note mps_arena_collect(): ce. to estimate the size of the
     heap.

     If you want to know how much memory the MPS is using then you’re
     probably interested in the value *note mps_arena_committed(): 18e.
     − *note mps_arena_spare_committed(): 191.

     The amount of committed memory can be limited with the function
     *note mps_arena_commit_limit(): 17d.

 -- C Function: double mps_arena_pause_time (mps_arena_t arena)

     Return the maximum time, in seconds, that operations within the
     arena may pause the *note client program: d0. for.

     ‘arena’ is the arena.

     See *note mps_arena_pause_time_set(): 180. for details.

 -- C Function: void mps_arena_pause_time_set (mps_arena_t arena, double
          pause_time)

     Set the maximum time, in seconds, that operations within an arena
     may pause the *note client program: d0. for.

     ‘arena’ is the arena.

     ‘pause_time’ is the new maximum pause time, in seconds.  It must be
     non-negative.

     The MPS makes more efficient use of processor time when it is
     allowed longer pauses, up to the maximum time it takes to collect
     the entire arena (see *note mps_arena_collect(): ce.).

     When the pause time is short, the MPS needs to take more slices of
     time in order to make *note garbage collection: f. progress, and
     make more use of *note barriers (1): 60. to support *note
     incremental garbage collection: d.  This increases time overheads,
     and especially operating system overheads.

     The pause time may be set to zero, in which case the MPS returns as
     soon as it can, without regard for overall efficiency.  This value
     is suitable for applications that require high responsiveness, but
     where overall run time is unimportant.

     For interactive applications, set this to the longest pause that a
     user won’t notice.  The default setting of 100ms is intended for
     this kind of application.

     The pause time may be set to infinity, in which case the MPS
     completes all outstanding *note garbage collection: f. work before
     returning from an operation.  The consequence is that the MPS will
     be able to save on the overheads due to *note incremental garbage
     collection: d, leading to lower total time spent in collection.
     This value is suitable for non-interactive applications where total
     time is important.

     The MPS makes a best effort to return to the *note client program:
     d0. from any operation on the arena within the maximum pause time,
     but does not guarantee to do so.  This is for three reasons:

       1. many operations in the MPS necessarily take some minimum
          amount time that’s logarithmic in the amount of *note memory
          (2): 194. being managed (so if you set the maximum pause time
          to zero, then every operation will exceed it);

       2. some operations in the MPS call functions in the *note client
          program: d0. (for example, the *note format methods: 69.), and
          the MPS has no control over how long these functions take;

       3. none of the operating systems supported by the MPS provide
          real-time guarantees (for example, the process may have to
          wait for *note memory (2): 194. to be *note paged in: 195.).

     In other words, the MPS is a “soft” real-time system.

 -- C Function: size_t mps_arena_reserved (mps_arena_t arena)

     Return the total *note address space: 54. reserved by an *note
     arena: 16, in *note bytes (1): 17c.

     ‘arena’ is the arena.

     For a *note virtual memory arena: 4f, this is the total address
     space reserved via the operating system’s virtual memory interface.

     For a *note client arena: 4d, this is the sum of the usable
     portions of the chunks of memory passed to the arena by the *note
     client program: d0. via *note mps_arena_create_k(): 52. and *note
     mps_arena_extend(): 182.

          Note: For a *note client arena: 4d, the reserved address space
          may be lower than the sum of the ‘MPS_KEY_ARENA_SIZE’ keyword
          argument passed to *note mps_arena_create_k(): 52. and the
          ‘size’ arguments passed to *note mps_arena_extend(): 182,
          because the arena may be unable to use the whole of each chunk
          for reasons of alignment.

 -- C Function: double mps_arena_spare (mps_arena_t arena)

     Return the current *note spare commit limit: 197. for an *note
     arena: 16.

     ‘arena’ is the arena to return the spare commit limit for.

     Returns the spare commit limit fraction.  The spare commit limit is
     the maximum fraction of *note spare committed memory: 18f. (that
     is, memory committed by the MPS but not currently in use, neither
     by the *note client program: d0, or by the MPS itself) the MPS is
     allowed to have.

     For example, setting the *note spare commit limit: 197. to 0.5 will
     allow the arena to retain up to 50% of *note committed: 190. memory
     as *note spare committed memory: 18f.

     The spare commit limit can be set by passing the ‘MPS_KEY_SPARE’
     *note keyword argument: 53. to *note mps_arena_create_k(): 52.  It
     can be changed by calling *note mps_arena_spare_set(): 198.
     Setting it to a value lower than the current fraction of spare
     committed memory causes spare committed memory to be uncommitted so
     as to bring the value under the limit.  In particular, setting it
     to 0.0 will mean that the MPS will have no spare committed memory.

 -- C Function: size_t mps_arena_spare_committed (mps_arena_t arena)

     Return the total *note spare committed memory: 18f. for an *note
     arena: 16.

     ‘arena’ is the arena.

     Returns the number of bytes of spare committed memory.

     Spare committed memory is memory which the arena is managing as
     free memory (not in use by any pool and not otherwise in use for
     internal reasons) but which remains committed (mapped to RAM by the
     operating system).  It is used by the arena to (attempt to) avoid
     calling the operating system to repeatedly map and unmap areas of
     *note virtual memory: 51. as the amount of memory in use goes up
     and down.  Spare committed memory is counted as committed memory by
     *note mps_arena_committed(): 18e. and is restricted by *note
     mps_arena_commit_limit(): 17d.

     The amount of “spare committed” memory can be limited passing the
     ‘MPS_KEY_SPARE’ *note keyword argument: 53. to *note
     mps_arena_create_k(): 52. or by calling *note
     mps_arena_spare_set(): 198.  The value of the limit can be
     retrieved with *note mps_arena_spare(): 189.  This is analogous to
     the functions for limiting the amount of *note committed: 190.
     memory.

          Note: *note Client arenas: 4d. do not use spare committed
          memory, and so this function always returns 0.

 -- C Function: void mps_arena_spare_set (mps_arena_t arena, double
          spare)

     Change the *note spare commit limit: 197. for an *note arena: 16.

     ‘arena’ is the arena to change the spare commit limit for.

     ‘spare’ is the new spare commit limit as a fraction of *note
     committed: 190. memory.  It must be between 0.0 and 1.0 inclusive.

     Non-virtual-memory arena classes (for example, a *note client
     arena: 4d.) do not have spare committed memory.  For these arenas,
     this function sets a value but has no other effect.

     Initially the spare commit limit is a configuration-dependent
     value.  The value of the limit can be retrieved by the function
     *note mps_arena_spare(): 189.


File: MemoryPoolSystem.info,  Node: Arena states,  Next: Running garbage collections,  Prev: Arena properties,  Up: Arenas

2.4.4 Arena states
------------------

An arena is always in one of four states.

  1. 
     In the 'unclamped state', garbage collection may take place,
     objects may move in memory, references may be updated, *note
     location dependencies: 19a. may become stale, virtual memory may be
     requested from or returned to the operating system, and other kinds
     of background activity may occur.  This is the normal state.

  2. 
     In the 'clamped state', objects do not move in memory, references
     do not change, the staleness of *note location dependencies: 19a.
     does not change, and memory occupied by *note unreachable: 21.
     objects is not recycled.

     However, a *note garbage collection: f. may be in progress and
     incremental collection may still occur, but it will not be visible
     to the *note client program: d0. and no new collections will begin.

  3. 
     The 'parked state' is the same as the clamped state, with the
     additional constraint that no garbage collections are in progress.

  4. 
     In the 'postmortem state', incremental collection does not take
     place, objects do not move in memory, references do not change, the
     staleness of *note location dependencies: 19a. does not change, and
     memory occupied by *note unreachable: 21. objects is not recycled.
     Additionally, all memory protection is removed, and memory may be
     in an inconsistent state.

          Warning: In this state, memory managed by the arena is not in
          a consistent state, and so it is not safe to continue running
          the client program.  This state is intended for postmortem
          debugging only.

Here’s a summary:

State                                            unclamped                              clamped                           parked                          postmortem
                                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                                                                                          
Collections may be running?                      yes                                    yes                               no                              yes
                                                                                                                                                          
                                                                                                                                                          
New collections may start?                       yes                                    no                                no                              no
                                                                                                                                                          
                                                                                                                                                          
Objects may move?                                yes                                    no                                no                              no
                                                                                                                                                          
                                                                                                                                                          
Location dependencies may become stale?          yes                                    no                                no                              no
                                                                                                                                                          
                                                                                                                                                          
Memory may be returned to the OS?                yes                                    no                                no                              no
                                                                                                                                                          
                                                                                                                                                          
Safe to continue running?                        yes                                    yes                               yes                             no
                                                                                                                                                          
                                                                                                                                                          
Functions that leave the arena in this state     *note mps_arena_create_k(): 52,        *note mps_arena_clamp(): 19d,     *note mps_arena_park(): b9,     *note mps_arena_postmortem(): d6.
                                                 *note mps_arena_release(): cf,         *note mps_arena_step(): 19c.      *note mps_arena_collect(): ce.  
                                                 *note mps_arena_start_collect(): 19b,                                    
                                                 *note mps_arena_step(): 19c.
                                                 

The clamped and parked states are important when introspecting and
debugging.  If you are examining the contents of the heap, you don’t
want data moving under your feet.  So for example, if your program is
stopped in GDB you might type:

     (gdb) print mps_arena_clamp(arena)

before inspecting memory, and:

     (gdb) print mps_arena_release(arena)

afterwards.

The results of introspection functions like *note mps_arena_has_addr():
d2. only remain valid while the arena remains in the parked state, and
functions like *note mps_arena_roots_walk(): 19e. can only be called in
this state.

 -- C Function: void mps_arena_clamp (mps_arena_t arena)

     Put an *note arena: 16. into the *note clamped state: 19f.

     ‘arena’ is the arena.

     In the clamped state, no object motion will occur and the staleness
     of *note location dependencies: 19a. will not change.  All
     references to objects loaded while the arena is clamped will keep
     the same binary representation until after it is released by
     calling *note mps_arena_release(): cf.

     In a clamped arena, incremental collection may still occur, but it
     will not be visible to the mutator and no new collections will
     begin.  Space used by unreachable objects will not be recycled
     until the arena is unclamped.

 -- C Function: void mps_arena_park (mps_arena_t arena)

     Put an *note arena: 16. into the *note parked state: b8.

     ‘arena’ is the arena.

     While an arena is parked, no object motion will occur and the
     staleness of *note location dependencies: 19a. will not change.
     All references to objects loaded while the arena is parked will
     keep the same binary representation until after it is released.

     Any current collection is run to completion before the arena is
     parked, and no new collections will start.  When an arena is in the
     parked state, it is necessarily not in the middle of a collection.

 -- C Function: void mps_arena_release (mps_arena_t arena)

     Put an arena into the *note unclamped state: 192.

     ‘arena’ is the arena.

     While an arena is unclamped, *note garbage collection: f, object
     motion, and other background activity can take place.

 -- C Function: void mps_arena_postmortem (mps_arena_t arena)

     Put an arena into the *note postmortem state: d5.

     ‘arena’ is the arena.

     In the postmortem state, incremental collection does not take
     place, objects do not move in memory, references do not change, the
     staleness of *note location dependencies: 19a. does not change, and
     memory occupied by *note unreachable: 21. objects is not recycled.
     Additionally, all memory protection is removed, and memory may be
     in an inconsistent state.

          Warning: 
            1. After calling this function, memory managed by the arena
               is not in a consistent state, and so it is no longer safe
               to continue running the client program.  This function is
               intended for postmortem debugging only.

            2. This function must be called from the thread that holds
               the arena lock (if any thread holds it).  This is the
               case if the program is single-threaded, or if it is
               called from an MPS assertion handler.  When calling this
               function from the debugger, check the stack to see which
               thread has the MPS arena lock.


File: MemoryPoolSystem.info,  Node: Running garbage collections,  Next: Using idle time for collection,  Prev: Arena states,  Up: Arenas

2.4.5 Running garbage collections
---------------------------------

The Memory Pool System’s garbage collector runs *note asynchronously:
a1. and *note incrementally: d.  This means that it is not normally
necessary to tell it when to start garbage collections, or to wait until
it has finished collecting.  (But if your program has idle time that
could be productively spent by the MPS, see *note Using idle time for
collection: 1a1. below.)

However, during development and testing it is useful to be able to
request that MPS run a full *note collection cycle: 1a2.  For example,
you might run frequent collections in an attempt to detect bugs in your
allocation and scanning code.

 -- C Function: void mps_arena_collect (mps_arena_t arena)

     Collect an arena and put it into the *note parked state: b8.

     ‘arena’ is the arena to collect.

     The collector attempts to recycle as many unreachable objects as
     possible and reduce the size of the arena as much as possible
     (though in some cases it may increase because it becomes more
     fragmented).  Note that the collector may not be able to recycle
     some objects (such as those near the destination of ambiguous
     references) even though they are not reachable.

     If you do not want the arena to remain in the parked state, you
     must explicitly call *note mps_arena_release(): cf. afterwards.

          Note: It is not normally necessary to call this function: in
          the *note unclamped state: 192, collections start
          automatically.  However, it may be useful during development
          and debugging: the more frequently the collector runs, the
          sooner and more reliably errors are discovered.  See *note
          General debugging advice: c7.

 -- C Function: *note mps_res_t: 14d. mps_arena_start_collect
          (mps_arena_t arena)

     Request an *note arena: 16. to start a full *note collection cycle:
     1a2.

     ‘arena’ is the arena.

     Returns *note MPS_RES_OK: 5a. if a collection is started, or
     another *note result code: 59. if not.

     This function puts ‘arena’ into the *note unclamped state: 192. and
     requests that it start a full collection cycle.  The call to *note
     mps_arena_start_collect(): 19b. returns quickly, leaving the
     collection to proceed incrementally (as for a collection that is
     scheduled automatically).

          Note: Contrast with *note mps_arena_collect(): ce, which does
          not return until the collection has completed.


File: MemoryPoolSystem.info,  Node: Using idle time for collection,  Next: Arena introspection and debugging,  Prev: Running garbage collections,  Up: Arenas

2.4.6 Using idle time for collection
------------------------------------

Some types of program have “idle time” in which they are waiting for an
external event such as user input or network activity.  The MPS provides
a function, *note mps_arena_step(): 19c, for making use of idle time to
make memory management progress.

Here’s an example illustrating the use of this function in a program’s
event loop.

     for (;;) { /* event loop */
         for (;;) {
             if (client_is_waiting()) {
                 perform_client_action();
             } else if (!mps_arena_step(arena, 0.010, 0.0)) {
                 /* no incremental MPS work remaining */
                 break;
             }
         }

         if (!block_on_client_with_timeout(2.0)) {
             /* Perhaps the user has gone for a cup of coffee? Allow the
              * MPS to start a big piece of work, but don't actually pause
              * for more than 10 ms. */
             mps_arena_step(arena, 0.010, 100.0);
         }
     }

When the program is idle (there are no client actions to perform), it
requests that the MPS spend up to 10 milliseconds on incremental work,
by calling ‘mps_arena_step(arena, 0.010, 0.0)’.  When this returns false
to indicate that there is no more work to do, the program blocks on the
client for two seconds: if this times out, it predicts that the user
will remain idle for at least a further second, so it calls
‘mps_arena_step(arena, 0.010, 100.0)’ to tell that it’s a good time to
start a collection taking up to 10 ms × 100 = 1 second, but not to pause
for more than 10 ms.

The program remains responsive: the MPS doesn’t take control for more
than a few milliseconds at a time (at most 10).  But at the same time,
major collection work can get done at times when the program would
otherwise be idle.  Of course the numbers here are only for
illustration; they should be chosen based on the requirements of the
application.

 -- C Function: *note mps_bool_t: 129. mps_arena_step (mps_arena_t
          arena, double interval, double multiplier)

     Request an *note arena: 16. to do some work during a period where
     the *note client program: d0. is idle.

     ‘arena’ is the arena.

     ‘interval’ is the time, in seconds, the MPS is permitted to take.
     It must not be negative, but may be ‘0.0’.

     ‘multiplier’ is the number of further similar calls that the client
     program expects to make during this idle period.

     Returns true if there was work for the MPS to do in ‘arena’
     (regardless of whether or not it did any) or false if there was
     nothing to do.

     *note mps_arena_step(): 19c. allows the client program to make use
     of idle time to do some garbage collection, for example when it is
     waiting for interactive input.  The MPS makes every effort to
     return from this function within ‘interval’ seconds, but cannot
     guarantee to do so, as it may need to call your own scanning code.
     It uses ‘multiplier’ to decide whether to commence long-duration
     operations that consume CPU (such as a full collection): it will
     only start such an operation if it is expected to be completed
     within ‘multiplier * interval’ seconds.

     If the arena was in the *note parked state: b8. or the *note
     clamped state: 19f. before *note mps_arena_step(): 19c. was called,
     it is in the clamped state afterwards.  It it was in the *note
     unclamped state: 192, it remains there.


File: MemoryPoolSystem.info,  Node: Arena introspection and debugging,  Next: Arena extension callbacks,  Prev: Using idle time for collection,  Up: Arenas

2.4.7 Arena introspection and debugging
---------------------------------------

     Note: Introspection functions covered in other chapters are:

        * *note mps_addr_fmt(): 1a5.: determine the *note object format:
          39. to which an address belongs;

        * *note mps_pool_walk(): 1a6.: visit all areas of *note
          formatted objects: 23. in a *note pool: 18.;

        * *note mps_arena_roots_walk(): 19e.: visit all references in
          *note roots: 97. registered with an arena; and

        * *note mps_addr_pool(): d3.: determine the *note pool: 18. to
          which an address belongs.

 -- C Function: *note mps_bool_t: 129. mps_arena_busy (mps_arena_t
          arena)

     Return true if an *note arena: 16. is part of the way through
     execution of an operation, false otherwise.

     ‘arena’ is the arena.

          Note: This function is intended to assist with debugging fatal
          errors in the *note client program: d0.  It is not expected to
          be needed in normal use.  If you find yourself wanting to use
          this function other than in the use case described below,
          there may be a better way to meet your requirements: please
          *note contact us: d8.

          A debugger running on Windows on x86-64 needs to decode the
          call stack, which it does by calling a callback that was
          previously installed in the dynamic function table using
          RtlInstallFunctionTableCallback()(1).  If the debugger is
          entered while the arena is busy, and if the callback needs to
          read from MPS-managed memory, then it may attempt to re-enter
          the MPS, which will fail as the MPS is not re-entrant.

          If this happens, in order to allow the debugger to finish
          decoding the call stack, the only remedy is to put the arena
          into the *note postmortem state: d5, so that memory is *note
          unprotected: 1a8. and objects do not move.  So in your dynamic
          function table callback, you might write:

               if (mps_arena_busy(arena)) {
                   mps_arena_postmortem(arena);
               }

          Warning: This function only gives a reliable result in
          single-threaded programs, and in multi-threaded programs where
          all threads but one are known to be stopped (as they are when
          the debugger is decoding the call stack in the use case
          described above).

 -- C Function: *note mps_bool_t: 129. mps_arena_has_addr (mps_arena_t
          arena, mps_addr_t addr)

     Test whether an *note address: 126. is managed by an *note arena:
     16.

     ‘arena’ is an arena.

     ‘addr’ is an address.

     Returns true if ‘addr’ is managed by ‘arena’; false otherwise.

     An arena manages a portion of *note address space: 54.  No two
     arenas overlap, so for any particular address this function will
     return true for at most one arena.

     In general, not all addresses are managed by any arena.  This is
     what allows the MPS to cooperate with other memory managers, shared
     object loaders, memory mapped file input/output, and so on: it does
     not steal the whole address space.

          Note: The result from this function is valid only at the
          instant at which the function returned.  In some circumstances
          the result may immediately become invalidated (for example, a
          *note garbage collection: f. may occur, the address in
          question may become free, the arena may choose to unmap the
          address and return storage to the operating system).  For
          reliable results call this function and interpret the result
          while the arena is in the *note parked state: b8.

     See also
     ........

     To find out which *note pool: 18. the address belongs to, use *note
     mps_addr_pool(): d3, and to find out which *note object format: 39.
     describes the object at the address, use *note mps_addr_fmt(): 1a5.

 -- C Function: *note mps_res_t: 14d. mps_addr_object (mps_addr_t *p_o,
          mps_arena_t arena, mps_addr_t addr)

     Find the *note base pointer: 1aa. of an *note object: 1ab. if
     provided with an *note interior pointer: 1ac. to that object, or
     the object’s base pointer, provided the object exists in a pool
     that supports this feature.

     ‘p_o’ points to a location that will hold the object’s base
     pointer.

     ‘arena’ is an arena.

     ‘addr’ is an address that might be an interior or base pointer.

     Returns MPS_RES_OK if a base pointer to an object into which ‘addr’
     points was successfully returned.

     Returns MPS_RES_FAIL if ‘addr’ points to memory not managed by the
     ‘arena’ or if ‘addr’ points to the interior of an object which has
     been moved by a *note moving memory manager: 1ad.

     Returns MPS_RES_UNIMPL if ‘addr’ is found to be managed by a *note
     pool: 18. which does not currently implement this feature.

     *note mps_addr_object(): 1a9. allows client programs that allocate
     code on the heap to implement debugging and stack tracing, in that
     it provides a way to unwind a client program’s stack by finding the
     block of code to which the program counter or function return
     addresses currently point.  It can be called multiple times as
     needed to build a complete trace of the client program’s stack.

     This function does not support debugging in situations where the
     arena itself has encountered a runtime error.  For cases where the
     MPS encounters runtime errors, see *note mps_arena_postmortem():
     d6.

          Note: This function is intended to assist with debugging fatal
          errors in the *note client program: d0.  It is not expected to
          be needed in normal use, i.e.  as part of the regular
          operation of code in production, since it is not optimized for
          performance.  If you find yourself wanting to use this
          function other than in the use case described, there may be a
          better way to meet your requirements: please *note contact us:
          d8.

          If you would like this function to work in a pool in which
          it’s currently unimplemented, please *note contact us: d8.

   ---------- Footnotes ----------

   (1) 
https://docs.microsoft.com/en-gb/windows/win32/api/winnt/nf-winnt-rtlinstallfunctiontablecallback


File: MemoryPoolSystem.info,  Node: Arena extension callbacks,  Prev: Arena introspection and debugging,  Up: Arenas

2.4.8 Arena extension callbacks
-------------------------------

There are situations in which the *note client program: d0. needs to be
informed about the chunks of address space that an *note arena: 16. is
managing.  To support this, the MPS allows the client program to specify
two callback functions when creating a *note virtual memory arena: 4f.:
one function is called when the arena is 'extended' (that is, when it
acquires a new chunk of address space from the operating system), and
the other when the arena is 'contracted' (that is, when it returns a
chunk of address space to the operating system).

The use case that this feature is designed to support is debugging of
dynamically generated code in 64-bit Windows.  Microsoft’s documentation
for RtlInstallFunctionTableCallback()(1) says:

     Function tables are used on 64-bit Windows to determine how to
     unwind or walk the stack.  These tables are usually generated by
     the compiler and stored as part of the image.  However,
     applications must provide the function table for dynamically
     generated code.

An application may install a dynamic function table by calling
RtlInstallFunctionTableCallback()(2), passing the region of memory in
which the dynamically generated functions can be found, and may later
delete the table by calling RtlDeleteFunctionTable()(3).

So if the client program is storing dynamically generated functions in
MPS-managed memory, then it could define callback functions that install
and delete the function table callback for the dynamically generated
code, like this:

     void arena_extended(mps_arena_t arena, void *base, size_t size)
     {
         RtlInstallFunctionTableCallback(...);
     }

     void arena_contracted(mps_arena_t arena, void *base, size_t size)
     {
         RtlDeleteFunctionTable(...);
     }

and then pass these two functions using *note keyword arguments: 53. to
*note mps_arena_create_k(): 52.:

     MPS_ARGS_BEGIN(args) {
         MPS_ARGS_ADD(args, MPS_KEY_ARENA_EXTENDED, (mps_fun_t)arena_extended);
         MPS_ARGS_ADD(args, MPS_KEY_ARENA_CONTRACTED, (mps_fun_t)arena_contracted);
         /* ... other keyword arguments ... */
         res = mps_arena_create_k(&arena, mps_arena_class_vm(), args);
     } MPS_ARGS_END(args);

The callback functions receive three arguments: ‘arena’ (the arena being
extended or contracted), ‘base’ (the base address of the chunk of
address space that has just been acquired from, or is about to be
returned to, the operating system), and ‘size’ (the size of the chunk,
in bytes).  They must not call any function in the MPS, and must not
access any memory managed by the MPS.

     Note: The extension callback is also called immediately after the
     arena is created, in other words, the creation of the arena is
     treated as a special example of an extension of the arena.

     The contraction callback is called on all remaining chunks when the
     arena is destroyed.  There will be at least one callback.

     Every contraction of the arena will match one-to-one with the arena
     extensions that have already taken place.  After creation, any
     contractions performed by the arena will be the same size as the
     extensions that have already taken place.  Contractions never occur
     as amalgamations nor as fractions of previous arena extensions.

     Arena extension callbacks are only supported by *note virtual
     memory arenas: 4f.

   ---------- Footnotes ----------

   (1) 
https://docs.microsoft.com/en-gb/windows/win32/api/winnt/nf-winnt-rtlinstallfunctiontablecallback

   (2) 
https://docs.microsoft.com/en-gb/windows/win32/api/winnt/nf-winnt-rtlinstallfunctiontablecallback

   (3) 
https://docs.microsoft.com/en-gb/windows/win32/api/winnt/nf-winnt-rtldeletefunctiontable


File: MemoryPoolSystem.info,  Node: Pools,  Next: Allocation<2>,  Prev: Arenas,  Up: Reference

2.5 Pools
=========

Within an *note arena: 16. a client program creates one or more pools.
A pool is responsible for requesting memory from the *note arena: 16.
and making it available for allocation.

 -- C Type: type mps_pool_t

     The type of *note pools: 18.

     A pool is responsible for requesting memory from the *note arena:
     16. and making it available to the *note client program: d0. via
     *note mps_alloc(): ad. or via an *note allocation point: 63.

 -- C Function: *note mps_res_t: 14d. mps_pool_create_k (mps_pool_t
          *pool_o, mps_arena_t arena, mps_pool_class_t pool_class,
          mps_arg_s args[])

     Create a *note pool: 18. in an *note arena: 16.

     ‘pool_o’ points to a location that will hold a pointer to the new
     pool.

     ‘arena’ is the arena in which to create the pool.

     ‘pool_class’ is the *note pool class: 10. of the new pool.

     ‘args’ are *note keyword arguments: 53. specific to the pool class.
     See the documentation for the pool class.

     Returns *note MPS_RES_OK: 5a. if the pool is created successfully,
     or another *note result code: 59. otherwise.

     The pool persists until it is destroyed by calling *note
     mps_pool_destroy(): 168.

 -- C Function: void mps_pool_destroy (mps_pool_t pool)

     Destroy a *note pool: 18.

     ‘pool’ is the pool to destroy.

     This function checks the consistency of the pool, destroys the
     pool’s internal control structures and causes the pool’s memory to
     be returned to the *note arena: 16. for reuse by other pools, or to
     be returned to the operating system.  Blocks allocated from the
     pool may no longer be used.

     It is an error to destroy a pool without first destroying all *note
     allocation points: 63. and *note segregated allocation caches: 1b2.
     created in the pool.

          Warning: It is not safe to carry on running the *note garbage
          collector: 20. after destroying an *note automatically
          managed: 9. pool that contains any objects that are *note
          reachable: 96. from your roots, or any objects that have been
          registered for *note finalization: b. but not yet finalized.

          Our recommended approach is to destroy automatically managed
          pools just before destroying the arena, and then only while
          the arena is in the *note parked state: b8.  Thus a safe
          tear-down sequence looks like this:

               mps_arena_park(arena);
               /* destroy threads and roots belonging to the arena */
               /* destroy allocation points and caches belonging to the pool */
               mps_pool_destroy(pool);
               /* destroy chains and formats belonging to the arena */
               mps_arena_destroy(arena);

* Menu:

* Pool classes::
* Pool introspection::


File: MemoryPoolSystem.info,  Node: Pool classes,  Next: Pool introspection,  Up: Pools

2.5.1 Pool classes
------------------

Pools belong to *note pool classes: 10. that specify policies for how
their memory is managed.  Some pools are *note manually managed: 8. (you
must call *note mps_free(): 1f. to return a block of memory to the pool)
and others are *note automatically managed: 9. (the *note garbage
collector: 20. reclaims *note unreachable: 21. blocks).

See the *note Pool reference: 22. for a list of pool classes.

 -- C Type: type mps_pool_class_t

     The type of *note pool classes: 10.


File: MemoryPoolSystem.info,  Node: Pool introspection,  Prev: Pool classes,  Up: Pools

2.5.2 Pool introspection
------------------------

 -- C Function: size_t mps_pool_total_size (mps_pool_t pool)

     Return the total memory allocated from the arena and managed by the
     pool.

     ‘pool’ is the pool.

     The result includes memory in use by the client program, memory
     that’s available for use by the client program, and memory that’s
     lost to fragmentation.  It does not include memory used by the
     pool’s internal control structures.

 -- C Function: size_t mps_pool_free_size (mps_pool_t pool)

     Return the free memory: memory managed by the pool but not in use
     by the client program.

     ‘pool’ is the pool.

     The result includes memory that’s available for use by the client
     program, and memory that’s lost to fragmentation.  It does not
     include memory used by the pool’s internal control structures.

 -- C Function: *note mps_bool_t: 129. mps_addr_pool (mps_pool_t
          *pool_o, mps_arena_t arena, mps_addr_t addr)

     Determine the *note pool: 18. to which an address belongs.

     ‘pool_o’ points to a location that will hold the address of the
     pool, if one is found.

     ‘arena’ is the arena whose pools will be considered.

     ‘addr’ is the address.

     If ‘addr’ is the address of a location inside a block allocated
     from a pool in ‘arena’, then update the location pointed to by
     ‘pool_o’ with the address of the pool, and return true.

     If ‘addr’ points to a location that is not managed by ‘arena’,
     return false.

     If neither of the above conditions is satisfied, *note
     mps_addr_pool(): d3. may return either true or false.

          Note: This function might return a false positive by returning
          true if you ask about an address that happens to be inside
          memory managed by a pool, but which is not inside a block
          allocated by that pool.  It never returns a false negative.

          The result from this function is valid only at the instant at
          which the function returned.  In some circumstances the result
          may immediately become invalidated.  For reliable results call
          this function and interpret the result while the arena is in
          the *note parked state: b8.

     See also
     ........

     To find out which *note object format: 39. describes the object at
     the address, use *note mps_addr_fmt(): 1a5.  If you only care
     whether the address belongs to a particular *note arena: 16, use
     *note mps_arena_has_addr(): d2.

 -- C Function: *note mps_res_t: 14d. mps_pool_walk (mps_pool_t pool,
          mps_area_scan_t scan_area, void *closure)

     Visit all *note formatted objects: 23. in a *note pool: 18.  The
     pool must be *note automatically managed: 9.  The pool’s *note
     arena: 16. must be in the *note parked state: b8.

     *note pool: 1a6. is the pool whose formatted objects are visited.

     *note scan_area: 1a6. is an area scanning function.  See *note Area
     scanners: 1b8.

     *note closure: 1a6. is an arbitrary pointer that will be passed to
     *note scan_area: 1a6.

     The scanning function is called multiple times with disjoint areas
     of memory that cover all formatted objects in the pool.  The areas
     may also include *note padding objects: 67. if the pool’s format
     has a *note padding method: 90, but never includes *note forwarding
     objects: 66. since the arena is in the parked state.

     The scanning function must follow the *note Scanning protocol: 16f.
     In particular, it must *note fix: b4. every *note reference: 24. in
     the area.  The scanning function may return *note MPS_RES_OK: 5a.
     to continue visiting areas of formatted objects, or return other
     *note Result codes: 159. to stop visiting and return to the caller.

          Note: If the scanning function modifies a reference, it must
          scan the modified reference.  It is safe to scan the original
          reference as well, but this may lead to unwanted *note
          retention: 17f.


File: MemoryPoolSystem.info,  Node: Allocation<2>,  Next: Object formats,  Prev: Pools,  Up: Reference

2.6 Allocation
==============

* Menu:

* Manual allocation::
* Allocation points::
* Allocation point protocol::
* Example; allocating a symbol: Example allocating a symbol.
* Cautions::
* Example; inserting into a doubly linked list: Example inserting into a doubly linked list.
* Allocation point implementation::


File: MemoryPoolSystem.info,  Node: Manual allocation,  Next: Allocation points,  Up: Allocation<2>

2.6.1 Manual allocation
-----------------------

     Note: Not all *note pool classes: 10. support this interface: *note
     automatically managed: 9. pools typically support none of it, and
     even *note manually managed: 8. pools may not support the whole
     interface.  Consult the pool class documentation for details.  For
     example, the *note MVT (Manual Variable Temporal): 1bc. pool class
     supports deallocation via *note mps_free(): 1f. but allocation must
     use allocation points, as described below.

 -- C Function: *note mps_res_t: 14d. mps_alloc (mps_addr_t *p_o,
          mps_pool_t pool, size_t size)

     Allocate a *note block: 185. of memory in a *note pool: 18.

     ‘p_o’ points to a location that will hold the address of the
     allocated block.

     ‘pool’ the pool to allocate in.

     ‘size’ is the *note size: 183. of the block to allocate.  If it is
     unaligned, it will be rounded up to the pool’s *note alignment: 68.
     (unless the pool documentation says otherwise).

          Note: It is tempting to call *note mps_alloc(): ad. with a
          cast from the desired pointer type to ‘mps_addr_t *’, like
          this:

               my_object *obj;
               res = mps_alloc((mps_addr_t *)&obj, pool, sizeof *obj);
               if (res != MPS_RES_OK)
                   error(...);

          but this is *note type punning: a5, and its behaviour is not
          defined in ANSI/ISO Standard C. See *note Type punning: 121.
          for more details.

 -- C Function: void mps_free (mps_pool_t pool, mps_addr_t addr, size_t
          size)

     Free a *note block: 185. of memory to a *note pool: 18.

     ‘pool’ is the pool the block belongs to.

     ‘addr’ is the address of the block to be freed.

     ‘size’ is the *note size: 183. of the block to be freed.  If it is
     unaligned, it will be rounded up to the pool’s *note alignment: 68.
     (unless the pool documentation says otherwise).

     The freed block of memory becomes available for allocation by the
     pool, or the pool might decide to make it available to other pools,
     or it may be returned to the operating system.

          Note: *note mps_free(): 1f. takes a ‘size’ parameter because
          it is most efficient to do so.  In most programs, the type of
          an object is known at the point in the code that frees it,
          hence the size is trivially available.  In such programs,
          storing the size on the MPS side would cost time and memory,
          and make it hard to get good virtual memory behaviour because
          of the need to touch the object in order to free it.  As it
          is, the deallocation code doesn’t have to touch the dead
          object at all.


File: MemoryPoolSystem.info,  Node: Allocation points,  Next: Allocation point protocol,  Prev: Manual allocation,  Up: Allocation<2>

2.6.2 Allocation points
-----------------------

*note Allocation points: 63. provide fast, *note inline: a, nearly *note
lock-free: 1bf. allocation.  They allow code to allocate without calling
an allocation function: this is vital for performance in languages or
programs that allocate many small objects.  They must be used according
to the *note Allocation point protocol: ae.

 -- C Type: type mps_ap_t

     The type of *note allocation points: 63.  It is a *note transparent
     alias: 127. for a pointer to *note mps_ap_s: 1c1.

 -- C Function: *note mps_res_t: 14d. mps_ap_create_k (mps_ap_t *ap_o,
          mps_pool_t pool, mps_arg_s args[])

     Create an *note allocation point: 63. in a *note pool: 18.

     ‘ap_o’ points to a location that will hold the address of the
     allocation point, if successful.

     ‘pool’ is the pool.

     ‘args’ are *note keyword arguments: 53. specific to the pool class
     to which ‘pool’ belong.  See the documentation for that pool class.
     (Most pool classes don’t take any keyword arguments; in those cases
     you can pass *note mps_args_none: 133.)

     Returns *note MPS_RES_OK: 5a. if successful, or another *note
     result code: 59. if not.

          Warning: An allocation point must not be used by more than one
          *note thread: 99.: each thread must create its own allocation
          point or points.

 -- C Function: void mps_ap_destroy (mps_ap_t ap)

     Destroy an *note allocation point: 63.

     ‘ap’ is the allocation point to destroy.

     Destroying an allocation point has no effect on blocks that were
     allocated from it, so long as they were successfully *note
     committed (2): b1. by *note mps_commit(): b2.


File: MemoryPoolSystem.info,  Node: Allocation point protocol,  Next: Example allocating a symbol,  Prev: Allocation points,  Up: Allocation<2>

2.6.3 Allocation point protocol
-------------------------------

This protocol is designed to work with *note incremental garbage
collection: d. and multiple *note threads: 99, where between any two
instructions in the *note client program: d0, the MPS may run part of a
*note garbage collection: f, *note move: 1ad. blocks in memory, rewrite
pointers, and reclaim space.  In order to reliably handle this, the
allocation point protocol consists of (at least) two steps, a 'reserve'
followed by a 'commit'.

     Note: The description of the protocol assumes that you have
     declared your threads’ *note control stacks: 27. and *note
     registers: 26. to be *note ambiguous roots: 1c4, by calling *note
     mps_root_create_thread(): a9.  This is the simplest way to write a
     client, but other scenarios are possible.  Please *note contact us:
     d8. if your use case is not covered here (for example, if you need
     an exact collector).

When the client program is initializing a newly allocated object, you
can think of it as being “in a race” with the MPS. Until the object is
initialized, the MPS cannot manage it in the usual way: in particular,
it cannot ensure that the new object remains correct if other objects
move during its initialization.  So if other objects 'do' move, the MPS
tells the client program that it has “lost the race”: the
partially-initialized object may be invalid, and the client must
initialize it again from scratch.

The allocation point protocol is as follows:

  1. Call *note mps_reserve(): b0. to reserve a block of memory on an
     allocation point.  The size of the block must be a multiple of the
     *note alignment: 68. of the pool in which the allocation point was
     created.

     If *note mps_reserve(): b0. returns *note MPS_RES_OK: 5a, go to
     step 2.

     Otherwise, the block cannot be reserved (this might happen if the
     MPS is out of memory).

  2. Initialize the block.  During this step the block must not be
     referenced by an *note exact reference: 61, and references stored
     in it must not be followed.

     The block need not be initialized completely, but if the pool has
     an *note object format: 39, then by the end of this step, the block
     must be capable of being passed to the format’s *note scan method:
     73. and *note skip method: 81.

  3. Call *note mps_commit(): b2. to attempt to commit the object to the
     care of the MPS.

     If *note mps_commit(): b2. returns true, this means that the object
     is valid, and is now under the management of the MPS. The client
     program may rely on references stored in the object, and may store
     references to the new object in its other objects.

     If *note mps_commit(): b2. returns false, this means that the block
     is invalid.  It is usual in this case to go back to step 1 and
     re-reserve and re-initialize it, but other courses of action are
     permitted.

          Note: In this case, the reason the block is invalid because a
          *note flip: 18c. took place after the call to *note
          mps_reserve(): b0. and before the call to *note mps_commit():
          b2.  This means that references in the block may point to the
          old location of blocks that moved.

The usual implementation of the allocation point protocol in *note C:
1c. is thus:

     mps_addr_t p;
     obj_t obj;
     size_t aligned_size = ALIGN(size); /* see note 1 */
     do {
         mps_res_t res = mps_reserve(&p, ap, aligned_size);
         if (res != MPS_RES_OK)
             /* handle the error */;
         /* p is now an ambiguous reference to the reserved block */
         obj = p;
         /* initialize obj */
     } while (!mps_commit(ap, p, aligned_size)); /* see note 2 */
     /* obj is now valid and managed by the MPS */

     Note: 
       1. Here ‘ALIGN()’ represents a function or macro that rounds
          ‘size’ up to the necessary alignment, which should be at least
          as big as the alignment of the pool.  (The reason that the MPS
          does not do this rounding up for you is to provide more
          opportunities for optimization: in many cases the required
          alignment will be a constant that’s known at compilation
          time.)

       2. *note mps_commit(): b2. returns false only if a garbage
          collection *note flip: 18c. occurs after *note mps_reserve():
          b0.  This is a very rare event, especially if the object
          initialization is short.

 -- C Function: *note mps_res_t: 14d. mps_reserve (mps_addr_t *p_o,
          mps_ap_t ap, size_t size)

     Reserve a *note block: 185. of memory on an *note allocation point:
     63.

     ‘p_o’ points to a location that will hold the address of the
     reserved block.

     ‘ap’ is the allocation point.

     ‘size’ is the *note size: 183. of the block to allocate.  It must
     be a multiple of the *note alignment: 68. of the pool (or of the
     pool’s *note object format: 39. if it has one).

     Returns *note MPS_RES_OK: 5a. if the block was reserved
     successfully, or another *note result code: 59. if not.

     The reserved block may be initialized but must not otherwise be
     used

     Until it has been *note committed (2): b1. via a successful call to
     *note mps_commit(): b2, the reserved block may be:

        * initialized;

        * referenced by an *note ambiguous reference: 9f.;

     but:

        * it must not be referenced by an *note exact reference: 61.;

        * references stored in it must not be followed;

        * it is not scanned, moved, or protected (even if it belongs to
          a pool with these features).

          Note: *note mps_reserve(): b0. must only be called according
          to the *note Allocation point protocol: ae.

          *note mps_reserve(): b0. is implemented as a macro for speed.
          It may evaluate its arguments multiple times.

          There is an alternative, *note MPS_RESERVE_BLOCK: 124, which
          may generate faster code on some compilers.

 -- C Macro: MPS_RESERVE_BLOCK (res_v, p_v, ap, size)

     An alternative to *note mps_reserve(): b0.  On compilers that do
     not perform common-subexpression elimination, it may generate
     faster code than *note mps_reserve(): b0. (but may not).  It may
     only be used in statement context (not as an expression).

     The second argument is an lvalue ‘p_v’, which is assigned the
     address of the reserved block.  It takes an additional first
     argument, the lvalue ‘res_v’, which is assigned the *note result
     code: 59.

 -- C Function: *note mps_bool_t: 129. mps_commit (mps_ap_t ap,
          mps_addr_t p, size_t size)

     *note Commit: b1. a reserved *note block: 185. on an *note
     allocation point: 63.

     ‘ap’ is an allocation point.

     ‘p’ points to a block that was reserved by *note mps_reserve(): b0.
     but has not yet been committed.

     ‘size’ is the *note size: 183. of the block to allocate.  It must
     be the same size that was passed to *note mps_reserve(): b0.

     If *note mps_commit(): b2. returns true, the block was successfully
     committed, which means that the *note client program: d0. may use
     it, create references to it, and rely on references from it.  It
     also means that the MPS may scan it, move it, protect it, or
     reclaim it (if ‘ap’ was attached to a pool with those features).

     If *note mps_commit(): b2. returns false, the block was not
     committed.  This means that the client program must not create
     references to the block, rely on references from it, or otherwise
     use it.  It is normal to attempt the reserve operation again when
     this happens.

     It is very rare for *note mps_commit(): b2. to return false: this
     only happens if there was a *note flip: 18c. between the call to
     *note mps_reserve(): b0. and the call to *note mps_commit(): b2.
     Nonetheless, it can happen, so it is important not to perform
     operations with side effects (that you aren’t prepared to repeat)
     between calling *note mps_reserve(): b0. and *note mps_commit():
     b2.  Also, the shorter the interval, the less likely *note
     mps_commit(): b2. is to return false.

          Note: *note mps_commit(): b2. must only be called according to
          the *note Allocation point protocol: ae.

          *note mps_commit(): b2. is implemented as a macro for speed.
          It may evaluate its arguments multiple times.

