This is MemoryPoolSystem.info, produced by makeinfo version 7.1.1 from
MemoryPoolSystem.texi.

     Memory Pool System 1.118.0, Feb 11, 2025

     Ravenbrook Limited

     Copyright © 2025, Ravenbrook Limited

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* MemoryPoolSystem: (MemoryPoolSystem.info). One line description of project.
END-INFO-DIR-ENTRY


   Generated by Sphinx 8.1.3.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary K,  Next: Memory Management Glossary L,  Prev: Memory Management Glossary I,  Up: Memory Management Glossary

7.10 Memory Management Glossary: K
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

kB

     *note kilobyte: 188.

keyword argument

     An argument to a function call that’s identified by an associated
     keyword rather than by its position in the argument list.

     Keyword arguments are passed to functions in the MPS interface as
     arrays of structures of type *note mps_arg_s: 56.  See *note
     Keyword arguments: 57.

kilobyte

     'kB'.

     A kilobyte is 1024 *note bytes (1): 17c.

     See *note byte (1): 17c. for general information on this and
     related quantities.

     The standard abbreviation is “kB”, but “KB” is often used by people
     unfamiliar with the metric system.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary L,  Next: Memory Management Glossary M,  Prev: Memory Management Glossary K,  Up: Memory Management Glossary

7.11 Memory Management Glossary: L
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

large object area

     An *note allocation mechanism: 15d4. designed to optimize the
     management of large *note objects: 1ab. by separating them from
     small ones.

     Large objects, typically objects one or more orders of magnitude
     larger than the *note virtual memory: 51. *note page: 92. of a
     platform, can be costly to *note allocate: 15ca, initialize, and
     *note recycle: 15de.  By segregating those objects into a separate
     area, they can be managed using specific mechanisms that would be
     inefficient for smaller objects but which can reduce the cost of
     manipulating large ones.

     Some example mechanisms:

       1. In a *note copying collector: e3. large objects can be managed
          separately using a *note mark-and-sweep collector: 15fd. to
          avoid copying costs.  See *note Ungar (1988): 1574.

       2. By aligning large objects on page boundaries, they can be
          *note compacted: 1643. or copied by adjusting their *note
          mapping: 310. in *note virtual memory: 51.  See *note
          Withington (1991): 1582.

       3. Large objects may be split into a header and a body, where the
          header is fixed size and the bulk of the object is in the
          body.  See *note Ungar (1988): 1574.

       4. By using a page-based *note read barrier: 1d6, large objects
          can be initialized incrementally.  For example, each page of
          the large object is initialized to zero when it is first read,
          rather than all at once at creation time.

       5. In a copying collector, large objects can be copied
          incrementally using a similar technique (the new copy is
          initialized from the old copy).  See *note Baker (1978): 14e1.

       6. Large objects are often *note leaf objects: 107, so do not
          need to be *note scanned: 65, or are known to have a fixed
          *note format: 164e. with only a few *note references: 24. so
          they can be scanned more efficiently by a specialized scanner.

       7. Large objects often have longer than average *note lifetimes:
          b5, so are not allocated in a *note nursery space: 35f. of a
          *note generational garbage collector: e.

large page

     *note huge page: 16a1.

leaf object

     'atomic object'.

     A leaf object is an *note object: 1ab. that does not *note
     reference: 24. any other objects.

     In a typed language, the compiler can often determine at compile
     time that certain types can be represented as leaf objects.
     Usually these types are either a *note scalar data type: 15c6. or a
     *note vector data type: 15c7. of scalars with bounded magnitude.

     If leaf objects can be identified, a *note garbage collector: 20.
     can make certain optimizations: leaf objects do not have to be
     *note scanned: 65. for references nor are *note barriers (1): 60.
     needed to detect and maintain references in the object.

     The *note AMCZ (Automatic Mostly-Copying Zero-rank): 89. and *note
     LO (Leaf Object): 353. pool classes are designed for the storage of
     leaf objects.

leak

     *note memory leak: 234.

life

     *note lifetime: b5.

lifetime

     'extent', 'life'.

     The lifetime or extent of an *note object: 1ab. is the time for
     which the object is *note live: 78.

     See also
     ........

     *note dynamic extent: 24a, *note indefinite extent: 15af.

LIFO-ordered first fit

     The *note allocation policy: 380. that always uses the
     most-recently *note freed (1): 15d2. suitable *note free block:
     15bf.  Commonly implemented by pushing freed blocks on the front of
     a *note free block chain: 15c0, and then using *note first fit:
     37f. allocation on this chain.  *note free (1): 15d2. can be very
     quick, depending on the *note coalescing: 38c. policy.

     This policy may suffer from severe *note fragmentation: 17e. in the
     presence of short-lived large objects of a single size.  As smaller
     objects are allocated, the free block chain fills up with fragments
     a little smaller than the large object size.

     See also
     ........

     *note address-ordered first fit: 384, *note FIFO-ordered first fit:
     385.

     *note Wilson et al.  (1995): 157a.

limited-field reference count

     'sticky reference count'.

     A *note reference counting: 15e0. technique whereby the field used
     to store the number of *note references: 24. to an *note object:
     1ab. has a limited size.  In particular, the field is not large
     enough to represent the maximum possible number of references to an
     object.

     Using the observation that most objects are not referenced a great
     number of times, some systems that use reference counts only store
     the count accurately up to a certain maximum value.  If an object
     has more references than the maximum then the count “sticks” at the
     maximum and is never decremented.  Such objects are expected to be
     rare, but their *note memory (1): 15b0. can never be *note
     reclaimed: 4a. using reference counting.  A separate (infrequently
     run) *note tracing garbage collector: 15df. is often employed to
     reclaim this storage.

     A degenerate form of limited-field reference counting is *note
     one-bit reference counting: 16c6. where an object is considered to
     be referenced either exactly once or many times.

linear addressing

     In linear addressing, *note addresses: 126. form a single,
     continuous *note address space: 54.  This term is used mostly in
     opposition to *note segmented addressing: 15b9.

     *note segmented addressing: 15b9.

live

     'active', 'alive'.

     *note Memory (2): 194. or an *note object: 1ab. is live if the
     program will read from it in future.  The term is often used more
     broadly to mean *note reachable: 96.

     It is not possible, in general, for *note garbage collectors: 20.
     to determine exactly which *note objects: 1ab. are still live.
     Instead, they use some approximation to detect objects that are
     provably *note dead: 49, such as those that are not *note
     reachable: 96.

     *note reachable: 96.

     *note dead: 49.

     See also
     ........

     *note undead: 165d.

load

     To transfer data from *note memory (2): 194. to a processor’s *note
     registers: 26.

     Load can also be used in the more general sense of moving data from
     a part of the *note memory hierarchy: 16c8. that is slow to access
     to one that is fast to access (For example, “it takes about 3 ms
     for the *note virtual memory: 51. system to load a *note page: 92.
     from disk on this system”).  When used in this sense, the qualified
     term *note cache (2): 1627. load is common.

     ‘LOAD’ (or an abbreviation) is also commonly used in many processor
     architectures as the mnemonic name for the machine code
     instructions that are used primarily to make data accessible to the
     CPU (by loading the data into registers usually).  In RISC
     architectures it is common for the load instructions to be the only
     means of making data accessible to the CPU; in CISC architectures
     it is common for a wide variety of instructions to implicitly or
     explicitly load data from memory.

     *note store (1): 15eb.

locality of reference

     Locality of reference is the extent to which successive accesses of
     nearby *note memory (1): 15b0. *note locations: 15b4. are nearby in
     time; for example, a program that reads all the elements of a
     contiguous array in turn or that repeatedly uses the same memory
     variable has good locality of reference.

     Good locality of reference interacts well with *note virtual
     memory: 51. and *note memory caches: 1622, as it reduces the *note
     working set: 16ba. and improves the *note hit rate: 169f.

     There are a number of specialized senses of locality of reference
     in certain fields such as distributed systems; these are not
     covered in depth here.

     A *note mutator: 30c. may exhibit predictable properties such as
     accessing in turn *note objects: 1ab. which were *note allocated:
     15ca. in turn, or accessing in turn objects which have *note
     references: 24. to each other.  An intelligent *note allocator:
     15ce. or *note copying garbage collector: e3. can use this
     observation to improve locality of reference.

     *note Grunwald et al.  (1993): 1525, *note Wilson et al.  (1992):
     1577.

location

     *note memory location: 15b4.

location dependency

     A 'location dependency' records the fact that the *note client
     program: d0. depends on the bit patterns of some *note references:
     24. (and not merely on the identity of the *note block: 185. to
     which the reference refers), and provides a function (*note
     mps_ld_isstale(): f7.) to find out whether a reference might have
     been changed because a block has been *note moved: 5d.  See *note
     Location dependency: f8.

lock free

     A multi-threaded program is 'lock free' if all schedules for the
     threads make progress: in particular, no schedule leads to
     deadlock.  This is most easily implemented by avoiding taking
     locks.

logical address

     *note virtual address: 16b9.

longword

     *note doubleword: 1667.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary M,  Next: Memory Management Glossary N,  Prev: Memory Management Glossary L,  Up: Memory Management Glossary

7.12 Memory Management Glossary: M
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

machine word

     *note word: 37c.

main memory

     'memory', 'primary storage'.

     The 'main memory' (or 'primary storage') of a computer is *note
     memory (1): 15b0. that is wired directly to the processor,
     consisting of *note RAM: 55. and possibly *note ROM: 16ce.

     These terms are used in contrast to mass storage devices and *note
     cache memory: 1629. (although we may note that when a program
     accesses main memory, it is often actually interacting with a
     cache).

     Main memory is the middle level of the *note memory hierarchy:
     16c8.: it is slower and cheaper than *note caches (1): 1622, but
     faster and more expensive than *note backing store: 15d1.

     It is common to refer only to the main memory of a computer; for
     example, “This server has 128 GB of memory” and “macOS High Sierra
     requires at least 2 GB of memory”.

     Main memory used to be called *note core: 1656, and is now likewise
     often called *note RAM: 55.

     *note core: 1656, *note physical memory (1): 16b8, *note RAM: 55.

malloc

     A function in the standard *note C: 1c. library that performs *note
     dynamic allocation: 166b. of *note memory (2): 194.

     Many people use “malloc” as a verb to mean “allocate dynamically”.

     *note allocate: 15ca.

     *note free (2): 1b.

manual memory management

     In some systems or languages, it is up to the application program
     to manage all the bookkeeping details of *note allocating: 15ca.
     *note memory (2): 194. from the *note heap: 47. and *note freeing:
     15d2. it when no longer required; this is known as manual *note
     memory management: 15dd.

     Manual memory management may be appropriate for small programs, but
     it does not scale well in general, nor does it encourage modular or
     object-oriented programming.

     To quote *note Joyner (1996): 1539.:

          In C++ the programmer must manually manage storage due to the
          lack of *note garbage collection: f.  This is the most
          difficult bookkeeping task C++ programmers face, that leads to
          two opposite problems: firstly, an object can be *note
          deallocated: 15d2. prematurely, while valid *note references:
          24. still exist (*note dangling pointers: 281.); secondly,
          *note dead: 49. objects might not be deallocated, leading to
          memory filling up with dead objects (*note memory leaks:
          234.).  Attempts to correct either problem can lead to
          overcompensation and the opposite problem occurring.  A
          correct system is a fine balance.

     Manual memory management was common in early languages, but *note
     garbage collection: f. has been around since the late 1950s, in
     languages like *note Lisp: 28a.  Most modern languages use *note
     automatic memory management: 9, and some older languages have *note
     conservative garbage collection: 349. extensions.

     *note automatic memory management: 9.

     Manual memory management can be used with *note pools: 18. such as
     *note MVFF (Manual Variable First Fit): 10c. via the functions
     *note mps_alloc(): ad. and *note mps_free(): 1f.

mapped

     'committed'.

     A range of *note virtual addresses: 16b9. is said to be 'mapped'
     ('committed' on Windows) if there is *note physical memory (2):
     15b6. associated with the range.

     Note that, in some circumstances, the *note virtual memory: 51.
     system could actually *note overcommit: 16cf. mapped memory.

     *note unmapped: 1685.

     See also
     ........

     *note mapping: 310, *note memory mapping: 15b7, *note mmap: 16d0.

     The term 'committed' is used.  The function *note
     mps_arena_committed(): 18e. returns the total committed memory for
     an *note arena: 16.

mapping

     A 'mapping' is a correspondence between a range of *note virtual
     addresses: 16b9. and some *note memory (1): 15b0. (or a *note
     memory-mapped: 15b7. object).  The physical location of the memory
     will be managed by the *note virtual memory: 51. system.

     Each *note page: 92. in a mapping could be *note paged out: 16d1.
     or *note paged in: 195, and the locations it occupies in *note main
     memory: 311. and/or *note swap space: 15e9. might change over time.

     The *note virtual address space: 15bb. can contain of a complex set
     of mappings.  Typically, parts of the address space are *note
     mapped: 190. (have a mapping assigned), others are *note reserved:
     16d2. but unmapped, and most of it is entirely *note unmapped:
     1685.

 [image src="MemoryPoolSystem-figures/mapped.svg" alt="Diagram: Virtual memory with different kinds of mappings." ]


     Figure: Virtual memory with different kinds of mappings.

     See also
     ........

     *note backing store: 15d1.

mark-compact

     Mark-compact collection is a kind of *note tracing garbage
     collection: 15df. that operates by *note marking: 1600. *note
     reachable: 96. *note objects: 1ab, then *note compacting: 1643. the
     marked objects (which must include all the *note live: 78.
     objects).

     The mark phase follows *note reference: 24. chains to mark all
     reachable objects; the compaction phase typically performs a number
     of sequential passes over *note memory (2): 194. to move objects
     and update references.  As a result of compaction, all the marked
     objects are moved into a single contiguous *note block: 185. of
     memory (or a small number of such blocks); the memory left unused
     after compaction is *note recycled: 15de.

     Mark-compact collection can be regarded as a variation of *note
     mark-sweep collection: 15fd, with extra effort spent to eliminate
     the resulting *note fragmentation: 17e.  Compaction also allows the
     use of more efficient *note allocation mechanisms: 15d4, by making
     large free blocks available.

     *note Edwards: 151e.

mark-sweep

mark-and-sweep

     Mark-sweep collection is a kind of *note tracing garbage
     collection: 15df. that operates by *note marking: 1600. *note
     reachable: 96. *note objects: 1ab, then *note sweeping: 16d4. over
     *note memory (2): 194. and *note recycling: 15de. objects that are
     unmarked (which must be *note unreachable: 21.), putting them on a
     *note free list: 268.

     The mark phase follows *note reference: 24. chains to mark all
     reachable objects; the sweep phase performs a sequential (*note
     address: 126.-order) pass over memory to recycle all unmarked
     objects.  A mark-sweep *note collector (1): 15d7. doesn’t move
     objects.

     This was the first garbage collection algorithm, devised by John
     McCarthy for *note Lisp: 28a.

     See also
     ........

     *note mark-compact: 160d.

     *note McCarthy (1960): 1541.

marking

     Marking is the first phase (“the mark phase”) of the *note
     mark-sweep: 15fd. algorithm or *note mark-compact: 160d. algorithm.
     It follows all *note references: 24. from a set of *note roots: 97.
     to mark all the *note reachable: 96. *note objects: 1ab.

     Marking follows *note reference: 24. chains and makes some sort of
     mark for each object it reaches.

     Marking is often achieved by setting a bit in the object, though
     any conservative representation of a predicate on the *note memory
     location: 15b4. of the object can be used.  In particular, storing
     the mark bit within the object can lead to poor *note locality of
     reference: 1601. and to poor cache performance, because the marking
     phases ends up setting the *note dirty bit: 1602. on all *note
     pages: 92. in the *note working set: 16ba.  An alternative is to
     store the mark bits separately: see *note bitmap marking: 15fe.

     See also
     ........

     *note compact: 1643, *note sweep: 16d4.

MB

     *note megabyte: 186.

megabyte

     'MB'.

     A megabyte is 1024 *note kilobytes: 188, or 1048576 *note byte (1):
     17c.

     See *note byte (1): 17c. for general information on this and
     related quantities.

memoization

     *note caching (3): 162a.

memory^(1)

     'storage', 'store'.

     'memory' or 'storage' (or 'store') is where data and instructions
     are stored.  For example, *note caches (1): 1622, *note main
     memory: 311, floppy and hard disks are all storage devices.

     These terms are also used for the capacity of a system to store
     data, and may be applied to the sum total of all the storage
     devices attached to a computer.

     “Store” is old-fashioned, but survives in expressions such as
     “*note backing store: 15d1.”.

memory^(2)

     'Memory' refers to *note memory (1): 15b0. that can be accessed by
     the processor directly (using memory addressing instructions).

     This could be *note real memory (1): 16d7. or *note virtual memory:
     51.

memory^(3)

     *note main memory: 311.

memory^(4)

     A *note memory location: 15b4.; for example, “My digital watch has
     256 memories.”

memory bandwidth

     Memory bandwidth (by analogy with the term 'bandwidth' from
     communication theory) is a measure of how quickly information
     (expressed in terms of bits) can be transferred between two places
     in a computer system.

     Often the term is applied to a measure of how quickly the processor
     can obtain information from the *note main memory: 311. (for
     example, “My new bus design has a bandwidth of over 400 Megabytes
     per second”).

memory cache

     *note cache (1): 1622.

memory hierarchy

     *note storage hierarchy: 1628.

memory leak

     'leak', 'space leak', 'space-leak'.

     A memory leak is where *note allocated: 15ca. *note memory (2):
     194. is not *note freed (1): 15d2. although it is never used again.

     In *note manual memory management: 8, this usually occurs because
     *note objects: 1ab. become *note unreachable: 21. without being
     *note freed (1): 15d2.

     In *note tracing garbage collection: 15df, this happens when
     objects are *note reachable: 96. but not *note live: 78.

     In *note reference counting: 15e0, this happens when objects are
     *note referenced: 24. but not *note live: 78.  (Such objects may or
     may not be *note reachable: 96.)

     Repeated memory leaks cause the memory usage of a process to grow
     without bound.

memory location

     'location'.

     Each separately-*note addressable: 126. unit of *note memory (2):
     194. in which data can be stored is called a 'memory location'.
     Usually, these hold a *note byte (2): 15c8, but the term can refer
     to *note words: 37c.

memory management

     'storage management'.

     Memory management is the art and the process of coordinating and
     controlling the use of *note memory (1): 15b0. in a computer
     system.

     Memory management can be divided into three areas:

       1. Memory management hardware (*note MMUs: 16db, *note RAM: 55,
          etc.);

       2. Operating system memory management (*note virtual memory: 51,
          *note protection: 1fd.);

       3. Application memory management (*note allocation: 15ca, *note
          deallocation: 15d2, *note garbage collection: f.).

     Memory management hardware consists of the electronic devices and
     associated circuitry that store the state of a computer.  These
     devices include RAM, MMUs (memory management units), *note cache
     (1): 1622, disks, and processor *note registers: 26.  The design of
     memory hardware is critical to the performance of modern computer
     systems.  In fact, *note memory bandwidth: 16d9. is perhaps the
     main limiting factor on system performance.

     Operating system memory management is concerned with using the
     memory management hardware to manage the resources of the *note
     storage hierarchy: 1628. and allocating them to the various
     activities running on a computer.  The most significant part of
     this on many systems is *note virtual memory: 51, which creates the
     illusion that every process has more memory than is actually
     available.  OS memory management is also concerned with *note
     memory protection: 15ec. and security, which help to maintain the
     integrity of the operating system against accidental damage or
     deliberate attack.  It also protects user programs from errors in
     other programs.

     Application memory management involves obtaining *note memory (2):
     194. from the operating system, and managing its use by an
     application program.  Application programs have dynamically
     changing storage requirements.  The application *note memory
     manager: 15cd. must cope with this while minimizing the total CPU
     overhead, interactive pause times, and the total memory used.

     While the operating system may create the illusion of nearly
     infinite memory, it is a complex task to manage application memory
     so that the application can run most efficiently.  Ideally, these
     problems should be solved by tried and tested tools, tuned to a
     specific application.

     The Memory Management Reference is mostly concerned with
     application memory management.

     See also
     ........

     *note automatic memory management: 9, *note manual memory
     management: 8.

Memory Management Unit

     *note MMU: 16db.

memory manager

     The memory manager is that part of the system that manages *note
     memory (2): 194, servicing *note allocation: 15ca. requests, and
     *note recycling: 15de. memory, either *note manually: 8. or *note
     automatically: 9.

     The memory manager can have a significant effect on the efficiency
     of the program; it is not unusual for a program to spend 20% of its
     time managing memory.

     *note allocator: 15ce, *note collector (1): 15d7.

     See also
     ........

     *note memory management: 15dd.

memory mapping

     'file mapping'.

     'Memory mapping' is the technique of making a part of the *note
     address space: 54. appear to contain an “object”, such as a file or
     device, so that ordinary *note memory (2): 194. accesses act on
     that object.

     The object is said to be 'mapped' to that range of addresses.  (The
     term “object” does not mean a program *note object: 1ab.  It comes
     from Unix terminology on the *note mmap: 16d0. man page.)

 [image src="MemoryPoolSystem-figures/mapping.svg" alt="Diagram: An address space with a range mapped to part of an object." ]


     Figure: An address space with a range mapped to part of an object.

     Memory mapping uses the same mechanism as *note virtual memory: 51.
     to “trap” accesses to parts of the *note address space: 54, so that
     data from the file or device can be *note paged in: 195. (and other
     parts *note paged out: 16d1.) before the access is completed.

     File mapping is available on most modern Unix and Windows systems.
     However, it has a much longer history.  In Multics, it was the
     primary way of accessing files.

     See also
     ........

     *note mapped: 190.

memory protection

     *note protection: 1fd.

message

     A data structure which the MPS uses to communicate with the *note
     client program: d0.  See *note Messages: f1.

message queue

     A queue of *note messages: e9. posted by an *note arena: 16.  It
     can be queried by calling *note mps_message_poll(): 240, *note
     mps_message_queue_type(): 241, or *note mps_message_get(): ec.  See
     *note Messages: f1.

message type

     A value of type *note mps_message_type_t: 22b. describing the type
     of a *note message: e9.  There are three message types: *note
     mps_message_type_finalization(): 236, *note mps_message_type_gc():
     18d, and *note mps_message_type_gc_start(): 22a.  See *note
     Messages: f1.

misaligned

     *note unaligned: 15cb.

miss

     A miss is a lookup failure in any form of *note cache (3): 162a,
     most commonly at some level of a *note storage hierarchy: 1628,
     such as a *note cache (1): 1622. or *note virtual memory: 51.
     system.

     The cost of a miss in a virtual memory system is considerable: it
     may be five orders of magnitude more costly than a hit.  In some
     systems, such as multi-process operating systems, other work may be
     done while a miss is serviced.

     *note hit: 169d.

     See also
     ........

     *note miss rate: 16a0.

miss rate

     At any level of a *note storage hierarchy: 1628, the miss rate is
     the proportion of accesses which *note miss: 169e.

     Because misses are very costly, each level is designed to minimize
     the miss rate.  For instance, in *note caches (1): 1622, miss rates
     of about 0.01 may be acceptable, whereas in *note virtual memory:
     51. systems, acceptable miss rates are much lower (say 0.00005).
     If a system has a miss rate which is too high, it will spend most
     of its time servicing the misses, and is said to *note thrash:
     16de.

     Miss rates may also be given as a number of misses per unit time,
     or per instruction.

     *note hit rate: 169f.

mmap

     ‘mmap’ is a system call provided on many Unix systems to create a
     *note mapping: 310. for a range of *note virtual addresses: 16b9.

MMU

     'Memory Management Unit'.

     The MMU (Memory Management Unit) is a hardware device responsible
     for handling *note memory (2): 194. accesses requested by the main
     processor.

     This typically involves translation of *note virtual addresses:
     16b9. to *note physical addresses: 15aa, *note cache (1): 1622.
     control, bus arbitration, *note memory protection: 15ec, and the
     generation of various exceptions.  Not all processors have an MMU.

     See also
     ........

     *note page fault: 16b5, *note segmentation violation: 1618, *note
     virtual memory: 51.

mostly-copying garbage collection

     A type of *note semi-conservative: 348. *note tracing garbage
     collection: 15df. which permits *note objects: 1ab. to *note move:
     5d. if no *note ambiguous references: 9f. point to them.

     The techniques used are a hybrid of *note copying garbage
     collection: e3. and *note mark-sweep: 15fd.

     Mostly-copying garbage collectors share many of the benefits of
     copying collectors, including *note compaction: 1643.  Since they
     support ambiguous references they are additionally suitable for use
     with uncooperative compilers, and may be an efficient choice for
     multi-threaded systems.

     *note Bartlett (1989): 14f2, *note Yip (1991): 1583.

     The *note AMC (Automatic Mostly-Copying): 62. pool class implements
     mostly-copying garbage collection.

mostly-exact garbage collection

     *note semi-conservative garbage collection: 348.

mostly-precise garbage collection

     *note semi-conservative garbage collection: 348.

moving garbage collector

moving memory manager

     A memory manager (often a *note garbage collector: 20.) is said to
     be 'moving' if *note allocated: 15ca. *note objects: 1ab. can move
     during their lifetimes.

     In the garbage collecting world this will apply to *note copying:
     e3. collectors and to *note mark-compact: 160d. collectors.  It may
     also refer to *note replicating: 16e1. collectors.

     *note copying garbage collection: e3.

     *note non-moving garbage collector: 5e.

mutable

     Any *note object: 1ab. which may be changed by a program is
     'mutable'.

     *note immutable: 16a7.

mutator

     'client program'.

     In a *note garbage-collected: f. system, the part that executes the
     user code, which *note allocates: 15ca. *note objects: 1ab. and
     modifies, or 'mutates', them.

     For purposes of describing *note incremental garbage collection: d,
     the system is divided into the 'mutator' and the *note collector
     (2): 15ae.  These can be separate threads of computation, or
     interleaved within the same thread.

     The user code issues allocation requests, but the allocator code is
     usually considered part of the collector.  Indeed, one of the major
     ways of scheduling the other work of the collector is to perform a
     little of it at every allocation.

     While the mutator mutates, it implicitly *note frees: 15d2. *note
     memory (1): 15b0. by overwriting *note references: 24.

     This term is due to *note Dijkstra et al.  (1976): 1515.

     *note collector (2): 15ae.

     The MPS documentation uses the term *note client program: d0. to
     refer to the mutator.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary N,  Next: Memory Management Glossary O,  Prev: Memory Management Glossary M,  Up: Memory Management Glossary

7.13 Memory Management Glossary: N
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

nailing

     *note pinning: 1e5.

natural alignment

     Natural alignment is an *note alignment: 68. constraint such that
     all *note objects: 1ab. must be aligned to an address that is a
     multiple of their size.

     Natural alignment is not usually required for objects larger than a
     *note word: 37c. or *note grain: 1695, which usually only need to
     be word- or grain-aligned.

     See also
     ........

     *note alignment: 68, *note padding: 16b3.

     The MPS platform interface defines the *note C: 1c. preprocessor
     macro *note MPS_PF_ALIGN: 6f. to be the natural alignment of the
     platform.

nepotism

     In *note generational garbage collection: e. nepotism is the
     tendency for *note dead: 49. *note objects: 1ab. in old *note
     generations: e1. to preserve younger dead objects that are
     referenced by them.  In other words, dead parents can cause their
     children to get promoted.

     This happens when an object gets *note promoted: 223. to an old
     generation and dies there, but does not get *note reclaimed: 4a.
     because the generation it is in does not get considered for garbage
     collection very often.  The old object might refer to objects in
     younger generations that are also dead; until the old object is
     reclaimed the younger objects will be preserved by virtue of the
     *note reference: 24. from the older, assumed alive, object.

     This is a form of *note floating garbage: 15d8. introduced by
     partitioning the objects into generations.

next fit

     A variant of the *note first fit: 37f. *note allocation mechanism:
     15d4. that uses a 'roving pointer' on a circular *note free block
     chain: 15c0.  The pointer is advanced along the chain when
     searching for a fit.  Thus each allocation begins looking where the
     previous one finished.  The rationale is to avoid creating an
     accumulation of small fragments at the head of the free block
     chain, which would have to be examined on every allocation.

     There are several variants, according to the order of blocks on the
     free block chain.  The most common variant is address-ordered next
     fit.

     This has a tendency to spread related objects out in memory, and
     also gives quite poor *note locality: 1601. for the allocator (as
     the roving pointer rotates around memory, the free blocks touched
     are those least-recently used).

     See also
     ........

     *note allocation mechanism: 15d4, *note first fit: 37f.

     *note Wilson et al.  (1995): 157a.

new space

newspace

     *note tospace: 1633.

node

     In a *note graph: 1635, a node is a representation of an *note
     object: 1ab. at the junction of zero or more *note edges: 1671.

     *note edge: 1671.

     See also
     ........

     *note graph: 1635.

non-moving garbage collector

non-moving memory manager

     A memory manager is said to be 'non-moving' if *note allocated:
     15ca. *note objects: 1ab. do not move during their lifetimes.

     Non-moving memory management techniques include *note mark-sweep:
     15fd. collection, *note reference counting: 15e0, and most kinds of
     *note manual memory management: 8.

     *note moving garbage collector: 5d.

nursery generation

     *note nursery space: 35f.

nursery space

     'nursery generation'.

     In *note generational garbage collection: e, the 'nursery
     generation' or 'space' is the area used for new *note allocation:
     15ca.

     The size of the nursery space must be chosen carefully.  Often it
     is related to the size of *note physical memory (1): 16b8.

     By default, a garbage-collected *note pool: 18. allocates into the
     first *note generation: e1. in its *note generation chain: e2, but
     this can be altered by setting the ‘MPS_KEY_GEN’ *note keyword
     argument: 53. when calling *note mps_pool_create_k(): 166.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary O,  Next: Memory Management Glossary P,  Prev: Memory Management Glossary N,  Up: Memory Management Glossary

7.14 Memory Management Glossary: O
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

object

     'cell'.

     In *note memory management: 15dd, we use the term 'object' or
     'cell' to mean a contiguous *note block: 185. of *note memory (2):
     194. forming a single logical structure.

     Objects are the units of *note allocation: 15ca, *note
     deallocation: 15d2, etc.  No connection to an object-oriented
     system is implied.

     The MPS documentation generally reserves the term 'object' for
     *note formatted objects: 23.  For units of allocation in general,
     it uses the term *note block: 185.

object format

     A data structure provided by the *note client program: d0. which
     describes the format of *note objects: 23. allocated in a *note
     pool: 18.  The MPS uses the *note format methods: 69. to find *note
     references: 24. in an object, replace an object with *note padding:
     16b3, replace an object with a *note forwarding marker: 1db, and
     other essential *note garbage collection: f. tasks.  See *note
     Object formats: 6a.

object pointer

     In the *note C: 1c. programming language, a *note pointer: 15b8. to
     an *note object: 1ab, as distinct from a *note function pointer:
     168a.  The C programming language guarantees that you can cast any
     object pointer to ‘void *’ and back without losing information.

     *note function pointer: 168a.

off-white

     'ecru'.

     In a *note treadmill: 163f. *note garbage collector: 20, the *note
     color: 163c. off-white is used to describe *note objects: 1ab.
     which are *note free (3): 15d6.  *note Baker (1992c): 14e5. used
     the term 'ecru'.

     *note black: 1604, *note gray: 1606, *note white: 1607.

     See also
     ........

     *note color: 163c, *note treadmill: 163f.

old space

oldspace

     *note fromspace: 1682.

one-bit reference count

     The one-bit *note reference count: 15e0. is a heuristic mechanism
     that lets a program test, at low cost, whether an *note object:
     1ab. is *note dead: 49.

     The one-bit reference count is a special case of the *note
     limited-field reference count: 16c5.  A single bit in an object,
     called the MRB (Multiple Reference Bit), is cleared when the object
     is *note allocated: 15ca.  Whenever another *note reference: 24. to
     the object is created, the bit is set.  Thus, MRB=0 indicates that
     there is exactly one reference to the object, and MRB=1 indicates
     that there may be more than one reference to the object.

     The MRB can be stored in the reference rather than in the object;
     doing so reduces the number of memory accesses due to MRB checking
     and setting.  When a reference is copied, the copy’s MRB is set.
     If the MRB in the old reference is 0, it also needs to be set.
     Setting the MRB in the old reference requires that the program
     knows the location the old reference came from, and that it can
     prove that location has not since been overwritten with other data.

     The one-bit reference count is used by a compiler to augment an
     object lifetime analysis.  When compile-time analysis predicts that
     a particular object may be dead (typically because the variable
     that references the object is dead), the compiler can generate code
     that will check the object’s MRB at run-time.  If the MRB is 0,
     then the object is dead.

     Using a one-bit reference count does have a cost: the MRB uses
     space that could sometimes be put to other use, and the MRB must be
     set every time the number of references to the object increases.
     The one-bit reference count is cheaper than other kinds of
     reference counting, however, since the space cost is only one bit
     and the reference count is not adjusted when references are
     destroyed.

     The one-bit reference count was suggested by *note Friedman & Wise
     (1977): 1523.  Storing the MRB in the reference was suggested by
     *note Stoye, Clarke, and Norman (1984): 156e.

     *note Jones et al.  (2012): 1538.

opaque type

     In the MPS interface, an 'opaque type' is a pointer to an
     incomplete structure type.  The client programs must not rely on
     the details of its implementation.  For example, the type *note
     mps_arena_t: 11e. is an alias for ‘struct mps_arena_s *’, but the
     implementation of ‘struct mps_arena_s’ is not public.  See *note
     Interface conventions: 112.

     *note transparent type: 127.

out parameter

     A function parameter that points to a location for the caller to
     receive data from the function.

     *note in parameter: 16ab.

     Out parameters are given names ending with ‘_o’.  See *note
     Interface conventions: 112.

out-of-band header

     In some *note memory managers: 15cd, each *note allocated: 15ca.
     *note block: 185. has additional information (such as the size of
     the block or a *note tag: 88.) stored in a separate block; this is
     called 'an out-of-band header'.

     *note in-band header: 1d1.

overcommit

     In some circumstances, although a range of *note virtual addresses:
     16b9. has been *note mapped: 190. as far as the user program is
     concerned, the *note physical storage: 16ed. might not be allocated
     until it is accessed.  This is called 'overcommitting'.

     Overcommitting shares *note swap space: 15e9. resources more
     flexibly, especially when crude *note suballocators: 16b2. are
     involved, but it can lead to an out-of-resource error during a
     *note memory (2): 194. access; few environments deal with this
     situation gracefully.

     Unix systems such as IRIX and AIX can do this on *note sbrk: 160f.
     and *note mmap: 16d0. calls.

overwriting error

     'bounds error'.

     An overwriting or bounds error occurs when the programmer intends
     his program to write to a particular *note block: 185. of *note
     memory (1): 15b0, but a program error causes the program to write
     outside the bounds of that block.

     See also
     ........

     *note fencepost: 283.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary P,  Next: Memory Management Glossary Q,  Prev: Memory Management Glossary O,  Up: Memory Management Glossary

7.15 Memory Management Glossary: P
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

padding

     Padding is redundant *note memory (2): 194. within the memory *note
     allocated: 15ca. to an *note object: 1ab.  It is usually inserted
     because of *note alignment: 68. restrictions on the fields of the
     object or on the object itself.

     Padding is a form of *note internal fragmentation: 379.

padding method

     A *note format method: 69. that is called by a *note moving: 5d.
     *note pool: 18. to create a *note padding object: 67.  See *note
     mps_fmt_pad_t: 91.

padding object

     A *note formatted object: 23. that consists of *note padding: 16b3.
     One of three types of formatted objects, the other two being *note
     client objects: 325. and *note forwarding objects: 66.

page

     A *note virtual memory: 51. system usually deals with *note memory
     (1): 15b0. *note blocks: 185. of fixed size as units for *note
     paging: 15e7.  These are known as 'pages'.

     Pages are often 4 *note kB: 188. or 8 kB in size.  This size is
     determined by the addressing hardware of the machine.

page fault

     An exception when accessing *note virtual memory: 51, usually
     resulting in a *note page: 92. being fetched from disk.

     A page fault is an exception occurring during the translation of
     *note virtual addresses: 16b9. to *note physical addresses: 15aa.
     “Page fault” usually means an access to a page that has been *note
     paged out: 16d1. and hence requires fetching from disk, but it is
     sometimes also used to mean *note invalid page fault: 16b4. or
     *note protection fault: 1d7.

     See also
     ........

     *note paged in: 195, *note paged out: 16d1, *note paging: 15e7,
     *note read fault: 16f0, *note write fault: 16f1.

page marking

     Page marking is a form of *note card-marking: 162e. where the *note
     card: 162d. is the same size as a *note page: 92.

page protection

     *note protection: 1fd.

     Many operating systems support protection of *note memory (2): 194.
     *note pages: 92.  Individual pages may be protected against a
     combination of read, write or execute accesses by a process.

page table

     In a *note virtual memory: 51. system, it is common to map between
     *note virtual addresses: 16b9. and *note physical addresses: 15aa.
     by means of a data structure called a 'page table'.

     The *note page: 92. number of an address is usually found from the
     most significant bits of the address; the remaining bits yield the
     offset of the *note memory location: 15b4. within the page.  The
     page table is normally indexed by page number and contains
     information on whether the page is currently in *note main memory:
     311, and where it is in main memory or on disk.

     Conventional page tables are sized to the virtual *note address
     space: 54. and store the entire virtual address space description
     of each process.  Because of the need to keep the
     virtual-to-physical translation time low, a conventional page table
     is structured as a fixed, multi-level hierarchy, and can be very
     inefficient at representing a sparse virtual address space, unless
     the allocated pages are carefully aligned to the page table
     hierarchy.

     See also
     ........

     *note inverted page table: 16b6.

paged in

     In a *note virtual memory: 51. system, *note memory (2): 194. is
     described as 'paged in' if it is available in *note physical memory
     (1): 16b8.

     *note swapped in: 16f3.

     *note paged out: 16d1.

     See also
     ........

     *note paging: 15e7.

paged out

     In a *note virtual memory: 51. system, *note memory (2): 194. is
     described as 'paged out' if it is not available in *note physical
     memory (1): 16b8.

     *note swapped out: 169b.

     *note paged in: 195.

     See also
     ........

     *note paging: 15e7.

paging

     In a *note virtual memory: 51. system, 'paging' is the act of
     transferring *note pages: 92. between *note physical memory (1):
     16b8. and *note backing store: 15d1. (usually disk).

     When pages need to be paged out, a heuristic is used to select ones
     that will not be needed soon; “least recently used” is a popular
     one.

     *note swapping: 15e8.

     See also
     ........

     *note paged in: 195, *note paged out: 16d1.

palimpsest

     A *note block: 185. of *note memory (2): 194. that has been *note
     allocated: 15ca, *note freed (1): 15d2. (or *note reclaimed: 4a.),
     and then allocated again.  Such memory may contain data from the
     previous use if portions of it remain uninitialised.

     This commonly occurs on the *note stack: 15bc, especially if the
     compiler allocates large *note stack frames: 15b1. in anticipation
     of allocating data structures on the stack.

     If the palimpsest is being *note scanned: 65. *note conservatively:
     349, such left-over data may cause *note unreachable: 21. *note
     objects: 1ab. to appear *note reachable: 96. and thus become *note
     floating garbage: 15d8.  If it is scanned *note precisely: 164f,
     such left-over data, if treated as *note pointers: 15b8, is a bug.

parallel garbage collection

     'concurrent garbage collection'.

     A parallel or concurrent *note collector (2): 15ae. executes
     simultaneously with the *note mutator: 30c, usually on a
     multi-processor machine.

     Concurrent *note garbage collection: f. must cope with the mutator
     changing *note objects: 1ab. while collection occurs.  The problem
     is similar to that of *note incremental GC: d, but harder.  The
     solution typically involves *note barriers (1): 60.

     *note incremental: d.

     See also
     ........

     *note replicating garbage collector: 16e1.

     *note Doligez & Leroy (1993): 1519, *note Doligez & Gonthier
     (1994): 151a.

parked state

     One of the four states an *note arena: 16. can be in (the others
     being the *note clamped state: 19f, the *note postmortem state: d5,
     and the *note unclamped state: 192.).  In the parked state, no
     *note garbage collection: f. is in progress, no object motion
     occurs and the staleness of *note location dependencies: 19a. does
     not change.  Call *note mps_arena_park(): b9. or *note
     mps_arena_collect(): ce. to put an arena into the parked state.

perfect fit

     If an *note allocation: 15ca. request is satisfied exactly from a
     *note free block: 15bf. with no *note fragmentation: 17e, this is
     said to be a *note perfect fit: 15f2.

     See also
     ........

     *note allocation mechanism: 15d4, *note best fit: 382, *note free
     block: 15bf.

phantom reachable

phantomly reachable

     In *note Java: 167f, an object is 'phantom reachable' if it is
     neither *note strongly: 16f7. nor *note softly: 16f8. nor *note
     weakly reachable: 16f9. and has been *note finalized: b. and there
     is a path from the *note roots: 97. to it that contains at least
     one *note phantom reference: 16fa.

     When the Java *note collector (1): 15d7. determines that an object
     is phantom reachable, the *note reference objects: 16fb. containing
     the phantom references are enqueued.

     The Java specification says that the phantom reference is not
     cleared when the reference object is enqueued, but actually,
     there’s no way in the language to tell whether that has been done
     or not.  In some implementations, JNI weak global references are
     weaker than phantom references, and provide a way to access phantom
     reachable objects.

     See also
     ........

     *note reachability: 96.

     Class java.lang.ref.PhantomReference(1), Reference Objects and
     Garbage Collection(2).

phantom reference

     In *note Java: 167f. terminology, 'phantom reference' is used to
     mean a *note reference: 24. encapsulated in a *note reference
     object: 16fb. of class ‘PhantomReference’.

     Phantom references form one of three kinds of *note weak reference
     (1): c. in Java.  They are handy for performing clean-ups after an
     object has *note died: 49. and been *note finalized: b.

     See also
     ........

     *note phantom reachable: 16f5.

     Class java.lang.ref.PhantomReference(3), Reference Objects and
     Garbage Collection(4).

physical address

     'absolute address'.

     Physical *note addresses: 126. are used to index into *note
     physical memory (1): 16b8.  On some systems, they are called
     'absolute addresses'.

     In a *note virtual memory: 51. system the application program
     handles *note virtual addresses: 16b9. and these are translated to
     physical addresses by the *note MMU: 16db.

     *note virtual address: 16b9.

physical address space

     The physical *note address space: 54. is the space of *note
     physical addresses: 15aa.

     *note virtual address space: 15bb.

physical memory^(1)

     'real memory'.

     Physical memory is *note memory (1): 15b0. that is wired to
     directly to the processor, addressable by *note physical address:
     15aa.

     This term is basically synonymous to *note main memory: 311, but is
     used in contrast to *note virtual memory: 51. and *note backing
     store: 15d1.

     While modern computers usually have lots of *note virtual memory:
     51, performance is still closely related to the quantity of
     physical memory available.  If a system has insufficient physical
     memory, it may *note thrash: 16de.

     *note main memory: 311.

physical memory^(2)

     'physical storage'.

     Physical memory is *note memory (1): 15b0. on physical storage
     devices, such as *note RAM: 55. or disks.

     This term is often contrasted to *note virtual address space: 15bb.
     that might not be mapped to any actual storage.

     *note memory (1): 15b0.

physical storage

     *note physical memory (2): 15b6.

pig in the python

     'pig in the snake'.

     In a *note generational: e. collector, when long-lived *note
     objects: 1ab. are *note allocated: 15ca. in *note nursery space:
     35f, collection effort will be wasted as those objects survive and
     are *note promoted: 223. from *note generation: e1. to generation.
     This is especially noticeable in a *note copying collector: e3,
     where long-lived objects will be copied many times.  This
     difficulty is similar to that of a python which swallows its prey
     whole and is somewhat immobilized as it digests it.

     Modern collectors permit objects to be allocated directly into
     appropriate generations or pools to avoid this problem.  Long-lived
     objects can be allocated directly into long-term generations.
     Large objects can be allocated directly into pools with special
     support for large objects (such as copying by remapping,
     incremental copying, or not copying at all).

     See also
     ........

     *note generational garbage collection: e.

     A *note pool: 18. can be configured to allocate into a specific
     *note generation: e1. in its *note generation chain: e2. by setting
     the ‘MPS_KEY_GEN’ *note keyword argument: 53. when calling *note
     mps_pool_create_k(): 166.

pig in the snake

     *note pig in the python: 16fc.

pinning

     'nailing'.

     In *note copying garbage collection: e3, an object may not be
     movable because it is the target of an *note ambiguous reference:
     9f. or because it is referenced by *note foreign code: 10b. that
     does not co-operate with the collector.  Such an object is said to
     be 'pinned'.

placement policy

     *note allocation policy: 380.

platform

     The term 'platform' is used to refer to the combination of
     operating system, processor architecture, and compiler.  See *note
     Platforms: 130.

plinth

     The plinth is a program module providing the MPS with all the
     support functions it needs from the execution environment.  The
     plinth removes the need for external libraries, by getting the
     support from the *note client program: d0.  See *note Plinth: 3b.

pointer

     'Pointer' data types represent a reference to an *note object: 1ab.
     or a *note location: 15b4.

     Pointers may be specialized by the type of the object referred to.

     Typically, pointers are represented by an *note address: 126, but
     they can be more complicated when they need to carry more
     information.  For example, when the referent is smaller than a
     *note word: 37c, an offset within the word might be needed.

     *note address: 126, *note reference: 24.

     See also
     ........

     *note tag: 88.

pool

     A pool is responsible for requesting memory from the *note arena:
     16. and making it available to the *note client program: d0. via
     *note mps_alloc(): ad. or via an *note allocation point: 63.
     Multiple pools can coexist in one arena.  Pools belong to the type
     *note mps_pool_t: 1b1.  See *note Pools: 1e. and the *note Pool
     reference: 22.

pool class

     A value of type *note mps_pool_class_t: 1b4. describing a class of
     *note pools: 18. that manage memory according to particular policy.
     See *note Pool reference: 22.

postmortem state

     One of the four states an *note arena: 16. can be in (the others
     being the *note unclamped state: 192, the *note clamped state: 19f,
     and the *note parked state: b8.).  In the postmortem state, objects
     do not move in memory, the staleness of *note location
     dependencies: 19a. does not change, memory occupied by *note
     unreachable: 21. objects is not recycled, all memory protection is
     removed, and memory may be in an inconsistent state.  Call *note
     mps_arena_postmortem(): d6. to put an arena into the postmortem
     state.

precise garbage collection

     *note exact garbage collection: 164f.

precise reference

     *note exact reference: 61.

precise root

     *note exact root: 20b.

premature free

     'use after free'.

     A 'premature free' or 'use after free' occurs when *note memory
     (2): 194. is *note deallocated: 15d2, but is later accessed.

     Under *note manual memory management: 8, this usually occurs when
     one part of a program decides it has finished using a memory *note
     block: 185, and is unaware that another part of the program is
     still using it.  This is rare under *note automatic memory
     management: 9.

     See also
     ........

     *note double free: 26b.

premature promotion

     *note premature tenuring: 1703.

premature tenuring

     'premature promotion'.

     When a short-lived *note object: 1ab. *note allocated: 15ca. in a
     *note generational garbage collector: e. is *note promoted: 223.
     (due to poor timing) into a less-frequently collected *note
     generation: e1.  This 'prematurely tenured' object may become *note
     garbage: 1649. very soon after promotion, but will not be *note
     reclaimed: 4a. for some time because it is now in a less frequently
     collected generation.

     This problem is essentially due to quantization error: all objects
     in a generation are treated as if they have the same age, even
     though they range from as old as the previous promotion cycle to
     new-born.

     Modern *note collectors (1): 20. offer several remedies for
     premature tenuring.  If the client program knows that it is
     entering a phase that will create many short-lived objects, it can
     forestall all promotion until it knows it is done with those
     objects.  Thus no objects will be prematurely promoted: they will
     all be seen as garbage.  Another solution is to create *note
     buckets: 15c3. within generations to more accurately classify
     objects by age and only promote those which have reached a certain
     minimum.

primary storage

     *note main memory: 311.

promotion

     'tenuring'.

     Promotion or tenuring is the act of moving an *note object: 1ab.
     from its current *note generation: e1. to an 'older' one (one that
     contains objects that are expected to survive longer).

     “Tenuring” is used particularly about promotion to the oldest
     generation.

     See also
     ........

     *note generational garbage collection: e.

protectable root

     A *note root: 97. which the MPS may *note protect: 1fd. with a
     *note write barrier: 214.  A protectable root is created by
     specifying the *note root mode: a0. *note MPS_RM_PROT: 211. when
     calling a registration function such as *note mps_root_create():
     9c.

protected

     A region of *note memory (2): 194. is said to be protected if there
     is a *note barrier (1): 60. on that region.

     *note unprotected: 1a8.

protection

     'memory protection', 'page protection'.

     Many operating systems support protection of *note memory (2): 194.
     *note pages: 92.  Individual pages may be protected against a
     combination of read, write or execute accesses by a process.

     A process which attempts a protected access will trigger a *note
     protection fault: 1d7.  Protection is typically implemented in
     hardware by the *note MMU: 16db. as part of the support for *note
     virtual memory: 51. .

     Pages can be protected for a number of reasons: a *note
     generational: e. or *note incremental: d. *note garbage collector:
     20. may want to place *note barriers (1): 60. on pages; an
     operating system may want to protect pages for security, or to
     implement “copy-on-write” or “demand-zero-filled” pages.

     See also
     ........

     *note read fault: 16f0, *note write fault: 16f1.

     *note Appel et al.  (1988): 14db, *note Singhal et al.  (1992):
     1568, *note Hosking & Moss (1993): 152f.

protection exception

     *note protection fault: 1d7.

protection fault

     'barrier hit', 'protection exception', 'protection violation'.

     A protection fault is an exception or trap which occurs when a
     process attempts to access *note memory (2): 194. which has been
     *note protected: 1fd.

     Some *note garbage collectors: 20. use handlers for protection
     faults to provide *note barriers (1): 60.

     See also
     ........

     *note General Protection Fault: 1692, *note segmentation violation:
     1618.

protection violation

     *note protection fault: 1d7.

   ---------- Footnotes ----------

   (1) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html

   (2) http://pawlan.com/monica/articles/refobjs/

   (3) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html

   (4) http://pawlan.com/monica/articles/refobjs/


File: MemoryPoolSystem.info,  Node: Memory Management Glossary Q,  Next: Memory Management Glossary R,  Prev: Memory Management Glossary P,  Up: Memory Management Glossary

7.16 Memory Management Glossary: Q
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

quadword

     A 'quadword' is a unit of memory consisting of four adjacent *note
     words: 37c.

     In Digital’s Alpha architecture, a quadword of 64 bits was actually
     the natural word size, but the term 'word' was still used for the
     16-bit unit, for compatibility with the PDP-11.

     See also
     ........

     *note doubleword: 1667.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary R,  Next: Memory Management Glossary S,  Prev: Memory Management Glossary Q,  Up: Memory Management Glossary

7.17 Memory Management Glossary: R
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

RAM

     'random access memory'.

     RAM (random access memory) is a type of *note physical memory (2):
     15b6. that can be read from and written to.

     *note main memory: 311.

     See also
     ........

     *note dynamic RAM: 166d, *note ROM: 16ce, *note static RAM: 170b.

random access memory

     *note RAM: 55.

ramp allocation

     An *note allocation pattern: 272. indicating to the MPS that most
     of the blocks allocated after the call to *note
     mps_ap_alloc_pattern_begin(): 273. are likely to be *note dead: 49.
     by the time of the corresponding call to *note
     mps_ap_alloc_pattern_end(): 274.  See *note Ramp allocation: 228.

rank

     A value of *note mps_rank_t: 146. indicating whether a *note
     reference: 24. is *note ambiguous: 1c4. (*note mps_rank_ambig():
     20a.), *note exact: 20b. (*note mps_rank_exact(): 9d.) or *note
     weak: 20d. (*note mps_rank_weak(): 20c.).

rash

     A *note variety: c9. in which no MPS functions *note assert: 284.
     that their data structures are valid.  Select it by defining *note
     CONFIG_VAR_RASH: 173.  Compare *note cool: c8. and *note hot: 162.

raw

     *note unwrapped: 170e.

reachable

     An *note object: 1ab. is 'reachable' if it is *note referred: 24.
     to by a *note root: 97, or is referred to by a reachable object;
     that is, if it can be reached from the roots by following *note
     references: 24.

     Reachability is used as an approximation to *note liveness: 78. in
     *note tracing garbage collection: 15df.

     In *note Java: 167f, the *note reference objects: 16fb. together
     with ordinary references and *note finalization: b. generate a
     hierarchy of reachability that guides the *note collector (1):
     15d7. on what to do when an object is about to *note die: 49.
     There are six strengths:

       1. *note strongly reachable: 16f7.;

       2. *note softly reachable: 16f8.;

       3. *note weakly reachable: 16f9.;

       4. *note finalizable: b.;

       5. *note phantom reachable: 16f5.;

       6. *note unreachable: 21.

     Basically, an object is only as reachable as the weakest link in
     the strongest path from the roots.  Note that the Java
     specification’s description of the reachabilities is a bit patchy,
     but that’s what it intends.  It is unspecified where Java Native
     Interface’s 'weak global references' fit into this.

     *note live: 78.

     *note unreachable: 21.

     Package java.lang.ref(1), Reference Objects and Garbage
     Collection(2).

read barrier

     A read *note barrier (1): 60. is a block on reading from certain
     *note memory (2): 194. *note locations: 15b4. by certain threads or
     processes.

     Read barriers are used for *note incremental: d. or *note
     concurrent: 15ed. *note garbage collection: f.

     See also
     ........

     *note write barrier: 214.

read fault

     An exception which occurs when reading from an address in *note
     virtual memory: 51.

     This is probably either a *note page fault: 16b5, an *note invalid
     page fault: 16b4. or a *note protection fault: 1d7.

     *note segmentation violation: 1618.

     See also
     ........

     *note write fault: 16f1.

read-only memory

     *note ROM: 16ce.

real memory^(1)

     A system with no *note virtual memory: 51. capability can be said
     to have 'real memory'.

     On older architectures, programs could only directly access data in
     real memory.  Where this was inefficient, they had to store data on
     disk, and sometimes had alternate portions of program image called
     'overlays'.

     *note virtual memory: 51.

real memory^(2)

     *note physical memory (1): 16b8.

reclaim

     'Reclaiming' an *note object: 1ab. or the *note memory (1): 15b0.
     occupied by it is making it available for reuse after the object is
     no longer needed.

     This word is usually used only in connection with *note automatic
     memory management: 9.

     *note recycle: 15de.

recycle

     'Recycling' *note memory (1): 15b0. means making it available for
     reuse after it has been occupied by an *note object: 1ab. that is
     no longer needed.

     In simple cases, this might simply involve adding a *note memory
     (2): 194. *note block: 185. to the *note free list: 268.  Another
     possibility is *note unmapping: 1685. memory so that the *note
     backing store: 15d1. can be allocated to another process.

     *note reclaim: 4a.

reference

     In memory management, 'a reference' is the general term for a link
     from one *note object: 1ab. to another.  Some programming languages
     have more specific meanings for the term.

     The terms “*note pointer: 15b8.” and “reference” are often
     interchangeable, but some programming languages differentiate the
     two in subtle ways.

     *note address: 126, *note pointer: 15b8.

     A reference is represented in the *note C: 1c. interface by a value
     of type *note mps_addr_t: 11d. (an alias for ‘void *’) which points
     to a *note memory location: 15b4. within the object (typically the
     base of the object, but for objects with *note headers: 1d1. this
     may not be the case).  The pointer returned by *note mps_alloc():
     ad. and *note mps_reserve(): b0. is a reference to the object
     allocated.

     The *note client program: d0. is free to represent references as it
     chooses (for example, with *note tags: 7d.), provided that during
     *note scanning: 65. it is able to decode a reference from its
     representation into the MPS interface representation and encode a
     reference from the MPS into its representation.

reference counting

     Reference counting systems perform *note automatic memory
     management: 9. by keeping a count in each *note object: 1ab,
     usually in a *note header: 1d1, of how many *note references: 24.
     there are to the object.  Objects to which there are no references
     cannot be accessed by the *note mutator: 30c.; they are therefore
     *note dead: 49. and may be *note reclaimed: 4a.

     The reference count is incremented for each new reference, and is
     decremented if a reference is overwritten, or if the referring
     object is recycled.  If a reference count falls to zero, then the
     object is no longer required and can be recycled.

     There are four main problems with simple reference counting:

       1. The reference count field usually has to have limited size,
          and the system therefore breaks down if the number of possible
          references to an object is unbounded;

       2. Reference counting involves an operation on every modification
          of a pointer, which increases code size, increases demand for
          *note memory bandwidth: 16d9, decreases *note locality of
          reference: 1601. and can be a serious performance penalty
          (especially in multi-threaded environments where reference
          count updates require synchronization);

       3. Every object needs to be slightly larger in order to store the
          reference count;

       4. If any objects are part of a *note cyclic data structure:
          1659. then they will always have a non-zero reference count,
          and hence won’t be reclaimed when they are dead.

 [image src="MemoryPoolSystem-figures/refloop.svg" alt="Diagram: Garbage with non-zero reference counts." ]


     Figure: Garbage with non-zero reference counts.

     Reference counting has the advantage that it can reclaim objects
     promptly, and for this reason it is often used to reclaim
     non-cyclic data structures in file systems, databases and operating
     system kernels.  When there is a possibility of cyclic data
     structures, reference counting is sometimes used together with a
     *note tracing garbage collector: 15df. that runs infrequently.
     Such combinations are generally less efficient than using a tracing
     collector by itself, but the promptness of reference counting may
     be important.

     Pauses due to reference counting are typically fairly short, and it
     may be appropriate as a form of *note incremental garbage
     collection: d.  But removing a single reference may cause the
     recycling of a large number of objects at once, so it is not suited
     to real-time systems where minimum pause times must be guaranteed.
     There are more complex variations of the technique that address
     this problem.

     Reference counting is often used because it can be implemented
     without any support from the language or compiler.  In *note C++:
     1d. this can be encapsulated in a class, using a *note smart
     pointer: 1711.  However, it would normally be more efficient to use
     a tracing garbage collector instead.  The performance of reference
     counting can be improved substantially with compiler support, using
     refinements such as *note deferred reference counting: 165f, which
     has been successfully used in *note Smalltalk: 1661. and other
     languages.

     Despite the problems, reference counting is often used for *note
     distributed garbage collection: 1663.  This is because refinements
     such as *note weighted reference counting: 1666. require less
     inter-process communication than *note tracing: 4b.

     See also
     ........

     *note limited-field reference count: 16c5, *note one-bit reference
     count: 16c6.

reference object

     In *note Java: 167f, a 'reference object'
     (‘java.lang.ref.Reference’) encapsulates a *note reference: 24. to
     some other object, in order to make the *note garbage collector:
     20. handle it specially.  In particular, a Java program can use
     this to detect when the referent becomes *note unreachable: 21.

     Basically, the encapsulated reference is a *note weak reference
     (1): c.; it will be cleared by the *note collector (1): 15d7. when
     all other references to the referent have disappeared.  However, in
     order to better control what happens at the end of an object’s
     *note lifetime: b5, Java 1.2 provides three classes of reference
     objects, each with its own peculiarities: ‘SoftReference’,
     ‘WeakReference’, and ‘PhantomReference’.  Each of these classes has
     its uses in managing memory.  The reference objects together with
     ordinary references and *note finalization: b. generate a hierarchy
     of *note reachability: 96. that guides the collector on what to do
     when an object is about to *note die: 49.

     A reference object can be 'registered' with a queue, and it will be
     enqueued when the collector determines that the referent is *note
     softly: 16f8, *note weakly: 16f9. or *note phantom reachable: 16f5,
     as the case may be.  A program can use these queues to perform some
     action when an object is dying.  This allows finer control than the
     older *note finalization: b. mechanism alone.

     This feature was introduced in Java 1.2 (confusingly, part of the
     Java 2 Platform).

     See also
     ........

     *note phantom reference: 16fa, *note soft reference: 1712, *note
     weak reference (2): 1713.

     Package java.lang.ref(3), Reference Objects and Garbage
     Collection(4).

     *note Dybvig et al.  (1993): 151b.

region inference

     Region inference is a technique for determining when *note objects:
     1ab. become *note dead: 49. (even if they are *note reachable: 96.)
     by a static analysis of the program.

     Region inference infers a 'region' for each object.  When a region
     dies, all the objects in it are known to be *note dead: 49, whether
     reachable or not.  Regions obey a strict *note stack: 15bc.
     discipline; that is, when a region dies, all younger regions also
     die.  In this way, region inference occupies a middle ground
     between *note stack allocation: 15e2. and *note heap allocation:
     1653.

     *note Tofte & Talpin (1997): 1572.

register

     A 'register' is a small unit of *note memory (2): 194. that is
     attached to a processor and accessible very quickly.  Registers
     typically form the highest level of a computer’s *note storage
     hierarchy: 1628.

     In some programs (for example, those compiled by typical *note C:
     1c. or *note C++: 1d. compilers), a subset of the registers is
     always accessible by the *note mutator: 30c. and so forms a *note
     root: 97.

     The *note scan method: 73. for the root containing the registers is
     hard to write (it depends on the operating system, the processor
     architecture, and in some cases the compiler), so the MPS provides
     (on its supported platforms) the function *note
     mps_stack_scan_ambig(): 32f.

register set partitioning

     Run-time systems for *note garbage-collected: f. languages
     sometimes partition the set of machine *note registers: 26. 'a
     priori' into two categories: those always *note traced: 4b. and
     updated by the *note garbage collector: 20. and those ignored by
     it.

     The former are always maintained in a format understood by the
     collector; the latter are never used to hold *note references: 24.
     to collectable *note objects: 1ab.  More complicated schemes are
     also possible.

     This partitioning provides a separation of concerns between the
     compiler and the *note garbage collector: 20.  The compiler can
     generate code that produces values the garbage collector would not
     be able to handle (say, because they have no *note tags: 88.), as
     long as those values are kept in the ignored registers.  The
     garbage collector can trust that the registers it looks at always
     contain valid data, and can perform *note exact garbage collection:
     164f.

     Register set partitioning increases the demand for registers
     ('register pressure'), but may reduce the amount of *note boxing:
     160b. needed.

relocation

     'Relocating' means moving data from one location to another and
     updating all *note references: 24.

     Relocation is often performed to avoid *note external
     fragmentation: 383.

     Program loading sometimes relocates code and *note static: 1610.
     data.

     *note moving: 5d.

     See also
     ........

     *note compaction: 1643, *note moving memory manager: 1ad.

remembered set

     A remembered set is the technique of keeping a separate list of
     interesting *note references: 24. between two sets of *note
     objects: 1ab, so you don’t have to find them by *note scanning: 65.

     Many *note memory management: 15dd. algorithms depend on
     partitioning the objects and require special handling for
     references between partitions.  Keeping track of such references in
     a remembered set eliminates the need to scan the originating
     partition to find them.

     A typical use in *note generational garbage collection: e. is
     remembering *note references: 24. from an older *note generation:
     e1. to a younger one.

     *note entry table (2): 1674.

     *note Ungar (1984): 1573, *note Jones et al.  (2012): 1538.

remote reference

     A *note reference: 24. that logically belongs to a *note formatted
     object: 23. and so must be *note fixed: b4. when the object is
     *note scanned: 65, but which is not stored within the block
     containing the object.  (For example, in an auxiliary table of some
     sort.)

     The MPS does not generally support remote references because those
     references may be *note protected: 1fd. and so if *note scan
     method: 73. attempts to *note fix: b4. them this will hit a *note
     barrier (1): 60. and cause a re-entrant call to the MPS.

replicating garbage collector

     A variant of *note copying garbage collection: e3, which does not
     destroy the original *note object: 1ab. when making a copy.

     This is useful in an *note incremental: d. or *note concurrent:
     15ed. *note collector (1): 15d7, as no *note read barrier: 1d6. is
     required; the *note mutator: 30c. can continue to use old objects.
     The collector uses a *note write barrier: 214. to replicate the
     writes to the new copies.

     See also
     ........

     *note broken heart: 1611, *note copying garbage collection: e3.

     *note Nettles et al.  (1992): 154c, *note Nettles & O’Toole (1993):
     154f, *note Nettles & O’Toole (1993a): 154e, *note O’Toole &
     Nettles (1994): 1552.

reserved

     In a *note virtual memory: 51. system, it is usually possible to
     hold range of *note virtual addresses: 16b9. 'reserved' without
     making it *note mapped: 190.

     Reserving addresses prevents other components of the program using
     the same addresses, without consuming *note swap space: 15e9.  This
     technique is often used in *note BIBOP: 15f6. schemes, where one
     might want to reserve a large amount of *note address space: 54.
     but only sparsely map it.

     On some systems there are special calls for reserving; on others
     one can create *note mappings: 310. that don’t need *note backing
     store: 15d1.  For example, on some Unix systems, ‘mmap /dev/zero’
     with no access.

     See also
     ........

     *note mapping: 310, *note mmap: 16d0.

     The function *note mps_arena_reserved(): 196. returns the total
     address space reserved by an arena.

resident

     In a *note cache (2): 1627. system, that part of the cached storage
     which currently has a copy in the cache is called 'resident'.
     Ideally, the *note working set: 16ba. should be resident.

     See also
     ........

     *note cache (2): 1627, *note resident set: 1715, *note storage
     hierarchy: 1628.

resident set

     In a *note virtual memory: 51. system, a process’ resident set is
     that part of a process’ *note address space: 54. which is currently
     in *note main memory: 311.  If this does not include all of the
     process’ *note working set: 16ba, the system may *note thrash:
     16de.

result code

     A value returned from an MPS function, represented by the type
     *note mps_res_t: 14d.  The result code *note MPS_RES_OK: 5a.
     indicates success; other values indicate errors.  See *note Error
     handing: 5b.

resurrection

     An object is said to have been 'resurrected' if it was determined
     to be *note finalizable: b. by the *note garbage collector: 20.
     (that is, the only thing keeping it alive was the fact that it
     required finalization), but then a new *note strong reference: 244.
     was created to it.

     This can happen via a *note weak reference (1): c. or by the
     finalization procedure storing a permanent copy of its reference to
     the object.

     See *note Finalization: f0.

retention

     The failure to *note recycle: 15de. *note floating garbage: 15d8,
     due to some approximation or optimization in the *note garbage
     collector: 20.; also the amount of memory thus retained.

     *note Boehm (2001): 14fb.

ROM

     'read-only memory'.

     ROM (read-only memory) is a type of *note physical memory (2):
     15b6. that can be read from, but not written to.  The contents of
     ROM are usually set in the factory.

     See also
     ........

     *note RAM: 55.

root

     In *note tracing garbage collection: 15df, a root holds a *note
     reference: 24. or set of references to *note objects: 1ab. that are
     'a priori' *note reachable: 96.  The *note root set: 1716. is used
     as the starting point in determining all reachable data.

     Roots basically comprise the references in the state of the *note
     mutator: 30c.  Typical roots are global variables, other *note
     static: 1610. data, and the *note control stack: 27.

     See also
     ........

     *note ambiguous root: 1c4, *note exact root: 20b, *note strong
     root: 1717, *note weak root: 20d.

     See *note Roots: 28.

root description

     The *note arena: 16. uses root descriptions to find *note
     references: 24. within the *note client program’s: d0. *note roots:
     97.  Root descriptions belong to the type *note mps_root_t: 98.

root mode

     A value of type *note mps_rm_t: 20f. describing whether a *note
     root: 97. is *note constant: 215, *note protectable: 216, or both.
     The root mode tells the MPS whether it may place a *note barrier
     (1): 60. on the root.

root set

     The 'root set' is the collection of *note roots: 97. that the *note
     mutator: 30c. declares to the *note collector (2): 15ae.

     See also
     ........

     *note garbage collection: f.

   ---------- Footnotes ----------

   (1) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/package-summary.html

   (2) http://pawlan.com/monica/articles/refobjs/

   (3) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/package-summary.html

   (4) http://pawlan.com/monica/articles/refobjs/


File: MemoryPoolSystem.info,  Node: Memory Management Glossary S,  Next: Memory Management Glossary T,  Prev: Memory Management Glossary R,  Up: Memory Management Glossary

7.18 Memory Management Glossary: S
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

sbrk

     ‘sbrk’ is a Unix library function that adjusts the limit of the
     data segment; this limit is known as the 'break'.

     ‘sbrk’ and its companion *note brk: 15d9. are obsolete on Unix
     systems that support *note virtual memory: 51.

     ‘sbrk’ returns the previous value of the break, so ‘sbrk(0)’ was a
     common idiom for getting the current value.

scalar data type

     A scalar data type is a type that is representable in a single
     dimension and whose objects have only magnitude as value.

     Examples of scalar data types include: integers, floating-point
     numbers, enumerations, and characters.

     The objects of a scalar data type are *note leaf objects: 107.
     Scalar data types with bounded magnitude can be represented
     compactly using *note value objects: 16a6.

     Because compact representation solves many memory management
     issues, many older programming languages only offered bounded
     scalar data types.  For example, the ‘int’ type in *note C: 1c. is
     defined to have a magnitude that can be represented by a *note
     word: 37c.

     See also
     ........

     *note algebraic data type: 15c5, *note leaf object: 107, *note
     value object: 16a6, *note vector data type: 15c7.

scan

     The examination of an *note object: 1ab. or an area of *note memory
     (2): 194. to find *note references: 24, typically as part of *note
     tracing: 4b.

     Scanning examines memory that has been decided to be non-*note
     garbage: 1649, to find references to objects that have been *note
     condemned: 221.

     See *note Scanning: 25.

scan method

     A function that examines a block of memory to find *note
     references: 24. and indicate them to the MPS. A scan method forms
     part of an *note object format: 39.  See *note mps_fmt_scan_t: 74.

scan state

     A scan state represents the state of the current *note scan: 65.
     The MPS passes a scan state to the *note scan method: 73. of an
     *note object format: 39. when it needs to *note scan: 65. for *note
     references: 24. within a region of memory.  Scan states belong to
     the type *note mps_ss_t: 1dc.

scavenging garbage collection

     *note copying garbage collection: e3.

SDRAM

     Synchronous Dynamic Random Access Memory.  A high performance
     variant of *note DRAM: 166a.

     SDRAM uses an external clock signal to synchronize its data input
     and output.  It is capable of achieving very high data rates for
     linear access to memory.

segmentation violation

     A segmentation violation occurs when an attempt is made to access
     *note memory (2): 194. whose *note address: 126. is well-formed,
     but to which access cannot be granted.  This might be due to either
     a *note protection fault: 1d7. or an *note invalid page fault:
     16b4.

     The term is sometimes used more loosely as a synonym for any memory
     access error, including a *note bus error: 15c9.

     *note general protection fault: 1692, *note read fault: 16f0, *note
     write fault: 16f1.

segmented addressing

     In segmented addressing, *note addresses: 126. are in two parts: a
     segment identifier and an offset into that segment.

     Each segment has a base address and a limit.  If the offset is
     greater than the limit, the address is invalid (see *note
     segmentation violation: 1618.).  Otherwise, the offset is added to
     the segment’s base address, giving the unsegmented address.
     Segment identifiers may be implicit; for instance, they may be
     obtained from a 'current segment' register.

     Segmentation may be layered on top of *note virtual memory: 51, in
     which case the unsegmented address is a *note virtual address:
     16b9, or not, in which case it is a *note physical address: 15aa.

     Note that, in segmented architectures, you can have a
     two-dimensional *note address space: 54.

     Segments are a feature of some processor architectures and
     operating systems.  This description does not cover all possible
     variations on segmentation.

     Segment terminology may be used on unsegmented systems for
     historical reasons.  For instance, Unix processes have 'text
     segments', even when running on an unsegmented system.

     *note linear addressing: 16c7.

segregated allocation cache

     A mechanism for adding a *note segregated free list: 25c. to a
     *note manual: 8. *note pool class: 10.  See *note Segregated
     allocation caches: 25b.

segregated fit

     One of the *note segregated free list: 25c. class of *note
     allocation mechanisms: 15d4.  There is an array of *note free
     lists: 268, each holding *note free blocks: 15bf. of a particular
     range of sizes.  The *note allocator: 15ce. identifies the
     appropriate free list and allocates from it (often using a *note
     sequential fit: 15f1. mechanism such as *note first fit: 37f.).  If
     this fails, a larger block is taken from another list and split.

     The details of the mechanism depend on the division of sizes
     between free lists.  See *note exact segregated fit: 1675. and
     *note strict segregated fit: 1613.

     This implements a *note good fit: 15f5. *note allocation policy:
     380.

     See also
     ........

     *note allocation mechanism: 15d4, *note exact segregated fit: 1675,
     *note free list: 268, *note segregated free list: 25c, *note strict
     segregated fit: 1613.

     *note Wilson et al.  (1995): 157a.

segregated free list

segregated free-list

     A class of *note allocation mechanism: 15d4. which divides the
     *note free list: 268. into several subsets, according to the size
     of the *note free blocks: 15bf.  A *note freed: 15d2. or *note
     coalesced: 38c. block is placed on the appropriate list.  An
     allocation request is serviced from the appropriate list.

     This class of mechanism implements a *note good fit: 15f5. or *note
     best fit: 382. policy.

     Variations within this class include *note simple segregated
     storage: 171d, *note segregated fit: 15f3, and *note buddy systems:
     15f9.

     *note Wilson et al.  (1995): 157a.

     *note Segregated allocation caches: 1b2. are a general mechanism
     for adding a segregated free list to any manually managed pool.
     See *note Segregated allocation caches: 25b.

semi-conservative garbage collection

     'mostly-exact garbage collection', 'mostly-precise garbage
     collection'.

     A variant of *note conservative garbage collection: 349. which
     deals with *note exact references: 61. as well as *note ambiguous
     references: 9f.

     For example, references from the *note root set: 1716. might be
     ambiguous, but *note objects: 1ab. on the *note heap: 47. might be
     fully described and precisely *note scanned: 65.

     See also
     ........

     *note mostly-copying garbage collection: 1655.

     *note Bartlett (1988): 14f1.

semi-space

     When an area of *note memory (2): 194. is divided into two parts
     for the purposes of *note copying garbage collection: e3, the parts
     are known as 'semi-spaces', or sometimes just 'spaces'.

     Each semi-space is a contiguous area of memory.  Semi-spaces are
     usually used for *note two space collection: 1634, but can be used
     for *note generational collection: e.

     The semi-space where *note objects: 1ab. reside at the start of the
     collection is known as the *note fromspace: 1682.; the *note
     tospace: 1633. is where objects will reside, and where new objects
     will be *note allocated: 15ca, when the collection is complete.

     See also
     ........

     *note two-space collector: 1634.

semi-space collector

     *note two-space collector: 1634.

sequential fit

     A class of *note allocation mechanisms: 15d4. that maintain the
     *note free list: 268. as a single linear list of *note free blocks:
     15bf. (a *note free block chain: 15c0.).  Sequential fit mechanisms
     include *note first fit: 37f. and *note next fit: 1681.

     To quote *note Wilson et al.  (1995): 157a.:

          The list is often doubly-linked and/or circularly linked.
          Typically, sequential fit algorithms use Knuth’s boundary tag
          technique, and a doubly-linked list to make *note coalescing:
          38c. simple and fast.  […] In considering sequential fits, it
          is probably most important to keep strategy and policy issues
          in mind.  The classic linear-list implementations may not
          scale well to large *note heaps: 47, in terms of time costs;
          as the number of free blocks grows the time to search the list
          may become unacceptable.  More efficient and scalable
          techniques are available, using totally or partially ordered
          trees, or *note segregated fits: 15f3.

     See also
     ........

     *note bitmapped fit: 15ff, *note indexed fit: 15f4.

sequential store buffer

     'SSB'.

     A sequential store buffer is a technique for dividing the cost of a
     *note write barrier: 214. by remembering which *note objects: 1ab.
     are modified and updating *note remembered sets: 213. (and so on)
     at a later stage.

     This turns out to be extremely efficient on pipelined architectures
     with branch prediction.

shared memory

     *note Memory locations: 15b4. are 'shared' if they are in the range
     of multiple *note address spaces: 54.

simple object

     In the *note PostScript: 1645. language, 'simple objects' are the
     *note unboxed: 48. objects.

     Unlike a *note composite object: 1644, a simple object contains all
     its data in the object itself.

     *note unboxed: 48.

     *note composite object: 1644.

simple segregated storage

     A *note segregated free list: 25c. *note allocation mechanism:
     15d4. which divides *note memory (1): 15b0. into *note pages: 92.
     or other areas and only allocates *note objects: 1ab. of a single
     size, or small range of sizes, within each area.  This makes
     allocation fast and avoids *note headers: 1d1, but may lead to high
     *note external fragmentation: 383, as unused parts of areas cannot
     be reused for other object sizes.

     *note Wilson et al.  (1995): 157a.

size

     The term 'size' in the documentation always refers to a size that
     is measured in *note bytes (1): 17c.  The term 'count' is used for
     the number of elements in an array.

size class

     A *note segregated allocation cache: 1b2. maintains a reserve of
     free *note blocks: 185. in a set of *note sizes: 183.: each such
     size is known as a 'size class'.  When creating a segregated
     allocation cache by calling *note mps_sac_create(): 25e, the *note
     client program: d0. describes the desired set of size classes by
     passing an array of structures of type *note mps_sac_class_s: 25d.
     See *note Segregated allocation caches: 25b.

skip method

     A *note format method: 69. that returns the address of the “next
     object” in a block of *note formatted objects: 23.  See *note
     mps_fmt_skip_t: 82.

smart pointer

     A smart pointer is an instance of a *note C++: 1d. class that
     encapsulates a *note pointer: 15b8. and performs *note reference
     counting: 15e0.

     By overloading certain operators it is possible for the class to
     present the illusion of being a pointer, so that ‘operator*’,
     ‘operator->’, etc.  can be used as normal.  Reference counting
     allows the objects that are referred to using the smart pointer
     class to have their *note memory (1): 15b0. automatically *note
     reclaimed: 4a. when they are no longer *note referenced: 24.  It is
     a common technique used when trying to solve *note memory
     management: 15dd. problems in C++ applications.

     However, reference counting is not always an appropriate memory
     management technique and smart pointers can be hard to implement
     properly in C++.  A *note tracing garbage collector: 15df. might be
     worth considering.

     *note Edelson (1992a): 151c.

snap-out

     'transport snap-out'.

     In a *note copying collector: e3, when there is a *note reference:
     24. to an *note object: 1ab. that was *note condemned: 221, but has
     been *note transported: 1722, snap-out is the adjustment of that
     reference to point to the preserved copy.

     Typically the first transport leaves a *note forwarding pointer:
     87. that enables the snap-out.

 [image src="MemoryPoolSystem-figures/snap-out.svg" alt="Diagram: Snap-out." ]


     Figure: Snap-out.

     See also
     ........

     *note broken heart: 1611.

snapshot at the beginning

     Snapshot-at-the-beginning algorithms for *note tracing: 4b, *note
     incremental GC: d. note changes made by the *note mutator: 30c. to
     the *note graph: 1635. of *note objects: 1ab. and update the *note
     collector (2): 15ae. state to make it trace relevant *note edges:
     1671. that the mutator deletes.

     In order for the collector to miss a *note reachable: 96. *note
     object: 1ab, the following two conditions need to hold at some
     point during tracing:

       1. The mutator stores a *note reference: 24. to a *note white:
          1607. object into a *note black: 1604. object.

       2. All paths from any *note gray: 1606. objects to that white
          object are destroyed.

     Snapshot-at-the-beginning algorithms ensure the second condition
     cannot occur, by causing the collector to process any reference
     that the mutator overwrites and that might be part of such a path.

     They are so called because they keep track of references that
     existed at the beginning of the *note collection cycle: 1a2.  Note
     that this does not mean all modifications need to be seen by the
     collector, only those needed to complete tracing without missing a
     reachable object (see *note Pirinen (1998): 1555. for details), nor
     does it mean that it won’t trace some references created during the
     collection.

     This distinction between incremental update and snapshot at the
     beginning was first introduced for write-barrier algorithms, but it
     applies to any type of tracing algorithm.

     *note incremental update: 16ad.

     See also
     ........

     *note barrier (1): 60, *note tri-color marking: 1605, *note weak
     tri-color invariant: 1723.

     *note Wilson (1994): 1579, *note Pirinen (1998): 1555.

soft reference

     In *note Java: 167f. terminology, 'soft reference' is used to mean
     a *note reference: 24. encapsulated in a *note reference object:
     16fb. of class ‘SoftReference’.

     Soft references form one of three kinds of *note weak reference
     (1): c. in Java.  They are handy for building *note caches (3):
     162a. that are automatically flushed when memory is low.

     See also
     ........

     *note softly reachable: 16f8.

     Class java.lang.ref.SoftReference(1), Reference Objects and Garbage
     Collection(2).

softly reachable

     In *note Java: 167f, an object is 'softly reachable' if it is not
     *note strongly reachable: 16f7. and there is a path from the *note
     roots: 97. to it that contains at least one *note soft reference:
     1712. but no *note weak (2): 1713. or *note phantom references:
     16fa.

     When the Java *note collector (1): 15d7. determines that an object
     is softly reachable, it has the option of clearing the soft
     references involved, which will usually allow the object to be
     *note recycled: 15de.  The idea is that they will only be cleared
     if the process is running short of *note memory (2): 194.  If it is
     done, all soft references involved are cleared, so that the object
     is no longer softly reachable, and any affected *note reference
     objects: 16fb. which are registered with a queue are enqueued.

     See also
     ........

     *note phantom reachable: 16f5, *note reachability: 96, *note weakly
     reachable: 16f9.

     Class java.lang.ref.SoftReference(3), Reference Objects and Garbage
     Collection(4).

space leak

     *note memory leak: 234.

spare commit limit

     The spare commit limit is a limit on the *note spare committed
     memory: 18f. that the MPS will obtain from the operating system.
     It can be retrieved by calling *note mps_arena_spare(): 189. and
     changed by calling *note mps_arena_spare_set(): 198.

spare committed memory

     Memory which is not in use by any *note pool: 18. and not otherwise
     in use for internal MPS data structures, but which remains *note
     committed: 190. (mapped to *note RAM: 55. by the operating system).
     It is used by the *note arena: 16. to (attempt to) avoid calling
     the operating system to repeatedly map and unmap areas of *note
     virtual memory: 51. as the amount of memory in use goes up and
     down.  It is subject to the *note spare commit limit: 197.  The
     total spare committed memory can be retrieved by calling *note
     mps_arena_spare_committed(): 191.

spaghetti stack

     *note cactus stack: 162c.

splat

     To overwrite a *note weak reference (1): c. with a null pointer,
     when the MPS has determined that there are no remaining *note
     strong references: 244. to the block referred to.  See *note Weak
     references: 102.

split

     To divide a *note free block: 15bf. into two smaller free blocks in
     the process of satisfying an allocation request.

     Deciding when to split a block is an important aspect of an *note
     allocation policy: 380.

     *note coalesce: 38c.

     See also
     ........

     *note allocation policy: 380, *note coalesce: 38c, *note free
     block: 15bf.

SRAM

     *note static memory (1): 1623.

SSB

     *note sequential store buffer: 171f.

stack

     A stack is a LIFO (last in, first out) collection: *note objects:
     1ab. may be 'pushed' onto the stack, and 'popped' off it in reverse
     order of pushing.

     When people say “the stack”, they usually mean the *note control
     stack: 27. supported by the OS and/or the processor.

     *note Stack allocation: 15e2. is an important technique.  Control
     stacks are central to the performance of the system and often
     require special handling.

     The terms “stack”, “push”, and “pop” are taken from the
     spring-loaded dish stack found in cafeterias and salad bars where
     removing the top plate causes the others to rise up, exposing the
     next one, and adding a plate causes the spring to compress, leaving
     only that plate accessible.

     So originally, the latest item was the “top”, “down the stack”
     meant towards earlier items, and “up” towards later ones, but today
     many use “up” and “down” in the opposite sense.

     *note control stack: 27.

     See also
     ........

     *note cactus stack: 162c, *note data stack: 1654.

stack allocation

     'Stack allocation' means run-time *note allocation: 15ca. and *note
     deallocation: 15d2. of *note memory (1): 15b0. in last-in/first-out
     order.

     Typically, stack allocation is performed on top of the main *note
     stack: 15bc, but one can have a separate *note data stack: 1654.
     for this purpose as well, as in Forth, or even multiple ones, as in
     the *note PostScript: 1645. language.

     Allocation and deallocation are typically fast, since they can be
     done simply by adding or subtracting the size of the *note block:
     185. from the stack pointer.

     Using only stack allocation, without heap allocation, is somewhat
     restrictive, as only objects whose size is known at compile-time
     can be returned from a procedure.

     Some programming languages (such as some versions of *note Lisp:
     28a. and *note C: 1c.) provide program-controlled stack *note
     allocation: 15ca. and *note deallocation: 15d2. of dynamic extent
     objects for efficiency, despite its being unsafe.

     *note automatic storage duration: 15d0.

     *note heap allocation: 1653, *note static allocation: 1610.

     See also
     ........

     *note dynamic extent: 24a, *note region inference: 15e1.

stack frame

     'stack record'.

     A stack frame or record is an *note activation record: 15ac. that
     is stored on the *note stack: 15bc.

     In a register-based architecture, where the current activation
     record may be partially stored in registers, there may be hardware
     instructions that facilitate storing registers on the stack when
     another activation record is made current.  Such instructions may
     prescribe a particular layout for activation records.

     Hardware support for saving and restoring registers, for stacks and
     for stack addressing may limit or otherwise prescribe the size and
     type of data that can be stored in a stack frame.  Knowledge of the
     layout of each stack frame may assist a *note garbage collector:
     20. in finding *note roots: 97.

     *note activation record: 15ac.

     See also
     ........

     *note stack: 15bc.

stack record

     *note stack frame: 15b1.

static allocation

     'Static allocation' means *note allocation: 15ca. of *note memory
     (1): 15b0. before the program starts and retention until the end.

     The locations of *note objects: 1ab. are basically decided at
     compile-time, although they might be *note relocated: 160e. at
     load-time.  This implies the sizes of the objects must be known
     then.

     Using only static allocation is restrictive, as sizes of data
     structures can’t be dynamically varied, and procedures cannot be
     recursive.  However, it is also fast and eliminates the possibility
     of running out of memory.  For this reason, this scheme is
     sometimes used in real-time systems.

     *note static storage duration: 15e3.

     *note heap allocation: 1653, *note stack allocation: 15e2.

     See also
     ........

     *note region inference: 15e1, *note static memory (2): 1729.

static memory^(1)

     'SRAM', 'static RAM'.

     Static *note memory (2): 194. or static RAM (SRAM) is a type of
     *note physical memory (2): 15b6. that does not need to be refreshed
     periodically to avoid losing state.

     Static memory is typically faster than *note dynamic memory: 166a,
     or requires essentially no power to preserve its state, but rarely
     both.  These benefits result in static RAM being used for *note
     cache (1): 1622. memory, and also in portable, low-power
     applications (such as PDAs).  It is, however, more expensive than
     dynamic RAM and requires more transistors, making dynamic RAM the
     choice for large amounts of memory (the *note main memory: 311. of
     desktop machines, for example).

     *note dynamic memory: 166a.

static memory^(2)

     The *note memory (2): 194. where *note statically allocated: 1610.
     objects are stored is sometimes known as 'static memory'.  In the
     context of *note garbage collection: f, the term is used mean
     memory used to store *note static objects: 172a.

     See also
     ........

     *note static storage duration: 15e3.

static object

     A static *note object: 1ab. is non-*note moving: 5d.  That is, it
     is not *note relocated: 160e. by a *note memory manager: 15cd.; its
     *note address: 126. does not change.

static RAM

     *note static memory (1): 1623.

static storage duration

     In *note C: 1c. and *note C++: 1d, the ‘static’ keyword applied to
     a file scope variable or function means it is local to the file;
     the ‘static’ keyword applied to a function or a block scope
     variable means it is *note allocated: 15ca. and initialized once
     only.

     Objects declared locally in blocks with the ‘static’ keyword are
     *note allocated: 15ca. in *note static memory (2): 1729, and
     initialized once (usually by the compiler/linker) instead of each
     time the block is entered.

     Static variables within functions retain their value between
     function invocations, and therefore must form part of the *note
     root set: 1716. of any *note collector (1): 15d7.

     *note automatic storage duration: 15d0.

     See also
     ........

     *note lifetime: b5.

stepper function

     'visitor function'.

     A function that will be called on each element in a collection.
     For example, a stepper function of type *note mps_roots_stepper_t:
     21c. can be passed to *note mps_arena_roots_walk(): 19e. and it
     will be called on all *note roots: 97. in an *note arena: 16.

sticky reference count

     *note limited-field reference count: 16c5.

stop-and-copy collection

     *note Copying garbage collection: e3. that stops the *note mutator:
     30c. while the collector runs.

 [image src="MemoryPoolSystem-figures/two-space.svg" alt="Diagram: Two-space collector." ]


     Figure: Stop-and-copy in a *note two-space collector: 1634.

     *note incremental garbage collection: d, *note parallel garbage
     collection: 15ed.

storage

     *note memory (1): 15b0.

storage hierarchy

     'memory hierarchy'.

     A typical computer has several different 'levels' of *note storage:
     15b0.  Each level of storage has a different speed, cost, and size.
     The levels form a 'storage hierarchy', in which the topmost levels
     (those nearest the processor) are fastest, most expensive and
     smallest.

     Levels typically include processor *note registers: 26, possibly
     some levels of *note cache (1): 1622, *note main memory: 311, and
     possibly some levels of *note backing store: 15d1.

     Each level is commonly used as a *note cache (2): 1627. for the
     next level.  For instance, *note virtual memory: 51. systems use
     main memory as a cache for backing store.

 [image src="MemoryPoolSystem-figures/storage.svg" alt="Diagram: Storage hierarchy with (typical) relative cost, speed, and size." ]


     Figure: Storage hierarchy with (typical) relative cost, speed, and
     size.

storage level

     One level in a *note storage hierarchy: 1628, for instance a *note
     cache (1): 1622, *note main memory: 311, *note backing store: 15d1,
     and so on.

     See also
     ........

     *note storage hierarchy: 1628.

storage management

     *note memory management: 15dd.

store^(1)

     To transfer data from a processor’s *note registers: 26. to *note
     memory (2): 194.

     Store can also be used in the more general sense of transferring
     data from a part of the *note memory hierarchy: 16c8. that is fast
     to access to one that is slow to access.

     ‘STORE’ (or an abbreviation) is also commonly used in many
     processor architectures as the mnemonic for the machine code
     instructions that store data into memory.

     *note load: 15ea.

store^(2)

     *note memory (1): 15b0.

stretchy vector

     A *note vector: 15c7. that may grow or shrink to accommodate adding
     or removing elements.  Named after the ‘<stretchy-vector>’ abstract
     class in Dylan.

     In the presence of an *note asynchronous garbage collector: a1, the
     vector and its size may need to be updated atomically.

     Dylan Reference Manual: Collections(5).

     See *note The stretchy vector problem: be.

strict segregated fit

     A *note segregated fit: 15f3. *note allocation mechanism: 15d4.
     which has only one block size on each *note free list: 268.  A
     requested block size is rounded up to the next provided size, and
     the first block on that list is returned.  The sizes must be chosen
     so that any block of a larger size can be *note split: 1614. into a
     number of smaller sized blocks.  *note Buddy systems: 15f9. are a
     special case of strict segregated fit allocators.

     See also
     ........

     *note allocation mechanism: 15d4, *note buddy system: 15f9, *note
     segregated fit: 15f3, *note segregated free list: 25c.

     *note Wilson et al.  (1995): 157a.

strong reference

     In a *note tracing garbage collector: 15df, a strong reference is a
     *note reference: 24. that keeps the *note object: 1ab. it refers to
     *note alive: 78.

     A strong reference is the usual sort of reference: the term is
     usually used to draw a contrast with *note weak reference (1): c.

     *note weak reference (1): c.

     See also
     ........

     *note strong root: 1717.

strong root

     A strong root is a *note root: 97. such that all *note references:
     24. in it are *note strong references: 244.

     A strong root is the usual sort of root: the term is usually used
     to draw a contrast with *note weak root: 20d.

     *note weak root: 20d.

     Strong roots have *note rank: 9e. *note mps_rank_ambig(): 20a. or
     *note mps_rank_exact(): 9d.

strong tri-color invariant

strong tri-colour invariant

strong tricolor invariant

strong tricolour invariant

     The strong *note tri-color invariant: 1732. is the property of a
     *note reference: 24. *note graph: 1635. that there is no *note
     edge: 1671. from a *note black: 1604. *note node: 163e. to a *note
     white: 1607. node.

     By preserving this property throughout *note tri-color marking:
     1605, a *note tracing: 4b. algorithm can ensure that the *note
     collector (2): 15ae. will not miss reachable objects, even if the
     *note mutator: 30c. manipulates the graph during the collection.
     This invariant can also be used to ensure that a *note copying
     garbage collector: e3. doesn’t confuse the mutator.  Mutator
     actions might need to change the *note color: 163c. of the nodes
     affected in order to preserve the invariant.

     Algorithms using this invariant are *note incremental update: 16ad.
     algorithms.

     *note tri-color invariant: 1732.

     See also
     ........

     *note barrier (1): 60, *note weak tri-color invariant: 1723.

     *note Johnstone (1997): 381, *note Pirinen (1998): 1555.

strongly reachable

     In *note Java: 167f, an object is 'strongly reachable', if there is
     a path from the *note roots: 97. to it that contains only *note
     strong references: 244, that is, contains no *note reference
     objects: 16fb.

     See also
     ........

     *note phantom reachable: 16f5, *note reachability: 96, *note softly
     reachable: 16f8, *note weakly reachable: 16f9.

     Reference Objects and Garbage Collection(6).

suballocator

     A 'suballocator' is an *note allocator: 15ce. functioning on top of
     another allocator.

     Suballocators work by *note allocating: 15ca. large *note blocks:
     185. and *note splitting: 1614. them for use, or by *note
     recycling: 15de. blocks locally.

     Application programmers sometimes write their own suballocators
     when faced with an inefficient or inadequate *note memory manager:
     15cd.  Suballocators can take advantage of special knowledge of
     program behavior, but are less efficient in general than fixing the
     underlying allocator, mainly because *note memory management: 15dd.
     is a 'global' issue for an application, and a global strategy can
     make a big difference.  For example, different suballocators can
     interact catastrophically with each other and with the *note
     virtual memory: 51. system, causing the application’s memory
     requirements to grow unnecessarily due to *note fragmentation: 17e.

subgraph

     A subgraph S of a *note graph: 1635. G is a graph such that all the
     *note nodes: 163e. in S are also in G and all the *note edges:
     1671. in S are also in G; that is, it is a part of a graph.

superpage

     *note huge page: 16a1.

sure reference

     *note exact reference: 61.

swap space

     *note Backing store: 15d1. used by a *note swapping: 15e8. system.

     See also
     ........

     *note backing store: 15d1, *note swapping: 15e8.

swapped in

     A process or *note page: 92. is 'swapped in' if it is available in
     *note physical memory (1): 16b8.  This usually applies to the
     entire program image.

     *note paged in: 195.

     *note swapped out: 169b.

     See also
     ........

     *note swapping: 15e8.

swapped out

     A process or *note page: 92. is 'swapped out' if it is not
     available in *note physical memory (1): 16b8.  This usually applies
     to the entire program image.

     *note paged out: 16d1.

     *note swapped in: 16f3.

     See also
     ........

     *note swapping: 15e8.

swapping

     Historically, swapping was the technique of moving entire program
     images to disk (or drum) and back into *note physical memory (1):
     16b8, an early form of *note virtual memory: 51.  Nowadays, it is
     used as a synonym for *note paging: 15e7.

     *note paging: 15e7.

     See also
     ........

     *note swapped in: 16f3, *note swapped out: 169b.

sweeping

     Sweeping is the second phase (“the sweep phase”) of the *note
     mark-sweep: 15fd. algorithm.  It performs a sequential
     (address-order) pass over memory to *note recycle: 15de. unmarked
     blocks.

     Sweeping typically gathers all unmarked blocks into one or more
     *note free lists: 268.

     See also
     ........

     *note marking: 1600.

synchronous garbage collector

     A *note collector (2): 15ae. is asynchronous with respect to the
     *note mutator: 30c. if it runs at predictable times, for example
     only when a collection function is called.

     This means that mutator need not ensure that *note formatted
     objects: 23. are always *note scannable: 65, as long as it makes
     them scannable before the collector runs.

     *note asynchronous garbage collector: a1.

   ---------- Footnotes ----------

   (1) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html

   (2) http://pawlan.com/monica/articles/refobjs/

   (3) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html

   (4) http://pawlan.com/monica/articles/refobjs/

   (5) http://opendylan.org/books/drm/Collection_Classes

   (6) http://pawlan.com/monica/articles/refobjs/


File: MemoryPoolSystem.info,  Node: Memory Management Glossary T,  Next: Memory Management Glossary U,  Prev: Memory Management Glossary S,  Up: Memory Management Glossary

7.19 Memory Management Glossary: T
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

tabling

     *note caching (3): 162a.

tag

     A tag is a piece of information associated with an *note object:
     1ab. or *note reference: 24. that allows the representation of the
     object to be determined.

     Tags are often used to represent types in the implementation of a
     dynamically-typed language.  In statically-typed languages, types
     are usually implicit and not permitted to change at run-time, so
     tagging is rarely required.

     One of the simplest forms of tag is a *note word: 37c. at the
     beginning of the object that points to a block of information about
     the object’s *note format: 164e.

 [image src="MemoryPoolSystem-figures/tag-word.svg" alt="Diagram: Example of a tag-word at the start of an object." ]


     Figure: Example of a tag-word at the start of an object.

     Another common form of tagging is to *note align: 68. objects and
     keep information in the least significant bits of the reference.

 [image src="MemoryPoolSystem-figures/tag-ref.svg" alt="Diagram: Example of reference tagging, using the least significant bits." ]


     Figure: Example of reference tagging, with objects aligned to
     addresses that are multiples of four, and the tag stored in the
     least significant two bits of the reference.

     In *note C: 1c, when a structure contains a union, it is common to
     add a field to the structure to indicate which union member is
     currently being used.  This field is known as a 'discriminator',
     and is a form of tag.  Analogues occur in other languages,
     sometimes with compiler or run-time support.

     See also
     ........

     *note in-band header: 1d1, *note tagged architecture: 1658.

     *note Gudeman (1993): 1527.

     See *note Tagged references: 7e.

tagged architecture

     A tagged architecture is a hardware architecture where each memory
     *note word: 37c. is divided into a “data” and a *note tag: 88.
     section.  The data section is sufficiently large to contain a
     memory *note address: 126. and the tag section is used to describe
     how the data section is to be interpreted (that is, it encodes the
     type of the data).

     Tagged architectures greatly simplify the implementation of a
     memory manager because each word of memory is self-describing.

     The *note Lisp Machine: 16bb. was an example of a tagged
     architecture.

tagged reference

     A *note reference: 24. containing a *note tag: 88. in part of its
     address, for example by *note aligning: 68. objects and keeping the
     tag in the least significant bits of the address.

     See *note Tagged references: 7e.

TB^(1)

     *note terabyte: 161a.

TB^(2)

     *note translation lookaside buffer: 15be.

telemetry filter

     A *note bitmap: 298. indicating which events the MPS should include
     in the *note telemetry stream: ba.  It can be read by calling *note
     mps_telemetry_get(): 2b3. or changed by calling *note
     mps_telemetry_set(): 176. or *note mps_telemetry_reset(): 2b4.

telemetry label

     An identifier representing a string, returned from *note
     mps_telemetry_intern(): 296, that can be associated with certain
     *note addresses: 126, and so appear in the *note telemetry stream:
     ba. attached to events concerning those addresses.  See *note
     Telemetry: db.

telemetry stream

     A sequence of events reported by the MPS to assist with debugging
     and profiling.  The events that appear in the stream can be
     configured by setting the *note telemetry filter: 295.  See *note
     Telemetry: db.

telemetry system

     The subsystem of the MPS that outputs the *note telemetry stream:
     ba.  See *note Telemetry: db.

tenuring

     *note promotion: 223.

terabyte

     'TB'.

     A terabyte is 1024 *note gigabytes: 1619, or 1099511627776 *note
     bytes (1): 17c.

     See *note byte (1): 17c. for general information on this and
     related quantities.

termination

     *note finalization: b.

thrash

     A *note cache (2): 1627. is said to *note thrash: 16de. when its
     *note miss rate: 16a0. is too high, and it spends most of its time
     servicing *note misses: 169e.  Thrashing is bad for performance,
     particularly *note virtual memory: 51. thrashing, because the
     relative cost of a miss is so high: it may slow a machine down by a
     factor of a hundred or more.

     Thrashing is typically caused by a process or system having a *note
     working set: 16ba. which is larger than its *note cache (1): 1622.
     or *note main memory: 311.  It may also be caused by a failure of
     *note cache policy: 1625.  A system with an inflexible cache policy
     may thrash even when the working set is quite small.

     For instance, a virtual memory system which has four megabytes of
     *note physical memory (1): 16b8. but which has a working set of ten
     megabytes will *note thrash: 16de. badly.

     *note Denning (1968): 150f, *note Denning (1970): 1510, *note
     Denning & Schwartz (1972): 1511.

thread

     A thread of execution is a sequence of instructions that take place
     sequentially.  In a multi-threaded program, multiple threads of
     execution operate in parallel, and are generally asynchronous with
     respect to each other.

     Access to shared resources such as memory management interface must
     be thread-safe.  Each thread has its own *note control stack: 27.
     which may contain *note references: 24. to blocks on the heap.

     Threads are represented by values of type *note mps_thr_t: 201,
     created by calling *note mps_thread_reg(): a8.  In order for the
     MPS to find references on the control stack of the thread, the
     thread must be also be registered as a *note root: 97. by calling
     *note mps_root_create_thread(): a9.  See *note Threads: 29.

threatened set

     *note condemned set: 221.

TLB

     *note translation lookaside buffer: 15be.

to space

tospace

     'new space', 'newspace'.

     In *note copying garbage collection: e3, the space to which *note
     live: 78. object are copied.

     *note fromspace: 1682.

trace

     In *note tracing garbage collection: 15df, tracing is the process
     of following the *note graph: 1635. from all *note roots: 97. to
     all *note reachable: 96. data.

     *note scan: 65.

tracing garbage collection

     Tracing garbage collection is *note garbage collection: f. based on
     *note reachability: 96.

     Tracing garbage collection relies on the fact that if an *note
     object: 1ab. is not *note reachable: 96, there is no way the *note
     mutator: 30c. could ever access it, and therefore it cannot be
     *note live: 78.  In each *note collection cycle: 1a2, some or all
     of the objects are *note condemned: 221. and the *note graph: 1635.
     is *note traced: 4b. to find which of the condemned objects are
     reachable.  Those that were not reachable may be *note reclaimed:
     4a.

transform

     A mapping from old *note references: 24. to new references,
     represented by *note mps_transform_t: 2c2, that can be applied to
     all references managed by the MPS. See *note Transforms: 2be.

translation buffer

translation lookaside buffer

     'address translation cache', 'ATC', 'TB'.

     The 'translation lookaside buffer' or 'address translation cache'
     is small piece of associative *note memory (1): 15b0. within a
     processor which caches part of the translation from *note virtual
     addresses: 16b9. to *note physical addresses: 15aa.

     In a *note virtual memory: 51. system there is a translation from
     *note virtual addresses: 16b9. to *note physical addresses: 15aa.
     This translation can often be very large and complex and the data
     structures that implement the translation (often a *note page
     table: 16a2.) can be too large to store efficiently on the
     processor.  Instead, a few elements of the translation are stored
     in the TLB; the processor can access the TLB extremely quickly.  If
     a required translation for a particular virtual address is not
     present in the TLB then 'a TLB miss' is taken and the address is
     resolved using the more general mechanism.

transparent alias

transparent type

     In the MPS interface, a 'transparent type' is an alias defined
     using ‘typedef’, and this is documented so that the *note client
     program: d0. can rely on that fact.  For example, *note mps_addr_t:
     11d. is a transparent alias for ‘void *’.  See *note Interface
     conventions: 112.

     *note opaque type: 16ec.

transport

     In a *note copying collector: e3, transporting is preventing an
     *note object: 1ab. in the *note condemned set: 221. from being
     collected by copying it and adjusting the *note reference: 24. by
     which it was discovered to point to the new copy.

     See also
     ........

     *note scavenging: e3, *note snap-out: 1721.

transport snap-out

     *note snap-out: 1721.

treadmill

     Henry Baker devised an *note incremental: d. non-*note moving: 5d.
     *note garbage collector: 20. that uses a circular doubly-linked
     list, called the 'treadmill', to implement *note tri-color marking:
     1605.

     Every *note object: 1ab. is on the list.  The list has four
     sections corresponding to *note colors: 163c.  The *note black:
     1604, *note gray: 1606. and *note white: 1607. sections are used
     for tri-color marking, and an additional *note off-white: 1640.
     section is used for *note free (3): 15d6. objects.  The color of an
     object is changed by unlinking it from the list and relinking it to
     a different part of the list.

 [image src="MemoryPoolSystem-figures/treadmill.svg" alt="Diagram: A treadmill." ]


     Figure: A treadmill.  (Based on *note Jones (2012): 1538.)

     *note Baker (1992c): 14e5.

tri-color invariant

tri-colour invariant

tricolor invariant

tricolour invariant

     The term “tri-color invariant” is used to refer to any of a number
     of properties of a *note reference: 24. *note graph: 1635. that are
     preserved throughout a *note tri-color marking: 1605. algorithm to
     ensure the correctness.

     There are two important ones: the *note strong tri-color invariant:
     16af. and the *note weak tri-color invariant: 1723.  When people
     say “the tri-color invariant” they probably mean the strong one.

     *note Johnstone (1997): 381, *note Pirinen (1998): 1555.

tri-color marking

tri-colour marking

tricolor marking

tricolour marking

     Tri-color marking is a *note tracing garbage collection: 15df.
     algorithm that assigns a *note color: 163c. (*note black: 1604,
     *note white: 1607, or *note gray: 1606.) to each *note node: 163e.
     in the *note graph: 1635.  It is basic to *note incremental garbage
     collection: d.

     Initially all nodes are colored white.  The distinguished *note
     root set: 1716. is colored gray.  The *note collector (2): 15ae.
     proceeds to discover the *note reachable: 96. nodes by finding an
     *note edge: 1671. from a gray node to a white node and coloring the
     white node gray.  Hence each tracing step involves choosing a gray
     node and graying its white children.

     When all the edges from a gray node lead only to other gray (or
     black) nodes, the node is colored black.  When no gray nodes
     remain, the reachable part of the graph has been discovered and any
     nodes that are still white may be *note recycled: 15de.

     The *note mutator: 30c. is free to access any part of the graph and
     allocate new nodes while the *note collector (2): 15ae. is
     determining the reachable nodes, provided the *note tri-color
     invariant: 1732. is maintained, by changing the colors of the nodes
     affected, if necessary.

     “Tri-color marking” is the term used to describe an algorithm
     developed in 1975 by E. W. Dijkstra and others, as an exercise in
     proving cooperating programs correct.  They chose as their problem
     a *note parallel garbage collector: 15ed, with the intent of
     illustrating cooperating sequential processes with a large shared
     data space but minimal exclusion and synchronization constraints.

     Although the algorithm developed in the paper is not necessarily
     the most efficient algorithm for a *note collector (1): 15d7, it
     has been generally accepted to be correct: an important feature
     that not all garbage collectors can claim.  A number of other
     garbage collection algorithms have been shown to be isomorphic to
     the tri-color marking algorithm and thus are also believed to be
     correct.

     See also
     ........

     *note barrier (1): 60.

     *note Dijkstra et al.  (1976): 1515.

two-space collector

two space collector

     'semi-space collector'.

     A two-space *note collector (1): 15d7. is a simple form of a *note
     copying garbage collector: e3.  The available *note memory (2):
     194. is divided into two halves, called *note semi-spaces: 1612.
     *note Objects: 1ab. are allocated in one semi-space until it is
     full.  The *note reachable: 96. objects are then copied into the
     other semi-space (usually using a *note Cheney scan: 1636.) and the
     old semi-space is *note reclaimed: 4a.  *note Allocation: 15ca.
     continues in the new semi-space until it is full, at which point
     the process is repeated in reverse.

     The main disadvantage of a two-space collector is that it only
     makes use of half of the available memory.  This can be tolerable
     in a *note virtual memory: 51. system if the *note garbage
     collector: 20. is written carefully to preserve *note locality of
     reference: 1601.  Other forms of copying garbage collector, such as
     *note generational garbage collectors: e, have much lower
     overheads.

 [image src="MemoryPoolSystem-figures/two-space.svg" alt="Diagram: Two-space collector." ]


     Figure: Two-space collector.

     See also
     ........

     *note flip: 18c.

type-accurate garbage collection

     *note exact garbage collection: 164f.

type punning

     Interpreting a value of one type as if it were a value of another
     (for example, via a type cast in *note C: 1c.), especially if such
     interpretation is not defined by the language standard.  For
     example, interpreting a value of type ‘T**’ (pointer to pointer to
     ‘T’) as ‘U**’ is undefined.

     See *note Interface conventions: 112.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary U,  Next: Memory Management Glossary V,  Prev: Memory Management Glossary T,  Up: Memory Management Glossary

7.20 Memory Management Glossary: U
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

unaligned

     'misaligned'.

     An *note address: 126. is unaligned or misaligned if it does not
     comply with some *note alignment: 68. constraint on it.

     For example, typically double precision floating point numbers
     occupy 8 *note byte (1): 17c. and have an alignment of 4 bytes;
     that is, their address must be a multiple of four.  If a program
     tries to access such a number using an address that is not a
     multiple of four, a *note bus error: 15c9. may result, depending on
     the processor architecture and instruction used.

     *note aligned: 68.

     See also
     ........

     *note alignment: 68, *note bus error: 15c9.

unboxed

     Unboxed *note objects: 1ab. are represented by an encoding of the
     data itself, and not by a *note pointer: 15b8. to that data.

     Representations are typically chosen so that unboxed values are the
     same size as the pointer part of a *note boxed: 160b. object.
     Sometimes the value is *note tagged: 88. to distinguish it from a
     boxed object.  The entire object is duplicated when the object is
     passed around, so updates to it, if allowed, only affect one copy.

     *note immediate data: 16a5.

     *note boxed: 160b.

     *note Gudeman (1993): 1527.

unclamped state

     One of the four states an *note arena: 16. can be in (the others
     being the *note clamped state: 19f, the *note parked state: b8. and
     the *note postmortem state: d5.).  In the unclamped state, object
     motion and other background activity may occur.  Call *note
     mps_arena_release(): cf. to put an arena into the unclamped state.

undead

     An undead object is an *note object: 1ab. that cannot be proven to
     be *note dead: 49. by the *note garbage collector: 20, but whose
     *note liveness: 78. is dubious.

     For example, an *note ambiguous reference: 9f. to an object on a
     *note page: 92. may mark the entire page as *note reachable: 96.
     No further data is collected about that page.  The other objects on
     the page will survive, even though their reachability has not been
     determined.  They are 'undead'.

unmapped

     'free'.

     A range of *note virtual addresses: 16b9. is said to be 'unmapped'
     ('free' on Windows) if there is no *note physical memory (2): 15b6.
     associated with the range.

     An unmapped range may or may not be *note reserved: 16d2.

     *note mapped: 190.

unprotected

     A region of *note memory (2): 194. is said to be unprotected if
     there are no *note barriers (1): 60. on that region.

     *note protected: d4.

unreachable

     An *note object: 1ab. is unreachable if there is no *note
     reference: 24. chain to it from any *note root: 97.

     An object will become unreachable when the *note mutator: 30c.
     overwrites its last (direct or indirect) reference to the object.

     *note dead: 49.

     *note live: 78, *note reachable: 96.

     See also
     ........

     *note garbage collection: f.

unsure reference

     *note ambiguous reference: 9f.

unwrapped

     'raw'.

     A value is 'unwrapped' or 'raw' if it is not encoded with type
     information.

     In a dynamically-typed language, the compiler may sometimes be able
     to pick a more compact or efficient representation for a value if
     it can prove that the type can be determined at compile-time.  This
     is a particularly useful optimization for numeric values such as
     integers or floats.

     *note wrapped: 174e.

     See also
     ........

     *note boxed: 160b, *note tag: 88, *note value object: 16a6.

     *note Gudeman (1993): 1527.

use after free

     *note premature free: 165c.


File: MemoryPoolSystem.info,  Node: Memory Management Glossary V,  Next: Memory Management Glossary W,  Prev: Memory Management Glossary U,  Up: Memory Management Glossary

7.21 Memory Management Glossary: V
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

value object

     'immutable object'.

     A 'value object' or 'immutable object' is an *note object: 1ab.
     whose identity depends solely upon its value or magnitude.

     In a typed language, the compiler can often determine at compile
     time that certain types can be represented as value objects.
     Usually these types are a *note scalar data type: 15c6. with
     bounded magnitude.

     If value objects can be identified, the compiler and the memory
     manager can make certain optimizations: Value objects can be
     represented as *note immediate data: 16a5. to minimize storage
     overhead, they can be replicated to improve *note locality: 1601,
     and a *note vector data type: 15c7. of value objects can be
     represented as a *note leaf object: 107.

     Some programming languages expose representational details such as
     the use of value objects.  In *note Lisp: 28a, for example, numbers
     are often represented as value objects but not always as immediate
     data.  The ‘EQ’ predicate of Lisp tests if two objects have the
     same representation, whereas the ‘EQL’ predicate tests if two
     objects represent the same type and value (are computationally
     identical).  Because the choice of representation is an
     optimization, exposing it at the language level can cause programs
     to behave differently under different compilers or optimization
     settings.  Modern languages, such as *note Dylan: 1752. hide this
     representational distinction, permitting the compiler greater
     freedom in optimization.

     *note immediate data: 16a5.

     See also
     ........

     *note immutable: 16a7.

     *note Baker (1993a): 14e9.

variety

     A behaviour of the MPS that must be selected at compilation time.
     There are three varieties: *note cool: c8, *note hot: 162. and
     *note rash: 163.  See *note Varieties: 170.

vector data type

     A vector data type is an aggregate type whose elements belong to
     the same type and are indexed by integers or tuples of integers.

     Examples of vector data types include strings and arrays.

     Vector data types are seldom represented using *note value objects:
     16a6, but may be represented using *note leaf objects: 107. if they
     are an aggregate of a type that can be represented by *note value
     objects: 16a6.  *note Scanning: 65. information for vectors can be
     compactly encoded in terms of the aggregated type and the vector
     size.

     See also
     ........

     *note algebraic data type: 15c5, *note scalar data type: 15c6,
     *note leaf object: 107, *note value object: 16a6.

virtual address

     'logical address'.

     In a *note virtual memory: 51. system, the *note addresses: 126.
     that application programs deal with are known as 'virtual
     addresses'.

     The virtual addresses used by the application program are
     translated by the virtual memory system (often using *note
     translation lookaside buffers: 15be. and *note page tables: 16a2.)
     to *note physical addresses: 15aa.  It is the physical address that
     is used to retrieve the contents from the *note memory (3): 17.

     *note physical address: 15aa.

virtual address space

     The virtual *note address space: 54. is the space of *note virtual
     addresses: 16b9.

     On *note virtual memory: 51. systems, user processes see the
     virtual address space, and commonly have a separate virtual address
     space each, so that they map the same addresses to different data.
     These systems often have *note shared memory: 1720. as well.

     *note physical address space: 15ba.

virtual memory

     'VM'.

     In a 'virtual memory' ('VM') system, the program code deals with
     *note virtual addresses: 16b9.  Upon use, the virtual address is
     translated by the *note MMU: 16db. to obtain a *note physical
     address: 15aa. that is used to access *note physical memory (1):
     16b8.

     Some operating systems can simulate having more *note memory (2):
     194. than is available as *note main memory: 311, by storing part
     of the data in *note backing store: 15d1, typically on disk.  If
     the *note page: 92. referenced by the virtual address is not
     currently in main memory, a *note page fault: 16b5. occurs,
     triggering an operating system handler that *note swaps in: 16f3.
     the page.  Some other page might be *note swapped out: 169b. to
     make room.

     Each process typically has its own separate *note virtual address
     space: 15bb. with its own *note mappings: 310. and *note
     protections: 1fd.

 [image src="MemoryPoolSystem-figures/virtual-memory.svg" alt="Diagram: Example of the relationship between the virtual address spaces of two processes, physical memory, and backing store." ]


     Figure: Example of the relationship between the virtual address
     spaces of two processes, physical memory, and backing store.

     Virtual memory technology can be used in many useful memory
     management techniques, such as *note barriers (1): 60,
     copy-on-write, and *note memory mapping: 15b7.

          “Virtual” means never knowing where your next byte is coming
          from.  — ‘fortune(6)’

     *note real memory (1): 16d7.

     See also
     ........

     *note mapped: 190, *note paging: 15e7, *note paged in: 195, *note
     paged out: 16d1, *note reserved: 16d2, *note shared memory: 1720,
     *note swapping: 15e8, *note swap space: 15e9, *note unmapped: 1685.

virtual memory arena

     An *note arena class: 11a. which gets its *note memory (2): 194.
     from the operating system’s *note virtual memory: 51. interface.
     See *note Virtual memory arenas: 179.

visitor function

     *note stepper function: 21d.

VM^(1)

     *note virtual memory: 51.

VM^(2)

     In the *note PostScript: 1645. language, 'VM' is the *note memory
     (1): 15b0. where the values of the *note composite objects: 1644.
     reside.

     VM is short for “virtual memory”, but this has nothing to do with
     the usual sense of the phrase (see *note virtual memory: 51.).


File: MemoryPoolSystem.info,  Node: Memory Management Glossary W,  Next: Memory Management Glossary Z,  Prev: Memory Management Glossary V,  Up: Memory Management Glossary

7.22 Memory Management Glossary: W
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

weak-key hash table

     A hash table which has *note weak references (1): c. to its keys.
     If the key dies, the value for that key is automatically deleted
     from the table too.  It can be used to store extra information
     about objects without keeping them alive.

     *note doubly weak hash table: fd, *note weak-value hash table: fc.

     See *note AWL (Automatic Weak Linked): fe.

weak-value hash table

     A hash table which has *note weak references (1): c. to its value.
     If the value dies, any keys that refer to that value are
     automatically deleted from the table too.  It can be used to index
     a set of objects without keeping them alive.

     *note doubly weak hash table: fd, *note weak-key hash table: fb.

     See *note AWL (Automatic Weak Linked): fe.

weak hash table

     A *note weak-key: fb. or *note weak-value hash table: fc. (usually
     the former).

weak reference^(1)

     In *note tracing garbage collection: 15df, a weak reference is a
     *note reference: 24. that does not keep the *note object: 1ab. it
     refers to *note alive: 78.

     A weak reference does not keep the referent alive, but it will
     continue to refer to the object as long as it remains otherwise
     alive.  When only weak references to the object remain, the weak
     references can be deleted (“splatted” or “cleared”) and the object
     *note reclaimed: 4a.

     *note Java: 167f. offers three kinds of weak references, called
     *note soft references: 1712, *note weak references (2): 1713, and
     *note phantom references: 16fa, in order of increasing weakness.

     *note strong reference: 244.

     See also
     ........

     *note weak root: 20d.

weak reference^(2)

     In *note Java: 167f. terminology, 'weak reference' is used to mean
     a *note reference: 24. encapsulated in a *note reference object:
     16fb. of class ‘WeakReference’.

     Weak references form one of three kinds of *note weak reference
     (1): c. in Java.  They are handy for associating extra data with
     objects when you cannot store it in the objects themselves.

     See also
     ........

     *note weakly reachable: 16f9.

     Class java.lang.ref.WeakReference(1), Reference Objects and Garbage
     Collection(2).

weak root

     A weak root is a *note root: 97, such that all *note references:
     24. in it are *note weak references (1): c.; that is, they do not
     affect the *note liveness: 78. of the *note objects: 1ab. referred
     to.

     *note strong root: 1717.

     A weak root has *note rank: 9e. *note mps_rank_weak(): 20c.

weak tri-color invariant

weak tri-colour invariant

weak tricolor invariant

weak tricolour invariant

     The weak *note tri-color invariant: 1732. is the property of a
     *note reference: 24. *note graph: 1635. that all *note white: 1607.
     *note nodes: 163e. pointed to by a *note black: 1604. node are also
     *note reachable: 96. from some *note gray: 1606. node through a
     chain of white nodes.

     By preserving this property throughout *note tri-color marking:
     1605, a *note tracing: 4b. algorithm can ensure that the *note
     collector (2): 15ae. will not miss reachable objects, even if the
     *note mutator: 30c. manipulates the graph during the collection.
     Mutator actions might need to change the *note color: 163c. of the
     nodes affected in order to preserve the invariant.

     Algorithms using this invariant are *note
     snapshot-at-the-beginning: 16ae. algorithms.

     See also
     ........

     *note barrier (1): 60, *note strong tri-color invariant: 16af.

     *note Johnstone (1997): 381, *note Pirinen (1998): 1555.

weakly reachable

     In *note Java: 167f, an object is 'weakly reachable' if it is
     neither *note strongly: 16f7. nor *note softly reachable: 16f8. and
     there is a path from the *note roots: 97. to it that contains at
     least one *note weak reference (2): 1713. but no *note phantom
     references: 16fa.

     When the Java *note collector (1): 15d7. determines that an object
     is weakly reachable, it clears all the weak references involved,
     and declares the object *note finalizable: b.  (Operationally,
     finalization works as if it was implemented by a class of “final
     references” that stand between weak and phantom references.)  Also,
     the *note reference objects: 16fb. containing the weak references
     are enqueued, if they were registered with a queue.

     See also
     ........

     *note phantom reachable: 16f5, *note reachability: 96.

     Class java.lang.ref.WeakReference(3), Reference Objects and Garbage
     Collection(4).

weighted buddies

     A *note buddy system: 15f9. *note allocation mechanism: 15d4. using
     two series of size classes: *note binary buddies: 15f8. (2, 4, 8,
     …) and three-times-power-of-two (3, 6, 12, …).  A block that is in
     the latter series may be *note split: 1614. in two different ways.
     Thus a block of size 12 may be split into two blocks of size 6 or
     one block of size 4 and one block of size 8.  The same applies for
     *note coalescing: 38c.  This gives this system more flexibility
     than a regular buddy system.

     See also
     ........

     *note allocation mechanism: 15d4, *note binary buddies: 15f8, *note
     buddy system: 15f9.

     *note Wilson et al.  (1995): 157a.

weighted reference counting

     A technique for *note reference counting: 15e0. which is in common
     use for *note distributed garbage collection: 1663. because of the
     low level of inter-process communication it requires.

     Inter-process *note references: 24. to *note objects: 1ab. are
     counted, but instead of simply counting the number of references,
     each reference is given a weight.  When an object is created, the
     initial pointer to it is assigned a weight, which is usually a
     power of 2 for easy division.  The object records the sum of all
     the weights of all of its references.  Whenever a reference is
     copied, its weight is divided equally between the new and original
     copies.  Since this operation preserves the weighted reference sum,
     there is no need for communication with the object at this time.
     When a reference is deleted, the weighted reference sum is
     decremented by the weight of the reference.  This is communicated
     to the object by sending it a message.  When the object detects
     that the weighted reference sum has dropped to zero, it may be
     *note reclaimed: 4a.  The algorithm is tolerant of communication
     protocols which don’t guarantee order of arrival of deletion
     messages.

white

     In a *note tri-color marking: 1605. scheme, white *note objects:
     1ab. are objects that were *note condemned: 221. at the beginning
     of the *note collection cycle: 1a2. and have not been shown to be
     *note reachable: 96.  When *note tracing: 4b. is complete, white
     objects will be subject to *note reclamation: 4a.

     *note black: 1604, *note gray: 1606.

word

     'machine word'.

     Almost all processor architectures have a characteristic data size
     that is handled most efficiently.  This is known as the 'word
     size', and data of that size are known as 'words'.  The word size
     is usually a power of two multiple of *note bytes (2): 15c8.

     Often the platform’s word size is used to characterize the
     architecture by quoting the number of bits in it.  For example, a
     32-bit platform has a word size of four bytes and a 64-bit platform
     has eight-byte words (assuming 8-bit bytes).  Typically, *note
     pointers: 15b8. are the size of a word, and traditionally this
     determined the word size.  Nowadays, word size is usually driven by
     the need for more accuracy and range in mathematical calculations.

     In the past, the convenience of dealing with powers of two was not
     as significant, and word sizes such as 36- or 72-bits were not
     unknown.

     See also
     ........

     *note alignment: 68, *note grain: 1695.

working set

     The working set of a program or system is that *note memory (2):
     194. or set of *note addresses: 126. which it will use in the near
     future.

     This term is generally used when discussing *note miss rates: 16a0.
     at some *note storage level: 1626.; the time scale of “near future”
     depends upon the cost of a *note miss: 169e.  The working set
     should fit in the storage level; otherwise the system may *note
     thrash: 16de.

     See also
     ........

     *note cache (2): 1627, *note resident set: 1715, *note storage
     hierarchy: 1628.

     *note Denning & Schwartz (1972): 1511.

worst fit

     The *note allocation policy: 380. that always allocates from the
     largest *note free block: 15bf.  Commonly implemented using a
     size-ordered *note free block chain: 15c0. (largest first).

     In practice, this tends to work quite badly because it eliminates
     all large blocks, so large requests cannot be met.

     See also
     ........

     *note allocation policy: 380, *note best fit: 382, *note first fit:
     37f.

     *note Wilson et al.  (1995): 157a.

wrapped

     A value is wrapped if it is encoded with type information.

     *note unwrapped: 170e.

     See also
     ........

     *note boxed: 160b, *note tag: 88, *note wrapper: 175a.

     *note Gudeman (1993): 1527.

wrapper

     A wrapper is that part of a *note wrapped: 174e. representation
     that is copied when the value is passed by value.

     The wrapper does not include parts of the representation that are
     accessed indirectly, and are not copied when the value is passed.

     For instance, a *note Lisp: 28a. implementation might use the top
     two bits of a value representation as a *note tag: 88. to
     distinguish between integers and *note cons (1): 15cf. cells,
     setting these bits to 01 for a *note pointer: 15b8. to a cons cell
     and 11 for an integer.  Then the wrapped value of the number 4
     would have binary representation 11000…00100, and the wrapper for
     this number is the whole of this wrapped value.  The pointer to a
     cons cell stored at location 4 would have binary representation
     01000…00100.  The wrapped value of the cons cell is the combination
     of this pointer and the cons cell in memory itself.  The wrapper of
     the cons cell is just the pointer; when the cons cell is passed as
     a function argument, just the pointer is passed.

     See also
     ........

     *note boxed: 160b, *note wrapped: 174e.

     *note Gudeman (1993): 1527.

write barrier

     A write *note barrier (1): 60. is a block on writing to certain
     *note memory (2): 194. *note locations: 15b4. by certain threads or
     processes.

     Write barriers are used for *note incremental: d. or *note
     concurrent: 15ed. *note garbage collection: f.  They are also used
     to maintain *note remembered sets: 213. for *note generational: e.
     *note collectors (1): 20.

     See also
     ........

     *note read barrier: 1d6.

write fault

     An exception which occurs when writing to an address in *note
     virtual memory: 51.

     This is probably either a *note page fault: 16b5, an *note invalid
     page fault: 16b4. or a *note protection fault: 1d7.

     *note segmentation violation: 1618.

     See also
     ........

     *note read fault: 16f0.

   ---------- Footnotes ----------

   (1) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html

   (2) http://pawlan.com/monica/articles/refobjs/

   (3) 
http://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html

   (4) http://pawlan.com/monica/articles/refobjs/


File: MemoryPoolSystem.info,  Node: Memory Management Glossary Z,  Next: All,  Prev: Memory Management Glossary W,  Up: Memory Management Glossary

7.23 Memory Management Glossary: Z
==================================

*note A: 1590. | *note B: 1591. | *note C: 1592. | *note D: 1593. |
*note E: 1594. | *note F: 1595. | *note G: 1596. | *note H: 1597. |
*note I: 1598. | J | *note K: 1599. | *note L: 159a. | *note M: 159b. |
*note N: 159c. | *note O: 159d. | *note P: 159e. | *note Q: 159f. |
*note R: 15a0. | *note S: 15a1. | *note T: 15a2. | *note U: 15a3. |
*note V: 15a4. | *note W: 15a5. | X | Y | *note Z: 15a6.

ZCT

     *note zero count table: 1660.

zero count table

     'ZCT'.

     A 'zero count table' is used in *note deferred reference counting:
     165f. to record *note objects: 1ab. whose *note reference counts:
     15e0. have dropped to zero but which have not been processed to see
     if they can be *note reclaimed: 4a.


File: MemoryPoolSystem.info,  Node: All,  Prev: Memory Management Glossary Z,  Up: Memory Management Glossary

7.24 All
========

*note absolute address: 15aa,  *note activation frame: 15ac,  *note
activation record: 15ac,  *note activation stack: 27,  *note active:
78,  *note address: 126,  *note address space: 54,  *note address space
layout randomization: cc,  *note address translation cache: 15be,  *note
address-ordered first fit: 384,  *note aging space: 15c2,  *note
algebraic data type: 15c5,  *note alignment: 68,  *note alive: 78, 
*note allocate: 15ca,  *note allocation frame: 27d,  *note allocation
mechanism: 15d4,  *note allocation pattern: 272,  *note allocation
point: 63,  *note allocation point protocol: 2a,  *note allocation
policy: 380,  *note allocation strategy: 15d5,  *note allocator: 15ce, 
*note ambiguous reference: 9f,  *note ambiguous root: 1c4,  *note arena:
16,  *note arena class: 11a,  *note ASLR: cc,  *note assertion: 284, 
*note asynchronous garbage collector: a1,  *note ATC: 15be,  *note
atomic object: 107,  *note automatic memory management: 9,  *note
automatic storage duration: 15d0, 

*note backing store: 15d1,  *note barrier (1): 60,  *note barrier (2):
15ee,  *note barrier hit: 1d7,  *note base pointer: 1aa,  *note best
fit: 382,  *note BIBOP: 15f6,  *note big bag of pages: 15f6,  *note
binary buddies: 15f8,  *note bit array: 298,  *note bit table: 298, 
*note bit vector: 298,  *note bitmap: 298,  *note bitmap marking: 15fe, 
*note bitmapped fit: 15ff,  *note bitmask: 218,  *note bitset: 298, 
*note black: 1604,  *note blacklisting: 1608,  *note black-listing:
1609,  *note block: 185,  *note bounds error: c5,  *note boxed: 160b, 
*note break-table: 160c,  *note brk: 15d9,  *note broken heart: 1611, 
*note bucket: 15c3,  *note buddy system: 15f9,  *note buffer: 1cb, 
*note bus error: 15c9,  *note byte (1): 17c,  *note byte (2): 15c8, 
*note byte (3): 161b,  *note byte (4): 161c, 

*note C89: 1620,  *note C90: 1620,  *note C99: 1621,  *note cache (1):
1622,  *note cache (2): 1627,  *note cache memory: 1622,  *note cache
policy: 1625,  *note caching (3): 162a,  *note cactus stack: 162c, 
*note card: 162d,  *note card marking: 162e,  *note cell: 1ab,  *note
Cheney collector: 1632,  *note Cheney scan: 1632,  *note clamped state:
19f,  *note client arena: 4d,  *note client object: 325,  *note client
pointer: 1d4,  *note client program: 30c,  *note closure: 1ee,  *note
coalesce: 38c,  *note cold end: aa,  *note collect: 163a,  *note
collection: 1a2,  *note collection cycle: 1a2,  *note collector (1):
20,  *note collector (2): 15ae,  *note color: 163c,  *note colour:
163d,  *note commit limit: 156,  *note committed (1): 190,  *note
committed (2): b1,  *note compactifying: 1643,  *note compaction: 1643, 
*note composite object: 1644,  *note comprehensive: 1648,  *note
concurrent garbage collection: 15ed,  *note condemned set: 221,  *note
connected: 164c,  *note cons (1): 15cf,  *note cons (2): 15ca,  *note
conservative garbage collection: 349,  *note constant root: 215,  *note
constructor (1): 15d3,  *note constructor (2): 1651,  *note
continuation: 15ad,  *note control stack: 27,  *note cool: c8,  *note
copying garbage collection: e3,  *note core: 1656,  *note creation
space: 15c4,  *note critical path: 7c,  *note crossing map: 162f,  *note
cyclic data structure: 1659, 

*note dangling pointer: 281,  *note data stack: 1654,  *note dead: 49, 
*note deallocate: 15d2,  *note debugging pool: 285,  *note deferred
coalescing: 1638,  *note deferred reference counting: 165f,  *note
dependent object: ff,  *note derived pointer: 1ac,  *note destructor
(1): 1650,  *note destructor (2): 1652,  *note DGC: 1663,  *note direct
method: 1664,  *note dirty bit: 1602,  *note distributed garbage
collection: 1663,  *note double buddies: 1617,  *note double free: 26b, 
*note doubleword: 1667,  *note doubly weak hash table: fd,  *note DRAM:
166a,  *note dynamic allocation: 1653,  *note dynamic extent: 24a, 
*note dynamic memory: 166a,  *note dynamic RAM: 166a, 

*note ecru: 1640,  *note edge: 1671,  *note entry table (1): 1672, 
*note entry table (2): 1674,  *note exact garbage collection: 164f, 
*note exact reference: 61,  *note exact root: 20b,  *note exact
segregated fit: 1675,  *note execution stack: 27,  *note exit table:
1673,  *note extent: b5,  *note external fragmentation: 383, 

*note fencepost: 283,  *note fence post: 167b,  *note fencepost error:
167c,  *note fence post error: 167d,  *note Fibonacci buddies: 1615, 
*note FIFO-ordered first fit: 385,  *note file mapping: 15b7,  *note
finalization: b,  *note finalized block: 23d,  *note first fit: 37f, 
*note fix: b4,  *note flip: 18c,  *note floating garbage: 15d8,  *note
foreign code: 10b,  *note format: 164e,  *note format method: 69,  *note
formatted object: 23,  *note forward method: 85,  *note forwarding
marker: 1db,  *note forwarding object: 66,  *note forwarding pointer:
87,  *note fragmentation: 17e,  *note frame: 1d1,  *note free (1):
15d2,  *note free (2): 1b,  *note free (3): 15d6,  *note free (4):
1685,  *note free block: 15bf,  *note free block chain: 15c0,  *note
free list: 268,  *note free store: 47,  *note freestore: 47,  *note from
space: 1689,  *note fromspace: 1682,  *note function pointer: 168a, 
*note function record: 15ac, 

*note garbage: 1649,  *note garbage collection: f,  *note garbage
collector: 20,  *note GB: 1619,  *note GC: f,  *note General Protection
Fault: 1692,  *note generation: e1,  *note generation chain: e2,  *note
generation scavenging: e,  *note generational garbage collection: e, 
*note generational hypothesis: 35b,  *note gigabyte: 1619,  *note good
fit: 15f5,  *note GPF: 1692,  *note grain: 1695,  *note graph: 1635, 
*note gray: 1606,  *note grey: 1696,  *note gray list: 1697,  *note grey
list: 1698, 

*note handle: 1678,  *note header: 1d1,  *note heap: 47,  *note heap
allocation: 1653,  *note hit: 169d,  *note hit rate: 169f,  *note hot:
162,  *note hot end: 1639,  *note huge page: 16a1, 

*note immediate data: 16a5,  *note immune set: 164b,  *note immutable:
16a7,  *note immutable object: 16a6,  *note in-band header: 1d1,  *note
in parameter: 16ab,  *note in/out parameter: 120,  *note incremental
garbage collection: d,  *note incremental update: 16ad,  *note
indefinite extent: 15af,  *note indexed fit: 15f4,  *note indirect
method: 1665,  *note infant mortality: 35b,  *note inline allocation
(1): a,  *note inline allocation (2): 16b1,  *note inter-generational
pointer: 1630,  *note interior pointer: 1ac,  *note internal
fragmentation: 379,  *note invalid page fault: 16b4,  *note inverted
page table: 16b6,  *note inverted page-table: 16b7,  *note is-forwarded
method: 8c, 

*note kB: 188,  *note keyword argument: 53,  *note kilobyte: 188, 

*note large object area: 16c1,  *note large page: 16a1,  *note leaf
object: 107,  *note leak: 234,  *note life: b5,  *note lifetime: b5, 
*note LIFO-ordered first fit: 15c1,  *note limited-field reference
count: 16c5,  *note linear addressing: 16c7,  *note live: 78,  *note
load: 15ea,  *note locality of reference: 1601,  *note location: 15b4, 
*note location dependency: 19a,  *note lock free: 1bf,  *note logical
address: 16b9,  *note longword: 1667, 

*note machine word: 37c,  *note main memory: 311,  *note malloc: 1a, 
*note manual memory management: 8,  *note mapped: 190,  *note mapping:
310,  *note mark-compact: 160d,  *note mark-sweep: 15fd,  *note
mark-and-sweep: 16d3,  *note marking: 1600,  *note MB: 186,  *note
megabyte: 186,  *note memoization: 162a,  *note memory (1): 15b0,  *note
memory (2): 194,  *note memory (3): 311,  *note memory (4): 16d8,  *note
memory bandwidth: 16d9,  *note memory cache: 1622,  *note memory
hierarchy: 1628,  *note memory leak: 234,  *note memory location: 15b4, 
*note memory management: 15dd,  *note Memory Management Unit: 16db, 
*note memory manager: 15cd,  *note memory mapping: 15b7,  *note memory
protection: 1fd,  *note message: e9,  *note message queue: ea,  *note
message type: 22c,  *note misaligned: 15cb,  *note miss: 169e,  *note
miss rate: 16a0,  *note mmap: 16d0,  *note MMU: 16db,  *note
mostly-copying garbage collection: 1655,  *note mostly-exact garbage
collection: 348,  *note mostly-precise garbage collection: 348,  *note
moving garbage collector: 5d,  *note moving memory manager: 1ad,  *note
mutable: 16a8,  *note mutator: 30c, 

*note nailing: 1e5,  *note natural alignment: 70,  *note nepotism:
16e5,  *note next fit: 1681,  *note new space: 16e6,  *note newspace:
1633,  *note node: 163e,  *note non-moving garbage collector: 5e,  *note
non-moving memory manager: 1e7,  *note nursery generation: 35f,  *note
nursery space: 35f, 

*note object: 1ab,  *note object format: 39,  *note object pointer: 6e, 
*note off-white: 1640,  *note old space: 1682,  *note oldspace: 1682, 
*note one-bit reference count: 16c6,  *note opaque type: 16ec,  *note
out parameter: 58,  *note out-of-band header: 16aa,  *note overcommit:
16cf,  *note overwriting error: c5, 

*note padding: 16b3,  *note padding method: 90,  *note padding object:
67,  *note page: 92,  *note page fault: 16b5,  *note page marking:
1657,  *note page protection: 1fd,  *note page table: 16a2,  *note paged
in: 195,  *note paged out: 16d1,  *note paging: 15e7,  *note palimpsest:
16f4,  *note parallel garbage collection: 15ed,  *note parked state:
b8,  *note perfect fit: 15f2,  *note phantom reachable: 16f5,  *note
phantomly reachable: 16f6,  *note phantom reference: 16fa,  *note
physical address: 15aa,  *note physical address space: 15ba,  *note
physical memory (1): 16b8,  *note physical memory (2): 15b6,  *note
physical storage: 15b6,  *note pig in the python: 16fc,  *note pig in
the snake: 16fc,  *note pinning: 1e5,  *note placement policy: 380, 
*note platform: 12f,  *note plinth: 160,  *note pointer: 15b8,  *note
pool: 18,  *note pool class: 10,  *note postmortem state: d5,  *note
precise garbage collection: 164f,  *note precise reference: 61,  *note
precise root: 20b,  *note premature free: 165c,  *note premature
promotion: 1703,  *note premature tenuring: 1703,  *note primary
storage: 311,  *note promotion: 223,  *note protectable root: 216, 
*note protected: d4,  *note protection: 1fd,  *note protection
exception: 1d7,  *note protection fault: 1d7,  *note protection
violation: 1d7, 

*note quadword: 1668, 

*note RAM: 55,  *note random access memory: 55,  *note ramp allocation:
277,  *note rank: 9e,  *note rash: 163,  *note raw: 170e,  *note
reachable: 96,  *note read barrier: 1d6,  *note read fault: 16f0,  *note
read-only memory: 16ce,  *note real memory (1): 16d7,  *note real memory
(2): 16b8,  *note reclaim: 4a,  *note recycle: 15de,  *note reference:
24,  *note reference counting: 15e0,  *note reference object: 16fb, 
*note region inference: 15e1,  *note register: 26,  *note register set
partitioning: 1714,  *note relocation: 160e,  *note remembered set:
213,  *note remote reference: 35d,  *note replicating garbage collector:
16e1,  *note reserved: 16d2,  *note resident: 1624,  *note resident set:
1715,  *note result code: 59,  *note resurrection: 247,  *note ROM:
16ce,  *note root: 97,  *note root description: 1718,  *note root mode:
a0,  *note root set: 1716, 

*note sbrk: 160f,  *note scalar data type: 15c6,  *note scan: 65,  *note
scan method: 73,  *note scan state: 79,  *note scavenging garbage
collection: e3,  *note SDRAM: 166c,  *note segmentation violation:
1618,  *note segmented addressing: 15b9,  *note segregated allocation
cache: 1b2,  *note segregated fit: 15f3,  *note segregated free list:
25c,  *note segregated free-list: 171c,  *note semi-conservative garbage
collection: 348,  *note semi-space: 1612,  *note semi-space collector:
1634,  *note sequential fit: 15f1,  *note sequential store buffer:
171f,  *note shared memory: 1720,  *note simple object: 1646,  *note
simple segregated storage: 171d,  *note size: 183,  *note size class:
263,  *note skip method: 81,  *note smart pointer: 1711,  *note
snap-out: 1721,  *note snapshot at the beginning: 16ae,  *note soft
reference: 1712,  *note softly reachable: 16f8,  *note space leak: 234, 
*note spare commit limit: 197,  *note spare committed memory: 18f, 
*note spaghetti stack: 162c,  *note splat: 245,  *note split: 1614, 
*note SRAM: 1623,  *note SSB: 171f,  *note stack: 15bc,  *note stack
allocation: 15e2,  *note stack frame: 15b1,  *note stack record: 15b1, 
*note static allocation: 1610,  *note static memory (1): 1623,  *note
static memory (2): 1729,  *note static object: 172a,  *note static RAM:
1623,  *note static storage duration: 15e3,  *note stepper function:
21d,  *note sticky reference count: 16c5,  *note stop-and-copy
collection: 16ac,  *note storage: 15b0,  *note storage hierarchy: 1628, 
*note storage level: 1626,  *note storage management: 15dd,  *note store
(1): 15eb,  *note store (2): 15b0,  *note stretchy vector: 172e,  *note
strict segregated fit: 1613,  *note strong reference: 244,  *note strong
root: 1717,  *note strong tri-color invariant: 16af,  *note strong
tri-colour invariant: 172f,  *note strong tricolor invariant: 1730, 
*note strong tricolour invariant: 1731,  *note strongly reachable:
16f7,  *note suballocator: 16b2,  *note subgraph: 1733,  *note
superpage: 16a1,  *note sure reference: 61,  *note swap space: 15e9, 
*note swapped in: 16f3,  *note swapped out: 169b,  *note swapping:
15e8,  *note sweeping: 16d4,  *note synchronous garbage collector: c1, 

*note tabling: 162a,  *note tag: 88,  *note tagged architecture: 1658, 
*note tagged reference: 7d,  *note TB (1): 161a,  *note TB (2): 15be, 
*note telemetry filter: 295,  *note telemetry label: 12e,  *note
telemetry stream: ba,  *note tenuring: 223,  *note terabyte: 161a, 
*note termination: b,  *note thrash: 16de,  *note thread: 99,  *note
threatened set: 221,  *note TLB: 15be,  *note to space: 173f,  *note
tospace: 1633,  *note trace: 4b,  *note tracing garbage collection:
15df,  *note translation buffer: 1740,  *note translation lookaside
buffer: 15be,  *note transparent alias: 1741,  *note transparent type:
127,  *note transport: 1722,  *note transport snap-out: 1721,  *note
treadmill: 163f,  *note tri-color invariant: 1732,  *note tri-colour
invariant: 1743,  *note tricolor invariant: 1744,  *note tricolour
invariant: 1745,  *note tri-color marking: 1605,  *note tri-colour
marking: 1746,  *note tricolor marking: 1747,  *note tricolour marking:
1748,  *note two-space collector: 1634,  *note two space collector:
1749,  *note type-accurate garbage collection: 164f,  *note type
punning: a5, 

*note unaligned: 15cb,  *note unboxed: 48,  *note unclamped state: 192, 
*note undead: 165d,  *note unmapped: 1685,  *note unprotected: 1a8, 
*note unreachable: 21,  *note unsure reference: 9f,  *note unwrapped:
170e,  *note use after free: 165c, 

*note value object: 16a6,  *note variety: c9,  *note vector data type:
15c7,  *note virtual address: 16b9,  *note virtual address space: 15bb, 
*note virtual memory: 51,  *note virtual memory arena: 4f,  *note
visitor function: 21d,  *note VM (1): 51,  *note VM (2): 1647, 

*note weak-key hash table: fb,  *note weak-value hash table: fc,  *note
weak hash table: 357,  *note weak reference (1): c,  *note weak
reference (2): 1713,  *note weak root: 20d,  *note weak tri-color
invariant: 1723,  *note weak tri-colour invariant: 1757,  *note weak
tricolor invariant: 1758,  *note weak tricolour invariant: 1759,  *note
weakly reachable: 16f9,  *note weighted buddies: 1616,  *note weighted
reference counting: 1666,  *note white: 1607,  *note word: 37c,  *note
working set: 16ba,  *note worst fit: 386,  *note wrapped: 174e,  *note
wrapper: 175a,  *note write barrier: 214,  *note write fault: 16f1, 

*note ZCT: 1660,  *note zero count table: 1660.


File: MemoryPoolSystem.info,  Node: Index to source code,  Next: Memory Pool System Kit Open Source License,  Prev: Memory Management Glossary,  Up: Top

8 Index to source code
**********************

* Menu:

* External MPS interface::
* Plinth: Plinth<2>.
* Configuration::
* Core MPS::
* Platform interfaces::
* Pool classes: Pool classes<3>.
* Auxiliary programs::
* Benchmarks::
* Test support::
* Interactive test cases::
* Automated test cases::
* Build infrastructure::


File: MemoryPoolSystem.info,  Node: External MPS interface,  Next: Plinth<2>,  Up: Index to source code

8.1 External MPS interface
==========================

The external MPS interface consists of header files that the *note
client program: d0. is expected to include, plus the single-file source
code (mps.c).  See design.mps.interface-c(1).

File            Description
                
---------------------------------------------------------------------------------------
                
mps.h           Public MPS interface.
                
                
mps.c           Single-file source code.  See
                *note Building the Memory Pool System: 14.
                
                
mpsacl.h        *note Client arenas: 178. external interface.
                
                
mpsavm.h        *note Virtual memory arenas: 179. external interface.
                
                
mpscamc.h       *note AMC (Automatic Mostly-Copying): 62. pool class external
                interface.
                
                
mpscams.h       *note AMS (Automatic Mark and Sweep): 16c. pool class external
                interface.
                
                
mpscawl.h       *note AWL (Automatic Weak Linked): fe. pool class external
                interface.
                
                
mpsclo.h        *note LO (Leaf Object): 353. pool class external interface.
                
                
mpscmfs.h       *note MFS (Manual Fixed Small): 355. pool class external interface.
                
                
mpscmv2.h       Former (deprecated) *note MVT (Manual Variable Temporal): 1bc. pool
                class interface.
                
                
mpscmvff.h      *note MVFF (Manual Variable First Fit): 10c. pool class external
                interface.
                
                
mpscmvt.h       *note MVT (Manual Variable Temporal): 1bc. pool class external
                interface.
                
                
mpscsnc.h       *note SNC (Stack No Checking): 27b. pool class external interface.
                
                
mpsio.h         *note I/O module: 2b8. interface.
                
                
mpslib.h        *note Library module: 2cb. interface.
                

   ---------- Footnotes ----------

   (1) design/interface-c.html


File: MemoryPoolSystem.info,  Node: Plinth<2>,  Next: Configuration,  Prev: External MPS interface,  Up: Index to source code

8.2 Plinth
==========

The *note plinth: 160. provides an interface between the MPS and the
execution environment, to help support *note freestanding: 14e.
implementations.  See *note Plinth: 3b.

File            Description
                
---------------------------------------------------------------------------------------
                
mpsioan.c       *note I/O module: 2b8. for “ANSI” (hosted) environments.
                
                
mpsliban.c      *note Library module: 2cb. for “ANSI” (hosted) environments.
                


File: MemoryPoolSystem.info,  Node: Configuration,  Next: Core MPS,  Prev: Plinth<2>,  Up: Index to source code

8.3 Configuration
=================

These header files provide platform-specific constants, type
declarations, and macros.  See *note Porting the MPS: 306. and
design.mps.config(1).

File            Description
                
---------------------------------------------------------------------------------------
                
clock.h         Fast high-resolution clocks.
                
                
config.h        MPS configuration header.
                
                
mpstd.h         Target detection header.
                

   ---------- Footnotes ----------

   (1) design/config.html


File: MemoryPoolSystem.info,  Node: Core MPS,  Next: Platform interfaces,  Prev: Configuration,  Up: Index to source code

8.4 Core MPS
============

File             Description
                 
----------------------------------------------------------------------------------------
                 
abq.c            Fixed-length queue implementation.  See design.mps.abq(1).
                 
                 
abq.h            Fixed-length queue interface.  See design.mps.abq(2).
                 
                 
arena.c          Arena implementation.  See design.mps.arena(3).
                 
                 
arenacl.c        *note Client arenas: 178. implementation.
                 
                 
arenavm.c        *note Virtual memory arenas: 179. implementation.
                 
                 
arg.c            *note Keyword arguments: 57. implementation.
                 
                 
arg.h            *note Keyword arguments: 57. interface.
                 
                 
boot.c           Bootstrap allocator implementation.  See design.mps.bootstrap(4).
                 
                 
boot.h           Bootstrap allocator interface.  See design.mps.bootstrap(5).
                 
                 
bt.c             Bit table implementation.  See design.mps.bt(6).
                 
                 
bt.h             Bit table interface.  See design.mps.bt(7).
                 
                 
buffer.c         Buffer implementation.  See design.mps.buffer(8).
                 
                 
cbs.c            Coalescing block implementation.  See design.mps.cbs(9).
                 
                 
cbs.h            Coalescing block interface.  See design.mps.cbs(10).
                 
                 
check.h          Assertion interface.  See design.mps.check(11).
                 
                 
dbgpool.c        *note Debugging pools: 10d. implementation.
                 
                 
dbgpool.h        *note Debugging pools: 10d. interface.
                 
                 
dbgpooli.c       *note Debugging pools: 10d. external interface.
                 
                 
event.c          *note Telemetry: db. implementation.
                 
                 
event.h          *note Telemetry: db. interface (internal).
                 
                 
eventcom.h       *note Telemetry: db. interface (auxiliary programs).
                 
                 
eventdef.h       *note Telemetry: db. event definitions.
                 
                 
failover.c       Fail-over allocator implementation.  See design.mps.failover(12).
                 
                 
failover.h       Fail-over allocator interface.  See design.mps.failover(13).
                 
                 
format.c         *note Object formats: 6a. implementation.
                 
                 
freelist.c       Freelist allocator implementation.  See design.mps.freelist(14).
                 
                 
freelist.h       Freelist allocator interface.  See design.mps.freelist(15).
                 
                 
global.c         Global arena implementation.
                 
                 
land.c           Land implementation.  See design.mps.land(16).
                 
                 
ld.c             *note Location dependency: f8. implementation.
                 
                 
locus.c          Locus manager implementation.  See design.mps.locus(17).
                 
                 
locus.h          Locus manager interface.  See design.mps.locus(18).
                 
                 
message.c        *note Messages: f1. implementation.
                 
                 
meter.c          Debugging accumulator implementation.
                 
                 
meter.h          Debugging accumulator interface.
                 
                 
misc.h           Miscellaneous constant and macro definitions.
                 
                 
mpm.c            Miscellaneous support functions.  See design.mps.writef(19).
                 
                 
mpm.h            Core MPS interface.  (“MPM” = “Memory Pool Manager”)
                 
                 
mpmst.h          Core data structure declarations.
                 
                 
mpmtypes.h       Core type declarations.
                 
                 
mpsi.c           External interface implementation.  See design.mps.interface-c(20).
                 
                 
mpsiw3.c         Additional external interface implementation for Windows.
                 
                 
mpswin.h         Wrapper for windows.h.
                 
                 
nailboard.c      Nailboard implementation.  See design.mps.nailboard(21).
                 
                 
nailboard.h      Nailboard interface.  See design.mps.nailboard(22).
                 
                 
policy.c         Collection policy decisions.  See design.mps.strategy(23).
                 
                 
pool.c           Pool implementation.  See design.mps.pool(24).
                 
                 
poolabs.c        Abstract pool classes.
                 
                 
poolmrg.c        Manual Rank Guardian pool implementation.  See
                 design.mps.poolmrg(25).
                 
                 
poolmrg.h        Manual Rank Guardian pool interface.  See design.mps.poolmrg(26).
                 
                 
protocol.c       Inheritance protocol implementation.  See design.mps.protocol(27).
                 
                 
protocol.h       Inheritance protocol interface.  See design.mps.protocol(28).
                 
                 
range.c          Address ranges implementation.  See design.mps.range(29).
                 
                 
range.h          Address ranges interface.  See design.mps.range(30).
                 
                 
rangetree.c      Binary address-ordered range tree implementation.
                 
                 
rangetree.h      Binary address-ordered range tree interface.
                 
                 
ref.c            Ranks and zones implementation.
                 
                 
ring.c           Ring implementation.  See design.mps.ring(31).
                 
                 
ring.h           Ring interface.  See design.mps.ring(32).
                 
                 
root.c           *note Roots: 28. implementation.
                 
                 
sa.c             Sparse array implementation.
                 
                 
sa.h             Sparse array interface.
                 
                 
sac.c            *note Segregated allocation caches: 25b. implementation.
                 
                 
sac.h            *note Segregated allocation caches: 25b. interface.
                 
                 
sc.h             Stack context interface.
                 
                 
scan.c           *note Scanning: 25. functions.
                 
                 
seg.c            Segment implementation.  See design.mps.seg(33).
                 
                 
shield.c         Shield implementation.  See design.mps.shield(34).
                 
                 
splay.c          Splay tree implementation.  See design.mps.splay(35).
                 
                 
splay.h          Splay tree interface.  See design.mps.splay(36).
                 
                 
trace.c          Trace implementation.  See design.mps.trace(37).
                 
                 
traceanc.c       More trace implementation.  See design.mps.trace(38).
                 
                 
tract.c          Chunk and tract implementation.  See design.mps.arena(39).
                 
                 
tract.h          Chunk and tract interface.  See design.mps.arena(40).
                 
                 
tree.c           Binary tree implementation.
                 
                 
tree.h           Binary tree interface.
                 
                 
version.c        MPS version implementation.  See design.mps.version(41).
                 
                 
walk.c           Formatted object walker.
                 

   ---------- Footnotes ----------

   (1) design/abq.html

   (2) design/abq.html

   (3) design/arena.html

   (4) design/bootstrap.html

   (5) design/bootstrap.html

   (6) design/bt.html

   (7) design/bt.html

   (8) design/buffer.html

   (9) design/cbs.html

   (10) design/cbs.html

   (11) design/check.html

   (12) design/failover.html

   (13) design/failover.html

   (14) design/freelist.html

   (15) design/freelist.html

   (16) design/land.html

   (17) design/locus.html

   (18) design/locus.html

   (19) design/writef.html

   (20) design/interface-c.html

   (21) design/nailboard.html

   (22) design/nailboard.html

   (23) design/strategy.html

   (24) design/pool.html

   (25) design/poolmrg.html

   (26) design/poolmrg.html

   (27) design/protocol.html

   (28) design/protocol.html

   (29) design/range.html

   (30) design/range.html

   (31) design/ring.html

   (32) design/ring.html

   (33) design/seg.html

   (34) design/shield.html

   (35) design/splay.html

   (36) design/splay.html

   (37) design/trace.html

   (38) design/trace.html

   (39) design/arena.html

   (40) design/arena.html

   (41) design/version.html


File: MemoryPoolSystem.info,  Node: Platform interfaces,  Next: Pool classes<3>,  Prev: Core MPS,  Up: Index to source code

8.5 Platform interfaces
=======================

These modules provide interfaces to features that are not available in
standard C, and so may need to be ported to new platforms.  See *note
Porting the MPS: 306.

File             Description
                 
---------------------------------------------------------------------------------------
                 
lock.h           Lock interface.  See design.mps.lock(1).
                 
                 
lockan.c         Lock implementation for standard C.
                 
                 
lockix.c         Lock implementation for POSIX.
                 
                 
lockw3.c         Lock implementation for Windows.
                 
                 
prmc.h           Mutator context interface.  See design.mps.prmc(2).
                 
                 
prmcan.c         Mutator context implementation for generic operating system.
                 
                 
prmcanan.c       Mutator context implementation for generic architecture.
                 
                 
prmcfri3.c       Mutator context implementation for FreeBSD, IA-32.
                 
                 
prmcfri6.c       Mutator context implementation for FreeBSD, x86-64.
                 
                 
prmci3.c         Mutator context implementation for IA-32.
                 
                 
prmci3.h         Mutator context interface for IA-32.
                 
                 
prmci6.c         Mutator context implementation for x86-64.
                 
                 
prmci6.h         Mutator context interface for x86-64.
                 
                 
prmcix.c         Mutator context implementation for POSIX.
                 
                 
prmcix.h         Mutator context interface for POSIX.
                 
                 
prmclia6.c       Mutator context implementation for Linux, ARM64.
                 
                 
prmclii3.c       Mutator context implementation for Linux, IA-32.
                 
                 
prmclii6.c       Mutator context implementation for Linux, x86-64.
                 
                 
prmcw3.c         Mutator context implementation for Windows.
                 
                 
prmcw3.h         Mutator context interface for Windows.
                 
                 
prmcw3i3.c       Mutator context implementation for Windows, IA-32.
                 
                 
prmcw3i6.c       Mutator context implementation for Windows, x86-64.
                 
                 
prmcxc.c         Mutator context implementation for macOS.
                 
                 
prmcxc.h         Mutator context interface for macOS.
                 
                 
prmcxca6.c       Mutator context implementation for macOS, ARM64.
                 
                 
prmcxci3.c       Mutator context implementation for macOS, IA-32.
                 
                 
prmcxci6.c       Mutator context implementation for macOS, x86-64.
                 
                 
prot.h           Protection interface.  See design.mps.prot(3).
                 
                 
protan.c         Protection implementation for standard C.
                 
                 
protix.c         Protection implementation for POSIX.
                 
                 
protsgix.c       Protection implementation for POSIX (signals part).
                 
                 
protw3.c         Protection implementation for Windows.
                 
                 
protxc.c         Protection implementation for macOS.
                 
                 
protxc.h         Protection interface for macOS.
                 
                 
pthrdext.c       Protection implementation for POSIX (threads part).
                 
                 
pthrdext.h       Protection interface for POSIX (threads part).
                 
                 
sp.h             Stack probe interface.  See design.mps.sp(4).
                 
                 
span.c           Stack probe implementation for standard C.
                 
                 
spw3i3.c         Stack probe implementation for Windows, IA-32.
                 
                 
spw3i6.c         Stack probe implementation for Windows, x86-64.
                 
                 
ss.c             Stack scanning implementation.
                 
                 
ss.h             Stack scanning interface.  See design.mps.stack-scan(5).
                 
                 
th.h             Threads interface.  See design.mps.thread-manager(6).
                 
                 
than.c           Threads implementation for standard C.
                 
                 
thix.c           Threads implementation for POSIX.
                 
                 
thw3.c           Threads implementation for Windows.
                 
                 
thxc.c           Threads implementation for macOS.
                 
                 
vm.c             Virtual memory implementation (common part).
                 
                 
vm.h             Virtual memory interface.  See design.mps.vm(7).
                 
                 
vman.c           Virtual memory implementation for standard C.
                 
                 
vmix.c           Virtual memory implementation for POSIX.
                 
                 
vmw3.c           Virtual memory implementation for Windows.
                 

   ---------- Footnotes ----------

   (1) design/lock.html

   (2) design/prmc.html

   (3) design/prot.html

   (4) design/sp.html

   (5) design/stack-scan.html

   (6) design/thread-manager.html

   (7) design/vm.html


File: MemoryPoolSystem.info,  Node: Pool classes<3>,  Next: Auxiliary programs,  Prev: Platform interfaces,  Up: Index to source code

8.6 Pool classes
================

These files implement the supported *note pool classes: 10.  Some of
these (MFS, MVFF) are used internally by the MPS; the others are
available for *note client programs: d0. only.  See *note Pool
reference: 22.

File            Description
                
---------------------------------------------------------------------------------------
                
poolamc.c       *note AMC (Automatic Mostly-Copying): 62. implementation.
                
                
poolams.c       *note AMS (Automatic Mark and Sweep): 16c. implementation.
                
                
poolams.h       *note AMS (Automatic Mark and Sweep): 16c. internal interface.
                
                
poolawl.c       *note AWL (Automatic Weak Linked): fe. implementation.
                
                
poollo.c        *note LO (Leaf Object): 353. implementation.
                
                
poolmfs.c       *note MFS (Manual Fixed Small): 355. implementation.
                
                
poolmfs.h       *note MFS (Manual Fixed Small): 355. internal interface.
                
                
poolmv2.c       *note AMC (Automatic Mostly-Copying): 62. implementation.
                
                
poolmv2.h       *note MVT (Manual Variable Temporal): 1bc. internal interface.
                
                
poolmvff.c      *note MVFF (Manual Variable First Fit): 10c. implementation.
                
                
poolmvff.h      *note MVFF (Manual Variable First Fit): 10c. internal interface.
                
                
poolsnc.c       *note SNC (Stack No Checking): 27b. implementation.
                


File: MemoryPoolSystem.info,  Node: Auxiliary programs,  Next: Benchmarks,  Prev: Pool classes<3>,  Up: Index to source code

8.7 Auxiliary programs
======================

These files implement auxiliary programs.  See *note Telemetry
utilities: 28d.

File            Description
                
---------------------------------------------------------------------------------------
                
eventcnv.c      *note Decoding the telemetry stream: 28e.
                
                
eventsql.c      *note Loading the telemetry stream into SQLite: 290.
                
                
eventpy.c       *note Decoding the telemetry stream in Python: 291.
                
                
eventtxt.c      *note Making the telemetry stream readable: 28f.
                
                
getopt.h        Command-line option interface.  Adapted from FreeBSD.
                
                
getoptl.c       Command-line option implementation.  Adapted from FreeBSD.
                
                
table.c         Address-based hash table implementation.
                
                
table.h         Address-based hash table interface.
                


File: MemoryPoolSystem.info,  Node: Benchmarks,  Next: Test support,  Prev: Auxiliary programs,  Up: Index to source code

8.8 Benchmarks
==============

File            Description
                
---------------------------------------------------------------------------------------
                
djbench.c       Benchmark for manually managed pool classes.
                
                
gcbench.c       Benchmark for automatically managed pool classes.
                


File: MemoryPoolSystem.info,  Node: Test support,  Next: Interactive test cases,  Prev: Benchmarks,  Up: Index to source code

8.9 Test support
================

This is code that’s shared between test cases.

File             Description
                 
---------------------------------------------------------------------------------------
                 
fmtdy.c          Dylan object format implementation.
                 
                 
fmtdy.h          Dylan object format interface.
                 
                 
fmtdytst.c       Dylan object constructor implementation.
                 
                 
fmtdytst.h       Dylan object constructor interface.
                 
                 
fmthe.c          Dylan-like object format with headers (implementation).
                 
                 
fmthe.h          Dylan-like object format with headers (interface).
                 
                 
fmtno.c          Null object format implementation.
                 
                 
fmtno.h          Null object format interface.
                 
                 
fmtscheme.c      Scheme object format implementation.
                 
                 
fmtscheme.h      Scheme object format interface.
                 
                 
pooln.c          Null pool implementation.
                 
                 
pooln.h          Null pool interface.
                 
                 
testlib.c        Test utilities implementation.
                 
                 
testlib.h        Test utilities interface.
                 
                 
testthr.h        Test threads interface.  See design.mps.testthr(1).
                 
                 
testthrix.c      Test threads implementation for POSIX.
                 
                 
testthrw3.c      Test threads implementation for Windows.
                 

   ---------- Footnotes ----------

   (1) design/testthr.html


File: MemoryPoolSystem.info,  Node: Interactive test cases,  Next: Automated test cases,  Prev: Test support,  Up: Index to source code

8.10 Interactive test cases
===========================

These test cases provide harness for interacting with parts of the MPS,
for exploring the interface and testing by hand.  These predate the use
of continuous integration: we wouldn’t write this kind of test case now.

File            Description
                
---------------------------------------------------------------------------------------
                
bttest.c        Interactive bit tables test harness.
                
                
teletest.c      Interactive telemetry test harness.
                


File: MemoryPoolSystem.info,  Node: Automated test cases,  Next: Build infrastructure,  Prev: Interactive test cases,  Up: Index to source code

8.11 Automated test cases
=========================

These are test cases that run automatically and form the main test
suite.  See design.mps.tests(1).

File                 Description
                     
---------------------------------------------------------------------------------------
                     
abqtest.c            Fixed-length queue test.
                     
                     
airtest.c            Ambiguous interior reference test.
                     
                     
amcss.c              *note AMC (Automatic Mostly-Copying): 62. stress test.
                     
                     
amcsshe.c            *note AMC (Automatic Mostly-Copying): 62. stress test (using
                     in-band headers).
                     
                     
amcssth.c            *note AMC (Automatic Mostly-Copying): 62. stress test (using
                     multiple threads).
                     
                     
amsss.c              *note AMS (Automatic Mark and Sweep): 16c. stress test.
                     
                     
amssshe.c            *note AMS (Automatic Mark and Sweep): 16c. stress test (using
                     in-band headers).
                     
                     
apss.c               *note Allocation points: 1be. stress test.
                     
                     
arenacv.c            Arena coverage test.
                     
                     
awlut.c              *note AWL (Automatic Weak Linked): fe. unit test.
                     
                     
awluthe.c            *note AWL (Automatic Weak Linked): fe. unit test (using in-band
                     headers).
                     
                     
awlutth.c            *note AWL (Automatic Weak Linked): fe. unit test (using
                     multiple threads).
                     
                     
btcv.c               Bit table coverage test.
                     
                     
finalcv.c            *note Finalization: f0. coverage test.
                     
                     
finaltest.c          *note Finalization: f0. test.
                     
                     
forktest.c           *note Fork safety: 1ff. test.
                     
                     
fotest.c             Failover allocator test.
                     
                     
landtest.c           Land test.
                     
                     
locbwcss.c           Locus backwards compatibility stress test.
                     
                     
lockcov.c            Lock coverage test.
                     
                     
lockut.c             Lock unit test.
                     
                     
locusss.c            Locus stress test.
                     
                     
locv.c               *note LO (Leaf Object): 353. coverage test.
                     
                     
messtest.c           *note Messages: f1. test.
                     
                     
mpmss.c              Manual allocation stress test.
                     
                     
mpsicv.c             External interface coverage test.
                     
                     
mv2test.c            *note MVT (Manual Variable Temporal): 1bc. test.
                     
                     
nailboardtest.c      Nailboard test.
                     
                     
poolncv.c            Null pool class test.
                     
                     
qs.c                 Quicksort test.
                     
                     
sacss.c              *note Segregated allocation caches: 25b. stress test.
                     
                     
segsmss.c            Segment splitting and merging stress test.
                     
                     
steptest.c           *note mps_arena_step(): 19c. test.
                     
                     
tagtest.c            Tagged pointer scanning test.
                     
                     
walkt0.c             Roots and formatted objects walking test.
                     
                     
zcoll.c              Garbage collection progress test.
                     
                     
zmess.c              Garbage collection and finalization message test.
                     

   ---------- Footnotes ----------

   (1) design/tests.html


File: MemoryPoolSystem.info,  Node: Build infrastructure,  Prev: Automated test cases,  Up: Index to source code

8.12 Build infrastructure
=========================

These are makefiles (and makefile fragments) used to build the MPS. See
*note Porting the MPS: 306.

File              Description
                  
---------------------------------------------------------------------------------------
                  
anangc.gmk        GNU makefile for platform ANANGC.
                  
                  
ananll.gmk        GNU makefile for platform ANANLL.
                  
                  
ananmv.nmk        NMAKE file for platform ANANMV.
                  
                  
comm.gmk          Common GNU make fragment.
                  
                  
commpost.nmk      Common NMAKE fragment (included before the compiler fragment).
                  
                  
commpre.nmk       Common NMAKE fragment (included after the compiler fragment).
                  
                  
fri3gc.gmk        GNU makefile for platform FRI3GC.
                  
                  
fri3ll.gmk        GNU makefile for platform FRI3LL.
                  
                  
fri6gc.gmk        GNU makefile for platform FRI6GC.
                  
                  
fri6ll.gmk        GNU makefile for platform FRI6LL.
                  
                  
gc.gmk            GNU make fragment for GCC.
                  
                  
gp.gmk            GNU make fragment for GCC/GProf (broken).
                  
                  
lia6gc.gmk        GNU makefile for platform LIA6GC.
                  
                  
lia6ll.gmk        GNU makefile for platform LIA6LL.
                  
                  
lii3gc.gmk        GNU makefile for platform LII3GC.
                  
                  
lii6gc.gmk        GNU makefile for platform LII6GC.
                  
                  
lii6ll.gmk        GNU makefile for platform LII6LL.
                  
                  
ll.gmk            GNU make fragment for Clang/LLVM.
                  
                  
mv.nmk            NMAKE fragment for Microsoft Visual C.
                  
                  
pc.nmk            NMAKE fragment for Pelles C.
                  
                  
w3i3mv.nmk        NMAKE file for platform W3I3MV.
                  
                  
w3i3pc.nmk        NMAKE file for platform W3I3PC.
                  
                  
w3i6mv.nmk        NMAKE file for platform W3I6MV.
                  
                  
w3i6pc.nmk        NMAKE file for platform W3I6PC.
                  
                  
xca6ll.gmk        GNU makefile for platform XCA6LL.
                  
                  
xci3gc.gmk        GNU makefile for platform XCI3GC.
                  
                  
xci3ll.gmk        GNU makefile for platform XCI3LL.
                  
                  
xci6gc.gmk        GNU makefile for platform XCI6GC.
                  
                  
xci6ll.gmk        GNU makefile for platform XCI6LL.
                  


File: MemoryPoolSystem.info,  Node: Memory Pool System Kit Open Source License,  Next: Contact us,  Prev: Index to source code,  Up: Top

9 Memory Pool System Kit Open Source License
********************************************

This is the license under which the Memory Pool System Kit is made
available by Ravenbrook Limited.  This license is generally known as the
BSD 2-clause license(1).  It is GPL compatible(2) and OSI approved(3).

For avoidance of doubt, this license supersedes any older licenses that
may appear in other files that are part of this distribution and in any
of its branches.

Prior to 2020, the MPS was “multi-licensed” under the Sleepycat
License(4) and also by other specifically arranged license agreements.

* Menu:

* License::

   ---------- Footnotes ----------

   (1) https://opensource.org/licenses/BSD-2-Clause

   (2) https://www.gnu.org/licenses/license-list.html

   (3) https://opensource.org/licenses/sleepycat

   (4) https://en.wikipedia.org/wiki/Sleepycat_License


File: MemoryPoolSystem.info,  Node: License,  Up: Memory Pool System Kit Open Source License

9.1 License
===========

Copyright © 2001-2020 Ravenbrook Limited(1).

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the
     distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS
IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/


File: MemoryPoolSystem.info,  Node: Contact us,  Next: Contributing to the MPS,  Prev: Memory Pool System Kit Open Source License,  Up: Top

10 Contact us
*************

   * If you have questions about the project, or suggestions for
     improvement, please write to <mps-questions@ravenbrook.com>.

   * You can also join the mps-discussion mailing list(1) if you are
     interested in project progress, or if you’re adapting or extending
     the Memory Pool System.  The goals of the list are:

       1. to provide feedback to the project on requirements, design,
          implementation, etc.;

       2. to allow people to exchange information and experience with
          using and adapting the project;

       3. to keep people informed about project progress.

     To join, follow these instructions(2), or send a message with the
     word “subscribe” in the body to
     <mps-discussion-request@ravenbrook.com>.

     The mailing list is archived and the archives are published on
     Ravenbrook's web site(3).

   ---------- Footnotes ----------

   (1) http://mailman.ravenbrook.com/mailman/listinfo/mps-discussion

   (2) http://mailman.ravenbrook.com/mailman/listinfo/mps-discussion

   (3) http://mailman.ravenbrook.com/pipermail/mps-discussion/


File: MemoryPoolSystem.info,  Node: Contributing to the MPS,  Next: Release notes,  Prev: Contact us,  Up: Top

11 Contributing to the MPS
**************************

We are very happy to receive contributions to the Memory Pool System so
that we can improve it for everyone.

* Menu:

* Review::
* Licensing::
* Thank you::


File: MemoryPoolSystem.info,  Node: Review,  Next: Licensing,  Up: Contributing to the MPS

11.1 Review
===========

The MPS is highly engineered and rigorously controlled in order to
prevent defects.  This approach has lead to an extremely small number of
bugs in production since its first commercial use in 1997.  There are a
fairly large number of rules, both low- and high-level that your code
must follow in order to be accepted.  These rules are the result of
continuous process improvement to prevent defects.  Unfortunately, we do
not have many of them published at present.  We apologise if you find it
frustrating that we do not accept your changes as they are.

The style guide in guide.impl.c.format(1) contains basic rules for
style.

   ---------- Footnotes ----------

   (1) design/guide.impl.c.format.txt


File: MemoryPoolSystem.info,  Node: Licensing,  Next: Thank you,  Prev: Review,  Up: Contributing to the MPS

11.2 Licensing
==============

All contributions are deemed to have been made under the same license as
the material to which the contribution is made, unless you expressly
state otherwise in your contribution request.  In nearly all cases this
is the BSD 2-clause license(1).  You retain the copyright to such
contributions.

   ---------- Footnotes ----------

   (1) https://opensource.org/licenses/BSD-2-Clause


File: MemoryPoolSystem.info,  Node: Thank you,  Prev: Licensing,  Up: Contributing to the MPS

11.3 Thank you
==============

Finally, thank you for making the MPS more useful to everyone.


File: MemoryPoolSystem.info,  Node: Release notes,  Next: Introduction to memory management,  Prev: Contributing to the MPS,  Up: Top

12 Release notes
****************

* Menu:

* Release 1.118.0: Release 1 118 0.
* Release 1.117.0: Release 1 117 0.
* Release 1.116.0: Release 1 116 0.
* Release 1.115.0: Release 1 115 0.
* Release 1.114.0: Release 1 114 0.
* Release 1.113.0: Release 1 113 0.
* Release 1.112.0: Release 1 112 0.
* Release 1.111.0: Release 1 111 0.
* Release 1.110.0: Release 1 110 0.


File: MemoryPoolSystem.info,  Node: Release 1 118 0,  Next: Release 1 117 0,  Up: Release notes

12.1 Release 1.118.0
====================

* Menu:

* New features::
* Interface changes::
* Other changes::


File: MemoryPoolSystem.info,  Node: New features,  Next: Interface changes,  Up: Release 1 118 0

12.1.1 New features
-------------------

  1. New supported platforms:

        * ‘lia6gc’ (Linux, ARM64, GCC).

        * ‘lia6ll’ (Linux, ARM64, Clang/LLVM).

        * ‘xca6ll’ (macOS, ARM64, Clang/LLVM).

     See *note Platform limitations: 303. for limitations in the support
     for Apple Hardened Runtime on ‘xca6ll’.

  2. Support removed for platform:

        * ‘xci3ll’ (macOS, IA-32, Clang/LLVM).

     Support for this platform was removed in macOS 10.15 (Catalina),
     making it inconvenient to develop and test.

  3. The arena’s *note spare commit limit: 197. is now expressed as a
     fraction of the *note committed: 190. memory (rather than a fixed
     size, as previously).  This allows the *note spare committed
     memory: 18f. to scale with the *note working set: 16ba. size.  Set
     the spare commit limit using the keyword argument ‘MPS_KEY_SPARE’
     to *note mps_arena_create_k(): 52, or the function *note
     mps_arena_spare_set(): 198, and query it using the function *note
     mps_arena_spare(): 189.

  4. A new support tool, the 'monitor', implements a graphical user
     interface for analysis of *note Telemetry: db.  This is
     experimental: the implementation is likely to change in future
     versions of the MPS. See *note Monitor: 737.

  5. The newly-public 'transforms' feature updates references to a set
     of objects throughout the automatically managed portion of the
     heap, allowing them to be replaced by new versions.  See *note
     Transforms: 2be.

  6. The new function *note mps_pool_walk(): 1a6. visits all areas of
     *note formatted objects: 23. in a pool using the *note Scanning
     protocol: 16f, support hot reloading and serialization.  See *note
     Walking formatted objects: bd1.

  7. An *note allocation point: 63. for a pool belonging to the class
     *note AMC (Automatic Mostly-Copying): 62. can now be configured so
     that allocations do not provoke garbage collections, reducing the
     amount of re-hashing for address-based hash tables using *note
     location dependency: 19a.  See *note Hash arrays: 360.

  8. The new function *note mps_addr_object(): 1a9. allows clients to
     discover the base pointer of an object from a pointer to anywhere
     inside the object.  This is intended to support stack tracing and
     debugging for client programs that allocate their code on the heap.

  9. A *note virtual memory arena: 4f. can now be configured to call
     functions when it acquires a new chunk of *note address space: 54,
     and when it returns a chunk of address space to the operation
     system.  This is intended to support dynamic function tables in
     Windows.  See *note Arena extension callbacks: 181.


File: MemoryPoolSystem.info,  Node: Interface changes,  Next: Other changes,  Prev: New features,  Up: Release 1 118 0

12.1.2 Interface changes
------------------------

  1. The deprecated pool class MV (Manual Variable), and the deprecated
     functions ‘mps_mv_free_size’ and ‘mps_mv_size’ have been removed.
     Use *note MVFF (Manual Variable First Fit): 10c. and the generic
     functions *note mps_pool_free_size(): 1b7. and *note
     mps_pool_total_size(): 1b6. instead.

  2. The deprecated function ‘mps_tramp()’ has been removed.  The MPS
     has had no need for a trampoline, and client programs have not
     needed to take any special precautions before calling functions in
     the MPS, since version 1.111.

  3. The deprecated functions ‘mps_arena_expose()’,
     ‘mps_arena_unsafe_expose_remember_protection()’ and
     ‘mps_arena_unsafe_expose_restore_protection()’ have been removed.
     If you need access to protected memory for debugging a fatal error,
     use *note mps_arena_postmortem(): d6. instead.

  4. The deprecated reservoir functions
     ‘mps_ap_fill_with_reservoir_permit()’, ‘mps_reservoir_available()’,
     ‘mps_reservoir_limit()’, ‘mps_reservoir_limit_set()’ and
     ‘mps_reserve_with_reservoir_permit()’, have been removed.

  5. The deprecated function ‘mps_fix()’ has been removed.  Use the
     macro *note MPS_FIX12(): 77. instead.

  6. The deprecated function ‘mps_telemetry_control()’ has been removed.
     Use *note mps_telemetry_get(): 2b3, *note mps_telemetry_set(): 176.
     and *note mps_telemetry_reset(): 2b4. instead.

  7. The keyword argument ‘MPS_KEY_SPARE_COMMIT_LIMIT’ to *note
     mps_arena_create_k(): 52, and the functions *note
     mps_arena_spare_commit_limit(): 320. and *note
     mps_arena_spare_commit_limit_set(): 321. are now deprecated.  Use
     ‘MPS_KEY_SPARE’, *note mps_arena_spare(): 189. and *note
     mps_arena_spare_set(): 198. instead.

  8. The format of the *note telemetry stream: ba. has changed: Booleans
     are no longer packed into bitfields, but are emitted as unsigned
     bytes.  This makes it possible to decode the telemetry stream using
     the Python function struct.unpack()(1).

  9. The functions ‘mps_formatted_objects_walk()’ and *note
     mps_amc_apply(): 324. are deprecated in favour of the new function
     *note mps_pool_walk(): 1a6.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/struct.html#struct.unpack


File: MemoryPoolSystem.info,  Node: Other changes,  Prev: Interface changes,  Up: Release 1 118 0

12.1.3 Other changes
--------------------

  1. On FreeBSD and Linux, if the MPS handles a signal while the client
     program is blocked in a system call, the system call is
     automatically restarted and does not fail with ‘EINTR’.  See *note
     Signal and exception handling issues: d1.

  2. On FreeBSD and Linux, the MPS signal handlers no longer modify
     ‘errno’.  See GitHub issue #10(1).

  3. The MPS now builds with Clang 10 and
     ‘-Wimplicit-int-float-conversion’.  See GitHub issue #51(2).

  4. The MPS now builds with ‘clang -Wcomma’.  See GitHub issue #47(3).

   ---------- Footnotes ----------

   (1) https://github.com/Ravenbrook/mps/issues/10

   (2) https://github.com/Ravenbrook/mps/issues/51

   (3) https://github.com/Ravenbrook/mps/issues/47


File: MemoryPoolSystem.info,  Node: Release 1 117 0,  Next: Release 1 116 0,  Prev: Release 1 118 0,  Up: Release notes

12.2 Release 1.117.0
====================

* Menu:

* New features: New features<2>.
* Interface changes: Interface changes<2>.
* Other changes: Other changes<2>.


File: MemoryPoolSystem.info,  Node: New features<2>,  Next: Interface changes<2>,  Up: Release 1 117 0

12.2.1 New features
-------------------

  1. On FreeBSD, Linux and macOS, the MPS is now able to run in the
     child process after ‘fork()’.  See *note Fork safety: 1ff.

  2. The MPS now supports Windows Vista or later; it no longer supports
     Windows XP. (Microsoft’s own support for Windows XP expired in
     April 2014(1).)  This is so that we can use
     InitOnceExecuteOnce()(2) to ensure thread-safe initialization.

   ---------- Footnotes ----------

   (1) 
https://www.microsoft.com/en-gb/windowsforbusiness/end-of-xp-support

   (2) 
https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-initonceexecuteonce


File: MemoryPoolSystem.info,  Node: Interface changes<2>,  Next: Other changes<2>,  Prev: New features<2>,  Up: Release 1 117 0

12.2.2 Interface changes
------------------------

  1. The pool class MV (Manual Variable) is now deprecated.


File: MemoryPoolSystem.info,  Node: Other changes<2>,  Prev: Interface changes<2>,  Up: Release 1 117 0

12.2.3 Other changes
--------------------

  1. References from the MPS’s own stack frames no longer *note pin:
     1e5. objects allocated by the *note client program: d0. in moving
     pools, which prevented them from moving.  See job003525(1).

  2. Creation of *note arenas: 16. is now thread-safe on Windows.  See
     job004056(2).

  3. *note AWL (Automatic Weak Linked): fe. and *note LO (Leaf Object):
     353. pools now detect (and assert on) invalid *note exact
     references: 61.  See job004070(3).

  4. The MPS now compiles without warnings on GCC version 7 with
     ‘-Wextra’.  See job004076(4).

  5. Deprecated function *note mps_arena_roots_walk(): 19e. no longer
     causes *note mps_arena_formatted_objects_walk(): 322. to miss some
     objects.  See job004090(5).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003525/

   (2) https://www.ravenbrook.com/project/mps/issue/job004056/

   (3) https://www.ravenbrook.com/project/mps/issue/job004070/

   (4) https://www.ravenbrook.com/project/mps/issue/job004076/

   (5) https://www.ravenbrook.com/project/mps/issue/job004090/


File: MemoryPoolSystem.info,  Node: Release 1 116 0,  Next: Release 1 115 0,  Prev: Release 1 117 0,  Up: Release notes

12.3 Release 1.116.0
====================

* Menu:

* New features: New features<3>.
* Interface changes: Interface changes<3>.
* Other changes: Other changes<3>.


File: MemoryPoolSystem.info,  Node: New features<3>,  Next: Interface changes<3>,  Up: Release 1 116 0

12.3.1 New features
-------------------

  1. The MPS now measures the mortality of a *note generation: e1. each
     time it is *note collected: 163a, and maintains a moving average.
     This means that it is no longer important to provide an accurate
     estimate of the mortality when creating a *note generation chain:
     e2. by calling *note mps_chain_create(): 225.

  2. The MPS no longer supports Linux 2.4 and 2.5.  (These versions used
     LinuxThreads(1) instead of POSIX threads; all major distributions
     have long since ceased to support these versions and so it is no
     longer convenient to test against them.)  See *note Supported
     target platforms: 12.

  3. New function *note mps_arena_postmortem(): d6. assists with
     postmortem debugging.

  4. New function *note mps_arena_busy(): 1a7. assists debugging of
     re-entry errors in dynamic function table callbacks on Windows on
     x86-64.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/LinuxThreads


File: MemoryPoolSystem.info,  Node: Interface changes<3>,  Next: Other changes<3>,  Prev: New features<3>,  Up: Release 1 116 0

12.3.2 Interface changes
------------------------

  1. The pool class *note SNC (Stack No Checking): 27b. is no longer
     deprecated.

  2. Allocation frames are no longer deprecated.  See *note Allocation
     frames: 27a.

  3. On Linux and FreeBSD, it is now possible to configure the signals
     used to suspend and resume threads.  See *note Signal and exception
     handling issues: d1.


File: MemoryPoolSystem.info,  Node: Other changes<3>,  Prev: Interface changes<3>,  Up: Release 1 116 0

12.3.3 Other changes
--------------------

  1. It is now possible to register a *note thread: 99. with the MPS
     multiple times on OS X, thus supporting the use case where a
     program that does not use the MPS is calling into MPS-using code
     from multiple threads.  (This was already supported on other
     platforms.)  See job003559(1).

  2. The function *note mps_arena_formatted_objects_walk(): 322. walks
     the *note formatted objects: 23. in all *note pools: 18.
     Previously this was not implemented for *note AMS (Automatic Mark
     and Sweep): 16c. pools.  See job003738(2).

  3. Objects in *note SNC (Stack No Checking): 27b. pools are no longer
     scanned after their *note allocation frame: 27d. is popped, and so
     do not keep objects in automatically managed pools alive.  See
     job003883(3).

  4. When the MPS *note collects: 163a. a set of *note generations: e1,
     it *note condemns: 221. only the *note blocks: 185. in those
     generations.  Previously, it also condemned blocks that happened to
     share a region of memory with blocks currently or formerly
     allocated in those generations.  See job004000(4).

  5. Memory in *note allocation points: 63. no longer contributes to the
     decision to start a *note garbage collection: f, avoiding wasted
     work repeatedly collecting generations with very small capacities.
     See job004007(5).

  6. The MPS no longer considers *note collecting: 163a. the world
     again, without allowing the *note client program: d0. to run first.
     See job004011(6).

  7. *note Roots: 97. created by *note mps_root_create_thread_scanned():
     219. no longer cause an assertion failure.  See job004036(7).

  8. The MPS test suite now compiles and passes with GCC 6.1.  See
     job004037(8).

  9. The MPS no longer passes an uninitialized variable to
     ‘thread_swap_exception_ports()’ on OS X. See job004040(9).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003559/

   (2) https://www.ravenbrook.com/project/mps/issue/job003738/

   (3) https://www.ravenbrook.com/project/mps/issue/job003883/

   (4) https://www.ravenbrook.com/project/mps/issue/job004000/

   (5) https://www.ravenbrook.com/project/mps/issue/job004007/

   (6) https://www.ravenbrook.com/project/mps/issue/job004011/

   (7) https://www.ravenbrook.com/project/mps/issue/job004036/

   (8) https://www.ravenbrook.com/project/mps/issue/job004037/

   (9) https://www.ravenbrook.com/project/mps/issue/job004040/


File: MemoryPoolSystem.info,  Node: Release 1 115 0,  Next: Release 1 114 0,  Prev: Release 1 116 0,  Up: Release notes

12.4 Release 1.115.0
====================

* Menu:

* New features: New features<4>.
* Interface changes: Interface changes<4>.
* Other changes: Other changes<4>.


File: MemoryPoolSystem.info,  Node: New features<4>,  Next: Interface changes<4>,  Up: Release 1 115 0

12.4.1 New features
-------------------

  1. The MPS now provides control over the maximum time that operations
     within an arena may pause the *note client program: d0. for.  This
     can be specified by the new function *note
     mps_arena_pause_time_set(): 180. or by passing the new keyword
     argument ‘MPS_KEY_PAUSE_TIME’ to *note mps_arena_create_k(): 52.
     The current value can be retrieved by the new function *note
     mps_arena_pause_time(): 193.

     The maximum pause time defaults to 0.1 seconds.  For the old
     behaviour (whereby the MPS always returned to the *note client
     program: d0. as soon as possible), set it to zero.

  2. New supported platforms ‘fri3ll’ (FreeBSD, IA-32, Clang/LLVM) and
     ‘fri6ll’ (FreeBSD, x86-64, Clang/LLVM).

  3. When creating an *note AMC (Automatic Mostly-Copying): 62. pool,
     *note mps_pool_create_k(): 166. accepts the new keyword argument
     ‘MPS_KEY_EXTEND_BY’, specifying the minimum size of the memory
     segments that the pool requests from the *note arena: 16.

  4. The function *note mps_arena_create_k(): 52. accepts two new *note
     keyword arguments: 53.  ‘MPS_KEY_COMMIT_LIMIT’ sets the *note
     commit limit: 156. for the arena, and ‘MPS_KEY_SPARE_COMMIT_LIMIT’
     sets the *note spare commit limit: 197. for the arena.

  5. New area scanning functions *note mps_scan_area(): 1ef, *note
     mps_scan_area_masked(): 1f2, *note mps_scan_area_tagged(): 1f3,
     *note mps_scan_area_tagged_or_zero(): 1f4. for use when scanning,
     especially when scanning threads and *note tagged references: 7d.

  6. New thread root functions *note mps_root_create_thread(): a9, *note
     mps_root_create_thread_tagged(): 1ec, and *note
     mps_root_create_thread_scanned(): 219. allow flexible scanning of
     thread stacks and registers in any format, with convenient
     implementations provided for *note tagged references: 7d.

  7. New function *note mps_root_create_table_tagged(): 330. for tables
     of roots containing *note tagged references: 7d.

  8. New area root functions *note mps_root_create_area(): 206. and
     *note mps_root_create_area_tagged(): 21a. for areas of memory that
     can be scanned by area scanning functions.


File: MemoryPoolSystem.info,  Node: Interface changes<4>,  Next: Other changes<4>,  Prev: New features<4>,  Up: Release 1 115 0

12.4.2 Interface changes
------------------------

  1. The pool class MV (Manual Variable) is no longer deprecated.

  2. The type of pool classes is now *note mps_pool_class_t: 1b4.  The
     old name *note mps_class_t: 328. is still available via a
     ‘typedef’, but is deprecated.

  3. The functions ‘mps_mv_free_size’, ‘mps_mv_size’, *note
     mps_mvff_free_size(): 329, *note mps_mvff_size(): 32a, *note
     mps_mvt_free_size(): 32b. and *note mps_mvt_size(): 32c. are now
     deprecated in favour of the generic functions *note
     mps_pool_free_size(): 1b7. and *note mps_pool_total_size(): 1b6.

  4. The function *note mps_root_create_reg(): 32d. is deprecated in
     favour of *note mps_root_create_thread_tagged(): 1ec.

  5. The function *note mps_root_create_table_masked(): 331. is
     deprecated in favour of *note mps_root_create_table_tagged(): 330.

  6. The *note SNC (Stack No Checking): 27b. pool class now implements
     *note mps_pool_total_size(): 1b6. and *note mps_pool_free_size():
     1b7.

  7. The (undocumented) reservoir functions
     ‘mps_ap_fill_with_reservoir_permit()’, ‘mps_reservoir_available()’,
     ‘mps_reservoir_limit()’, ‘mps_reservoir_limit_set()’, and
     ‘mps_reserve_with_reservoir_permit()’, together with the
     ‘has_reservoir_permit’ arguments to *note mps_sac_alloc(): 25f. and
     *note MPS_SAC_ALLOC_FAST(): 260. are now deprecated.


File: MemoryPoolSystem.info,  Node: Other changes<4>,  Prev: Interface changes<4>,  Up: Release 1 115 0

12.4.3 Other changes
--------------------

  1. *note mps_arena_committed(): 18e. now returns a meaningful value
     (the amount of memory marked as in use in the page tables) for
     *note client arenas: 4d.  See job001887(1).

  2. *note AMC (Automatic Mostly-Copying): 62. pools now assert that
     exact references into the pool are aligned to the pool’s alignment.
     See job002175(2).

  3. Internal calculation of the address space available to the MPS no
     longer takes time proportional to the number of times the arena has
     been extended, speeding up allocation when memory is tight.  See
     job003814(3).

  4. Setting ‘MPS_KEY_SPARE’ for a *note MVFF (Manual Variable First
     Fit): 10c. pool now works.  See job003870(4).

  5. In the *note hot: 162. (production) variety, *note
     mps_pool_free_size(): 1b7. now returns the correct result for *note
     AWL (Automatic Weak Linked): fe. and *note LO (Leaf Object): 353.
     pools.  See job003884(5).

  6. When the arena is out of memory and cannot be extended without
     hitting the *note commit limit: 156, the MPS now returns *note
     MPS_RES_COMMIT_LIMIT: 155. rather than substituting *note
     MPS_RES_RESOURCE: 153.  See job003899(6).

  7. Unfinalizable objects can no longer be registered for finalization.
     Previously the objects would be registered but never finalized.
     See job003865(7).

  8. *note mps_arena_has_addr(): d2. now returns the correct result for
     objects allocated from the *note MFS (Manual Fixed Small): 355, MV
     (Manual Variable), and *note MVFF (Manual Variable First Fit): 10c.
     pools.  See job003866(8).

  9. The MPS can now make use of *note spare committed memory: 18f. even
     if it is *note mapped: 190. at an unhelpful address, by unmapping
     it and remapping at a better address.  See job003898(9).

  10. *note mps_arena_step(): 19c. now always considers starting a new
     *note garbage collection: f. if the remaining idle time is long
     enough to complete it.  (Previously, if there was already a
     collection in progress when *note mps_arena_step(): 19c. was
     called, it would finish the collection but not consider starting a
     new one.)  See job003934(10).

  11. The MPS no longer carries out *note garbage collections: f. when
     there is no collection work to be done.  See job003938(11).

  12. The MPS is less aggressive in its use of hardware memory
     protection to maintain *note write barrier: 214. to speed up future
     collections.  This is particularly important for OS X, where memory
     protection operations are very expensive.  See job003371(12) and
     job003975(13).

  13. The MPS coalesces memory protection, reducing the number of system
     calls.  This markedly improves real run time on operating systems
     where memory protection operations are very expensive, such as OS
     X, but also has a significant effect on Linux.  See job003371(14)
     and job003975(15).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job001887/

   (2) https://www.ravenbrook.com/project/mps/issue/job002175/

   (3) https://www.ravenbrook.com/project/mps/issue/job003814/

   (4) https://www.ravenbrook.com/project/mps/issue/job003870/

   (5) https://www.ravenbrook.com/project/mps/issue/job003884/

   (6) https://www.ravenbrook.com/project/mps/issue/job003899/

   (7) https://www.ravenbrook.com/project/mps/issue/job003865/

   (8) https://www.ravenbrook.com/project/mps/issue/job003866/

   (9) https://www.ravenbrook.com/project/mps/issue/job003898/

   (10) https://www.ravenbrook.com/project/mps/issue/job003934/

   (11) https://www.ravenbrook.com/project/mps/issue/job003938/

   (12) https://www.ravenbrook.com/project/mps/issue/job003371/

   (13) https://www.ravenbrook.com/project/mps/issue/job003975/

   (14) https://www.ravenbrook.com/project/mps/issue/job003371/

   (15) https://www.ravenbrook.com/project/mps/issue/job003975/


File: MemoryPoolSystem.info,  Node: Release 1 114 0,  Next: Release 1 113 0,  Prev: Release 1 115 0,  Up: Release notes

12.5 Release 1.114.0
====================

* Menu:

* New features: New features<5>.
* Interface changes: Interface changes<5>.
* Other changes: Other changes<5>.


File: MemoryPoolSystem.info,  Node: New features<5>,  Next: Interface changes<5>,  Up: Release 1 114 0

12.5.1 New features
-------------------

  1. *note Ambiguous: 9f. *note interior pointers: 1ac. now keep objects
     in *note AMC (Automatic Mostly-Copying): 62. and *note AMCZ
     (Automatic Mostly-Copying Zero-rank): 89. pools alive.

     This means that if the compiler optimizes away a pointer to the
     base of an object, leaving an interior pointer as the only
     reference keeping the object alive, this does not cause the object
     to be incorrectly collected.  Or, if you are writing your own
     compiler, you can now perform such an optimization safely.

     If you require the old behaviour (in which ambiguous interior
     pointers were ignored) then you can set the ‘MPS_KEY_INTERIOR’
     keyword argument to ‘FALSE’ when calling *note mps_pool_create_k():
     166.

  2. The logic for deciding which generations should be collected has
     changed.  Now, a chain may be scheduled for collection if the new
     size of 'any' of its generations exceeds its capacity, and when a
     chain is collected, all generations are collected up to, and
     including, the highest generation whose new size exceeds its
     capacity.  This ensures that all generations are collected reliably
     on chains where there is no allocation into the nursery generation.
     See *note Scheduling of collections: 226.

     (Previously, only the nursery generation in each chain was
     considered, and a chain was collected up to, but not including, the
     lowest generation whose new size was within its capacity.)

     As a result of this change, we recommend that you retune your
     generation sizes.  (This is not necessary, but may improve
     performance.)

  3. New pool introspection functions *note mps_pool_free_size(): 1b7.
     and *note mps_pool_total_size(): 1b6.


File: MemoryPoolSystem.info,  Node: Interface changes<5>,  Next: Other changes<5>,  Prev: New features<5>,  Up: Release 1 114 0

12.5.2 Interface changes
------------------------

  1. The granularity with which the arena manages memory can now be
     specified using the ‘MPS_KEY_ARENA_GRAIN_SIZE’ keyword argument to
     *note mps_arena_create_k(): 52.  See *note mps_arena_class_cl():
     4e. and *note mps_arena_class_vm(): 50.

  2. There is now a default value (currently 256 *note megabytes: 186.)
     for the ‘MPS_KEY_ARENA_SIZE’ keyword argument to *note
     mps_arena_create_k(): 52. when creating a virtual memory arena.
     See *note mps_arena_class_vm(): 50.

  3. The keyword argument ‘MPS_KEY_AMS_SUPPORT_AMBIGUOUS’ now defaults
     to ‘TRUE’ in order to better support the general case: the value
     ‘FALSE’ is appropriate only when you know that all references are
     exact.  See *note AMS (Automatic Mark and Sweep): 16c.

  4. There is now a default value for the ‘MPS_KEY_AWL_FIND_DEPENDENT’
     keyword argument to *note mps_pool_create_k(): 166. when creating
     an *note AWL (Automatic Weak Linked): fe. pool.  The default value
     is a function that always returns ‘NULL’ (meaning that there is no
     dependent object).

  5. It is now possible to configure the alignment of objects allocated
     in an MV (Manual Variable) pool, by passing the ‘MPS_KEY_ALIGN’
     keyword argument to *note mps_pool_create_k(): 166.

  6. The *note MVFF (Manual Variable First Fit): 10c. pool class takes a
     new keyword argument ‘MPS_KEY_SPARE’.  This specifies the maximum
     proportion of memory that the pool will keep spare for future
     allocations.

  7. The alignment requirements for *note MVFF (Manual Variable First
     Fit): 10c. and *note MVT (Manual Variable Temporal): 1bc. pools
     have been relaxed on the platforms ‘w3i3mv’ and ‘w3i6mv’.  On all
     platforms it is now possible to specify alignments down to
     ‘sizeof(void *)’ as the alignment for pools of these classes.

  8. The sizes of the templates in a *note mps_pool_debug_option_s: 143.
     structure no longer have to be related to the alignment of the
     pools that they are used with.  This makes it easier to reuse these
     structures.


File: MemoryPoolSystem.info,  Node: Other changes<5>,  Prev: Interface changes<5>,  Up: Release 1 114 0

12.5.3 Other changes
--------------------

  1. The *note AMS (Automatic Mark and Sweep): 16c. pool class no longer
     triggers the assertion ‘!AMS_IS_INVALID_COLOUR(seg, i)’ under rare
     circumstances (namely, detaching an *note allocation point: 63.
     from a *note grey: 1696. segment when
     ‘MPS_KEY_AMS_SUPPORT_AMBIGUOUS’ is ‘FALSE’).  See job001549(1).

  2. *note mps_arena_roots_walk(): 19e. no longer triggers an assertion
     failure when run twice in succession.  See job003496(2).

  3. The alignment of *note AWL (Automatic Weak Linked): fe. pools is
     now configurable via the object format, as documented, and is no
     longer always *note MPS_PF_ALIGN: 6f.  See job003745(3).

  4. The debugging version of the *note MVFF (Manual Variable First
     Fit): 10c. pool class, *note mps_class_mvff_debug(): 145, no longer
     triggers an assertion failure if you allocate a large object.  See
     job003751(4).

  5. ‘mpseventtxt’ now successfully processes a telemetry log containing
     multiple labels associated with the same address.  See
     job003756(5).

  6. *note AMS (Automatic Mark and Sweep): 16c, *note AWL (Automatic
     Weak Linked): fe. and *note LO (Leaf Object): 353. pools get
     reliably collected, even in the case where the pool is the only
     pool on its generation chain and is allocating into some generation
     other than the nursery.  See job003771(6).

  7. Allocation into *note AWL (Automatic Weak Linked): fe. pools again
     reliably provokes garbage collections of the generation that the
     pool belongs to.  (In version 1.113, the generation would only be
     collected if a pool of some other class allocated into it.)  See
     job003772(7).

  8. All unreachable objects in *note LO (Leaf Object): 353. pools are
     finalized.  (Previously, objects on a segment attached to an
     allocation point were not finalized until the allocation point was
     full.)  See job003773(8).

  9. The *note MVT (Manual Variable Temporal): 1bc. and *note MVFF
     (Manual Variable First Fit): 10c. pool classes are now around 25%
     faster (in our benchmarks) than they were in version 1.113.

  10. The default assertion handler in the default *note plinth: 160.
     now flushes the telemetry stream before aborting.  See *note
     mps_lib_assert_fail(): 161.

  11. Garbage collection performance is substantially improved in the
     situation where the arena has been extended many times.  Critical
     operations now take time logarithmic in the number of times the
     arena has been extended (rather than linear, as in version 1.113
     and earlier).  See job003554(9).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job001549/

   (2) https://www.ravenbrook.com/project/mps/issue/job003496/

   (3) https://www.ravenbrook.com/project/mps/issue/job003745/

   (4) https://www.ravenbrook.com/project/mps/issue/job003751/

   (5) https://www.ravenbrook.com/project/mps/issue/job003756/

   (6) https://www.ravenbrook.com/project/mps/issue/job003771/

   (7) https://www.ravenbrook.com/project/mps/issue/job003772/

   (8) https://www.ravenbrook.com/project/mps/issue/job003773/

   (9) https://www.ravenbrook.com/project/mps/issue/job003554/


File: MemoryPoolSystem.info,  Node: Release 1 113 0,  Next: Release 1 112 0,  Prev: Release 1 114 0,  Up: Release notes

12.6 Release 1.113.0
====================

* Menu:

* New features: New features<6>.
* Interface changes: Interface changes<6>.
* Other changes: Other changes<6>.


File: MemoryPoolSystem.info,  Node: New features<6>,  Next: Interface changes<6>,  Up: Release 1 113 0

12.6.1 New features
-------------------

  1. In previous releases there was an implicit connection between
     blocks allocated by *note AWL (Automatic Weak Linked): fe. and
     *note LO (Leaf Object): 353. pools, and blocks allocated by other
     automatically managed pool classes.

     In particular, blocks allocated by AWL and LO pools were garbage
     collected together with blocks allocated by *note AMS (Automatic
     Mark and Sweep): 16c. pools, and blocks allocated by *note AMC
     (Automatic Mostly-Copying): 62. pools in generation 1 of their
     chains.

     This is no longer the case: to arrange for blocks to be collected
     together you need to ensure that they are allocated in the 'same'
     generation chain, using the ‘MPS_KEY_CHAIN’ and ‘MPS_KEY_GEN’
     keyword arguments to *note mps_pool_create_k(): 166.

     So if you have code like this:

          res = mps_pool_create(&my_amc, arena, mps_class_amc(), my_chain);
          res = mps_pool_create(&my_awl, arena, mps_class_awl());

     and you want to retain the connection between these pools, then you
     must ensure that they use the same generation chain:

          MPS_ARGS_BEGIN(args) {
            MPS_ARGS_ADD(args, MPS_KEY_CHAIN, my_chain);
            res = mps_pool_create_k(&my_amc, arena, mps_class_amc(), args);
          } MPS_ARGS_END(args);

          MPS_ARGS_BEGIN(args) {
            MPS_ARGS_ADD(args, MPS_KEY_CHAIN, my_chain);
            MPS_ARGS_ADD(args, MPS_KEY_GEN, 1);
            res = mps_pool_create_k(&my_awl, arena, mps_class_awl(), args);
          } MPS_ARGS_END(args);


File: MemoryPoolSystem.info,  Node: Interface changes<6>,  Next: Other changes<6>,  Prev: New features<6>,  Up: Release 1 113 0

12.6.2 Interface changes
------------------------

  1. When creating a list of keyword arguments, there is no longer any
     need to call *note MPS_ARGS_DONE(): 333.  See *note Keyword
     arguments: 57.

  2. When creating an automatically managed pool using *note
     mps_pool_create_k(): 166, it is no longer necessary to pass in a
     generation chain.  The arena has a default generation chain and
     this is used by all automatically managed pools where no generation
     chain was specified.

  3. It is now possible to specify a generation chain for *note AWL
     (Automatic Weak Linked): fe. and *note LO (Leaf Object): 353. pool
     classes, by using the optional ‘MPS_KEY_CHAIN’ keyword argument to
     *note mps_pool_create_k(): 166.

  4. It is now possible to specify which generation the *note AMS
     (Automatic Mark and Sweep): 16c, *note AWL (Automatic Weak Linked):
     fe, and *note LO (Leaf Object): 353. pool classes allocate new
     objects into, using the optional ‘MPS_KEY_GEN’ keyword argument to
     *note mps_pool_create_k(): 166.


File: MemoryPoolSystem.info,  Node: Other changes<6>,  Prev: Interface changes<6>,  Up: Release 1 113 0

12.6.3 Other changes
--------------------

  1. The MPS now retains some unused memory instead of returning it to
     the operating system.  This reduces unnecessary overhead due to
     system calls, thrashing the operating system’s page table, and
     zeroing memory when re-allocated.  See job003700(1).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003700/


File: MemoryPoolSystem.info,  Node: Release 1 112 0,  Next: Release 1 111 0,  Prev: Release 1 113 0,  Up: Release notes

12.7 Release 1.112.0
====================

* Menu:

* New features: New features<7>.
* Interface changes: Interface changes<7>.
* Other changes: Other changes<7>.


File: MemoryPoolSystem.info,  Node: New features<7>,  Next: Interface changes<7>,  Up: Release 1 112 0

12.7.1 New features
-------------------

  1. New supported platform ‘lii6ll’ (Linux, x86-64, Clang/LLVM).

  2. On Windows, you can now request that the MPS allocate address space
     from the top down, allowing a 32-bit executable linked with
     ‘/LARGEADDRESSAWARE’ to use the top half of the address space.  Use
     the keyword argument ‘MPS_KEY_VMW3_TOP_DOWN’ when creating an arena
     of class *note mps_arena_class_vm(): 50.

  3. On OS X, multi-threaded programs are now supported.  See *note
     Threads: 29.

  4. On OS X, you can now debug the MPS using ‘lldb’.


File: MemoryPoolSystem.info,  Node: Interface changes<7>,  Next: Other changes<7>,  Prev: New features<7>,  Up: Release 1 112 0

12.7.2 Interface changes
------------------------

  1. In the *note hot: 162. (production) variety, the default assertion
     handler now prints messages to standard error but does 'not'
     terminate the program.  Even though assertions indicate serious
     problems in the program, an end-user does not always want an
     application to terminate when there is a chance to shut down safely
     and save work, or even to limp along indefinitely.  See *note
     Assertion handling: 15f.

  2. The behaviour when an assertion is triggered is now configurable in
     the default *note plinth: 160. by installing an assertion handler.
     See *note mps_lib_assert_fail_install(): 164.

  3. Functions that take a variable number of arguments (*note
     mps_arena_create(): 335, *note mps_pool_create(): 337, *note
     mps_ap_create(): 339.) and their ‘va_list’ alternatives (*note
     mps_arena_create_v(): 336. etc.)  are now deprecated in favour of
     functions that use a *note keyword argument: 53. interface (*note
     mps_arena_create_k(): 52, *note mps_pool_create_k(): 166, *note
     mps_ap_create_k(): af.).

     Similarly, the object format variant structures (*note mps_fmt_A_s:
     33b. etc.)  and the functions that take them as arguments (*note
     mps_fmt_create_A(): 33c. etc.)  are now deprecated in favour of
     *note mps_fmt_create_k(): 13f.

     The new interfaces provide better reporting of errors, default
     values for arguments, and forward compatibility.  See *note Keyword
     arguments: 57.

     The old interfaces continue to be supported for now, but new
     features will become available through the keyword interface only.

  4. *note MFS (Manual Fixed Small): 355. pools no longer refuse to
     manage blocks that are smaller than the platform alignment.  They
     now round up smaller sizes internally if necessary.

  5. *note MVT (Manual Variable Temporal): 1bc. pools now allow the
     client to specify the alignment of blocks.  Use the keyword
     argument ‘MPS_KEY_ALIGN’ when creating a pool of class *note
     mps_class_mvt(): 137.

  6. On OS X, signals are no longer used for handling memory protection
     exceptions.  This means that programs are free to handle ‘SIGBUS’,
     but must not install a thread-local Mach exception handler for
     ‘EXC_BAD_ACCESS’ exceptions.  See *note Signal and exception
     handling issues: d1.

  7. On OS X, when debugging with ‘gdb’, you no longer need to turn on
     ‘dont-handle-bad-access’ or to request special handling of
     ‘SIGBUS’.


File: MemoryPoolSystem.info,  Node: Other changes<7>,  Prev: Interface changes<7>,  Up: Release 1 112 0

12.7.3 Other changes
--------------------

  1. On Windows, an execute exception no longer triggers an assertion.
     See job003301(1).

  2. Rehashing of large address-based hash tables no longer provokes a
     nursery collection that immediately renders the hash table stale
     again.  See job003435(2).

  3. An *note MVT (Manual Variable Temporal): 1bc. pool no longer
     triggers an assertion failure when it runs out of space on its
     reserved block queue.  See job003486(3).

  4. The ‘-i’ and ‘-o’ options no longer cause ‘mpseventsql’ to crash.
     See job003507(4).

  5. On Windows, telemetry files now have correct clock values.
     Previously the top 32 bits were incorrectly output as zero.  See
     job003519(5).

  6. On 64-bit Windows, it’s no longer possible to get a stack overflow
     exception while the MPS is holding the arena lock.  See
     job003640(6).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003301/

   (2) https://www.ravenbrook.com/project/mps/issue/job003435/

   (3) https://www.ravenbrook.com/project/mps/issue/job003486/

   (4) https://www.ravenbrook.com/project/mps/issue/job003507/

   (5) https://www.ravenbrook.com/project/mps/issue/job003519/

   (6) https://www.ravenbrook.com/project/mps/issue/job003640/


File: MemoryPoolSystem.info,  Node: Release 1 111 0,  Next: Release 1 110 0,  Prev: Release 1 112 0,  Up: Release notes

12.8 Release 1.111.0
====================

* Menu:

* New features: New features<8>.
* Interface changes: Interface changes<8>.
* Other changes: Other changes<8>.


File: MemoryPoolSystem.info,  Node: New features<8>,  Next: Interface changes<8>,  Up: Release 1 111 0

12.8.1 New features
-------------------

  1. Reporting features have been removed from the *note mpseventcnv:
     28e. utility.  Instead, the telemetry system comes with two new
     utility programs to assist with reporting and analysis: *note
     mpseventtxt: 28f. converts an event stream into human-readable
     form, and *note mpseventsql: 290. loads an event stream into a
     SQLite database for further analysis.  See *note Telemetry: db.

  2. The new pool class *note MFS (Manual Fixed Small): 355. provides
     manually managed allocation of fixed-size objects.

  3. The new pool class *note MVT (Manual Variable Temporal): 1bc.
     provides manually managed allocation of variable-size objects using
     a 'temporal fit' allocation policy (that is, objects that are
     allocated together are expected to be freed together).


File: MemoryPoolSystem.info,  Node: Interface changes<8>,  Next: Other changes<8>,  Prev: New features<8>,  Up: Release 1 111 0

12.8.2 Interface changes
------------------------

  1. It is no longer necessary for client programs to use ‘mps_tramp()’
     to ensure that exceptions due to barrier hits are caught.  This
     function is now deprecated.

  2. You can set the environment variable *note MPS_TELEMETRY_CONTROL:
     288. to ‘all’ to make the telemetry system output all events.  See
     *note Telemetry: db.

  3. New functions *note mps_telemetry_get(): 2b3, *note
     mps_telemetry_set(): 176. and *note mps_telemetry_reset(): 2b4.
     provide a more convenient interface to telemetry control than
     ‘mps_telemetry_control()’, which is now deprecated.  See *note
     Telemetry: db.

  4. The pool classes MV (Manual Variable) and *note SNC (Stack No
     Checking): 27b. are now deprecated.

  5. Allocation frames are now deprecated.  See *note Allocation frames:
     27a.

  6. Additionally, the functions ‘mps_arena_expose()’,
     ‘mps_arena_unsafe_expose_remember_protection()’,
     ‘mps_arena_unsafe_restore_protection()’, *note
     mps_arena_roots_walk(): 19e, and ‘mps_fix()’ are now deprecated.


File: MemoryPoolSystem.info,  Node: Other changes<8>,  Prev: Interface changes<8>,  Up: Release 1 111 0

12.8.3 Other changes
--------------------

  1. *note mps_arena_step(): 19c. no longer unclamps the arena as a side
     effect.  If the arena is clamped or parked before calling *note
     mps_arena_step(): 19c, it is clamped afterwards.  See job003320(1).

  2. The ambiguous stack scanner, *note mps_stack_scan_ambig(): 32f, no
     longer asserts on Linux when there are multiple threads.  See
     job003412(2).

  3. It is no longer possible for the “ramp” allocation pattern, *note
     mps_alloc_pattern_ramp(): 26f, to get stuck.  Now *note
     mps_ap_alloc_pattern_end(): 274. reliably clears this pattern.  See
     job003454(3).

  4. The build system now correctly detects the FreeBSD operating system
     running on the x86-64 architecture, for FreeBSD version 9.1 or
     later.  See job003473(4).

   ---------- Footnotes ----------

   (1) https://www.ravenbrook.com/project/mps/issue/job003320/

   (2) https://www.ravenbrook.com/project/mps/issue/job003412/

   (3) https://www.ravenbrook.com/project/mps/issue/job003454/

   (4) https://www.ravenbrook.com/project/mps/issue/job003473/


File: MemoryPoolSystem.info,  Node: Release 1 110 0,  Prev: Release 1 111 0,  Up: Release notes

12.9 Release 1.110.0
====================

* Menu:

* New features: New features<9>.
* Interface changes: Interface changes<9>.


File: MemoryPoolSystem.info,  Node: New features<9>,  Next: Interface changes<9>,  Up: Release 1 110 0

12.9.1 New features
-------------------

  1. New supported platforms:

        * ‘fri6gc’ (FreeBSD, x86-64, GCC)

        * ‘lii6gc’ (Linux, x86-64, GCC)

        * ‘w3i6mv’ (Windows, x86-64, Microsoft Visual C)

        * ‘xci3ll’ (OS X, IA-32, Clang/LLVM)

        * ‘xci6gc’ (OS X, x86-64, GCC)

        * ‘xci6ll’ (OS X, x86-64, Clang/LLVM)

  2. Support removed for platforms:

        * ‘iam4cc’ (Irix 6, MIPS R4000, MIPSpro C)

        * ‘lii3eg’ (Linux, IA-32, EGCS)

        * ‘lippgc’ (Linux, PowerPC, GCC)

        * ‘o1alcc’ (OSF/1, Alpha, Digital C)

        * ‘o1algc’ (OSF/1, Alpha, GCC)

        * ‘s7ppmw’ (System 7, PowerPC, MetroWerks C)

        * ‘sos8gc’ (Solaris, SPARC 8, GCC)

        * ‘sos9sc’ (Solaris, SPARC 9, SunPro C)

        * ‘sus8gc’ (SunOS, SPARC 8, GCC)

        * ‘xcppgc’ (OS X, PowerPC, GCC)

  3. On Unix platforms, the MPS can now be built and installed by
     running ‘./configure && make install’.  See *note Building the
     Memory Pool System: 14.

  4. The MPS can be compiled in a single step via the new source file
     ‘mps.c’.  This also allows you to compile the MPS in the same
     compilation unit as your object format, allowing the compiler to
     perform global optimizations between the two.  See *note Building
     the Memory Pool System: 14.

  5. The set of build varieties has been reduced to three: the *note
     cool: c8. variety for development and debugging, the *note hot:
     162. variety for production, and the *note rash: 163. variety for
     people who like to live dangerously.  See *note Varieties: 170.

  6. The environment variable *note MPS_TELEMETRY_CONTROL: 288. can now
     be set to a space-separated list of event kinds.  See *note
     Telemetry: db.

  7. Telemetry output is now emitted to the file named by the
     environment variable *note MPS_TELEMETRY_FILENAME: 289, if it is
     set.  See *note Telemetry: db.


File: MemoryPoolSystem.info,  Node: Interface changes<9>,  Prev: New features<9>,  Up: Release 1 110 0

12.9.2 Interface changes
------------------------

  1. Deprecated constants ‘MPS_MESSAGE_TYPE_FINALIZATION’,
     ‘MPS_MESSAGE_TYPE_GC’ and ‘MPS_MESSAGE_TYPE_GC_START’ have been
     removed.  Use *note mps_message_type_finalization(): 236, *note
     mps_message_type_gc(): 18d. and *note mps_message_type_gc_start():
     22a. instead.

  2. Deprecated constants ‘MPS_RANK_AMBIG’, ‘MPS_RANK_EXACT’ and
     ‘MPS_RANK_WEAK’ have been removed.  Use *note mps_rank_ambig():
     20a, *note mps_rank_exact(): 9d. and *note mps_rank_weak(): 20c.
     instead.

  3. Deprecated functions with names starting ‘mps_space_’ have been
     removed.  Use the functions with names starting ‘mps_arena_’
     instead.


File: MemoryPoolSystem.info,  Node: Introduction to memory management,  Next: Home,  Prev: Release notes,  Up: Top

13 Introduction to memory management
************************************

* Menu:

* Overview: Overview<34>.
* Allocation techniques::
* Recycling techniques::
* Memory management in various languages::


File: MemoryPoolSystem.info,  Node: Overview<34>,  Next: Allocation techniques,  Up: Introduction to memory management

13.1 Overview
=============

Memory management is a complex field of computer science and there are
many techniques being developed to make it more efficient.  This guide
is designed to introduce you to some of the basic memory management
issues that programmers face.

This guide attempts to explain any terms it uses as it introduces them.
In addition, there is a *note Memory Management Glossary: 158e. of
memory management terms that gives fuller information; some terms are
linked to the relevant entries.

*note Memory management: 15dd. is usually divided into three areas,
although the distinctions are a little fuzzy:

   * *note Hardware memory management: 17af.

   * *note Operating system memory management: 17b0.

   * *note Application memory management: 17b1.

These are described in more detail below.  In most computer systems, all
three are present to some extent, forming layers between the user’s
program and the actual memory hardware.  The Memory Management Reference
is mostly concerned with application memory management.

* Menu:

* Hardware memory management::
* Operating system memory management::
* Application memory management::
* Memory management problems::
* Manual memory management::
* Automatic memory management::
* More information::


File: MemoryPoolSystem.info,  Node: Hardware memory management,  Next: Operating system memory management,  Up: Overview<34>

13.1.1 Hardware memory management
---------------------------------

Memory management at the hardware level is concerned with the electronic
devices that actually store data.  This includes things like *note RAM:
55. and *note memory caches: 1622.


File: MemoryPoolSystem.info,  Node: Operating system memory management,  Next: Application memory management,  Prev: Hardware memory management,  Up: Overview<34>

13.1.2 Operating system memory management
-----------------------------------------

In the operating system, memory must be allocated to user programs, and
reused by other programs when it is no longer required.  The operating
system can pretend that the computer has more memory than it actually
does, and also that each program has the machine’s memory to itself;
both of these are features of *note virtual memory: 51. systems.


File: MemoryPoolSystem.info,  Node: Application memory management,  Next: Memory management problems,  Prev: Operating system memory management,  Up: Overview<34>

13.1.3 Application memory management
------------------------------------

Application memory management involves supplying the memory needed for a
program’s objects and data structures from the limited resources
available, and recycling that memory for reuse when it is no longer
required.  Because application programs cannot in general predict in
advance how much memory they are going to require, they need additional
code to handle their changing memory requirements.

Application memory management combines two related tasks:

'Allocation'

     When the program requests a block of memory, the memory manager
     must allocate that block out of the larger blocks it has received
     from the operating system.  The part of the memory manager that
     does this is known as the *note allocator: 15ce.  There are many
     ways to perform allocation, a few of which are discussed in *note
     Allocation techniques: 17b5.

'Recycling'

     When memory blocks have been allocated, but the data they contain
     is no longer required by the program, then the blocks can be
     recycled for reuse.  There are two approaches to recycling memory:
     either the programmer must decide when memory can be reused (known
     as *note manual memory management: 8.); or the memory manager must
     be able to work it out (known as *note automatic memory management:
     9.).  These are both described in more detail below.

An application memory manager must usually work to several constraints,
such as:

'CPU overhead'

     The additional time taken by the memory manager while the program
     is running.

'Pause times'

     The time it takes for the memory manager to complete an operation
     and return control to the program.

     This affects the program’s ability to respond promptly to
     interactive events, and also to any asynchronous event such as a
     network connection.

'Memory overhead'

     How much space is wasted for administration, rounding (known as
     *note internal fragmentation: 379.), and poor layout (known as
     *note external fragmentation: 383.).

Some of the common problems encountered in application memory management
are considered in the next section.


File: MemoryPoolSystem.info,  Node: Memory management problems,  Next: Manual memory management,  Prev: Application memory management,  Up: Overview<34>

13.1.4 Memory management problems
---------------------------------

The basic problem in managing memory is knowing when to keep the data it
contains, and when to throw it away so that the memory can be reused.
This sounds easy, but is, in fact, such a hard problem that it is an
entire field of study in its own right.  In an ideal world, most
programmers wouldn’t have to worry about memory management issues.
Unfortunately, there are many ways in which poor memory management
practice can affect the robustness and speed of programs, both in manual
and in automatic memory management.

Typical problems include:

'Premature frees and dangling pointers'

     Many programs give up memory, but attempt to access it later and
     crash or behave randomly.  This condition is known as a *note
     premature free: 165c, and the surviving reference to the memory is
     known as a *note dangling pointer: 281.  This is usually confined
     to *note manual memory management: 8.

'Memory leak'

     Some programs continually allocate memory without ever giving it up
     and eventually run out of memory.  This condition is known as a
     *note memory leak: 234.

'External fragmentation'

     A poor allocator can do its job of giving out and receiving blocks
     of memory so badly that it can no longer give out big enough blocks
     despite having enough spare memory.  This is because the free
     memory can become split into many small blocks, separated by blocks
     still in use.  This condition is known as *note external
     fragmentation: 383.

'Poor locality of reference'

     Another problem with the layout of allocated blocks comes from the
     way that modern hardware and operating system memory managers
     handle memory: successive memory accesses are faster if they are to
     nearby memory locations.  If the memory manager places far apart
     the blocks a program will use together, then this will cause
     performance problems.  This condition is known as poor *note
     locality of reference: 1601.

'Inflexible design'

     Memory managers can also cause severe performance problems if they
     have been designed with one use in mind, but are used in a
     different way.  These problems occur because any memory management
     solution tends to make assumptions about the way in which the
     program is going to use memory, such as typical block sizes,
     reference patterns, or lifetimes of objects.  If these assumptions
     are wrong, then the memory manager may spend a lot more time doing
     bookkeeping work to keep up with what’s happening.

'Interface complexity'

     If objects are passed between modules, then the interface design
     must consider the management of their memory.

A well-designed memory manager can make it easier to write debugging
tools, because much of the code can be shared.  Such tools could display
objects, navigate links, validate objects, or detect abnormal
accumulations of certain object types or block sizes.


File: MemoryPoolSystem.info,  Node: Manual memory management,  Next: Automatic memory management,  Prev: Memory management problems,  Up: Overview<34>

13.1.5 Manual memory management
-------------------------------

Manual memory management is where the programmer has direct control over
when memory may be recycled.  Usually this is either by explicit calls
to *note heap: 47. management functions (for example, *note malloc: 1a.
and *note free (2): 1b. in *note C: 1c.), or by language constructs that
affect the *note control stack: 27. (such as local variables).  The key
feature of a manual memory manager is that it provides a way for the
program to say, “Have this memory back; I’ve finished with it”; the
memory manager does not recycle any memory without such an instruction.

The advantages of manual memory management are:

   * it can be easier for the programmer to understand exactly what is
     going on;

   * some manual memory managers perform better when there is a shortage
     of memory.

The disadvantages of manual memory management are:

   * the programmer must write a lot of code to do repetitive
     bookkeeping of memory;

   * memory management must form a significant part of any module
     interface;

   * manual memory management typically requires more memory overhead
     per object;

   * memory management bugs are common.

It is very common for programmers, faced with an inefficient or
inadequate manual memory manager, to write code to duplicate the
behavior of a memory manager, either by allocating large blocks and
splitting them for use, or by recycling blocks internally.  Such code is
known as a *note suballocator: 16b2.  Suballocators can take advantage
of special knowledge of program behavior, but are less efficient in
general than fixing the underlying allocator.  Unless written by a
memory management expert, suballocators may be inefficient or
unreliable.

The following languages use mainly manual memory management in most
implementations, although many have *note conservative garbage
collection: 349. extensions: *note Algol: 1637.; *note C: 1c.; *note
C++: 1d.; *note COBOL: 17ba.; *note Fortran: 17bb.; *note Pascal: 17bc.


File: MemoryPoolSystem.info,  Node: Automatic memory management,  Next: More information,  Prev: Manual memory management,  Up: Overview<34>

13.1.6 Automatic memory management
----------------------------------

Automatic memory management is a service, either as a part of the
language or as an extension, that automatically recycles memory that a
program would not otherwise use again.  Automatic memory managers (often
known as garbage collectors, or simply collectors) usually do their job
by recycling blocks that are *note unreachable: 21. from the program
variables (that is, blocks that cannot be reached by following
pointers).

The advantages of automatic memory management are:

   * the programmer is freed to work on the actual problem;

   * module interfaces are cleaner;

   * there are fewer memory management bugs;

   * memory management is often more efficient.

The disadvantages of automatic memory management are:

   * memory may be retained because it is reachable, but won’t be used
     again;

   * automatic memory managers (currently) have limited availability.

There are many ways of performing automatic recycling of memory, a few
of which are discussed in *note Recycling techniques: 17bf.

Most modern languages use mainly automatic memory management: *note
BASIC: 17c0, *note Dylan: 1752, Erlang, Haskell, *note Java: 167f, *note
JavaScript: 17c1, *note Lisp: 28a, *note ML: 168e, *note Modula-3: 168f,
*note Perl: 1680, *note PostScript: 1645, *note Prolog: 162b, Python,
*note Scheme: 46, *note Smalltalk: 1661, etc.


File: MemoryPoolSystem.info,  Node: More information,  Prev: Automatic memory management,  Up: Overview<34>

13.1.7 More information
-----------------------

For more detailed information on the topics covered briefly above,
please have a look at the *note Memory Management Glossary: 158e.  Books
and research papers are available on many specific techniques, and can
be found via our *note Bibliography: 14d7.; particularly recommended
are: *note Wilson (1994): 1579, which is survey of garbage collection
techniques; *note Wilson et al.  (1995): 157a, which is a survey of
allocation techniques; and *note Jones et al.  (2012): 1538, which is a
handbook covering all aspects of garbage collection.


File: MemoryPoolSystem.info,  Node: Allocation techniques,  Next: Recycling techniques,  Prev: Overview<34>,  Up: Introduction to memory management

13.2 Allocation techniques
==========================

Memory allocation is the process of assigning blocks of memory on
request.  Typically the *note allocator: 15ce. receives memory from the
operating system in a small number of large blocks that it must divide
up to satisfy the requests for smaller blocks.  It must also make any
returned blocks available for reuse.  There are many common ways to
perform this, with different strengths and weaknesses.  A few are
described briefly below.

   * *note First fit: 17c5.

   * *note Buddy system: 17c6.

   * *note Suballocators: 17c7.

These techniques can often be used in combination.

* Menu:

* First fit::
* Buddy system::
* Suballocators::


File: MemoryPoolSystem.info,  Node: First fit,  Next: Buddy system,  Up: Allocation techniques

13.2.1 First fit
----------------

In the *note first fit: 37f. algorithm, the allocator keeps a list of
free blocks (known as the *note free list: 268.) and, on receiving a
request for memory, scans along the list for the first block that is
large enough to satisfy the request.  If the chosen block is
significantly larger than that requested, then it is usually split, and
the remainder added to the list as another free block.

The first fit algorithm performs reasonably well, as it ensures that
allocations are quick.  When recycling free blocks, there is a choice as
to where to add the blocks to the free list—effectively in what order
the free list is kept:

'Memory location (address)'

     This is not fast for allocation or recycling, but supports
     efficient merging of adjacent free blocks (known as *note
     coalescence: 38c.).  According to *note Wilson et al.  (1995):
     157a, this ordering reduces *note fragmentation: 17e.  It can also
     improve *note locality of reference: 1601.

'Increasing size'

     This is equivalent to the *note best fit: 382. algorithm, in that
     the free block with the “tightest fit” is always chosen.  The fit
     is usually sufficiently tight that the remainder of the block is
     unusably small.

'Decreasing size'

     This is equivalent to the *note worst fit: 386. algorithm.  The
     first block on the free list will always be large enough, if a
     large enough block is available.  This approach encourages *note
     external fragmentation: 383, but allocation is very fast.

'Increasing time since last use'

     This is very fast at adding new free blocks, because they are added
     to the beginning of the list.  It encourages good *note locality of
     reference: 1601. (where blocks used together are not spread
     throughout memory), but can lead to bad external fragmentation.

A variation of first fit, known as *note next fit: 1681, continues each
search for a suitable block where the previous one left off, by using a
roving pointer into the free block chain.  This is not usually combined
with increasing or decreasing size ordering because it would eliminate
their advantages.


File: MemoryPoolSystem.info,  Node: Buddy system,  Next: Suballocators,  Prev: First fit,  Up: Allocation techniques

13.2.2 Buddy system
-------------------

In a *note buddy system: 15f9, the allocator will only allocate blocks
of certain sizes, and has many free lists, one for each permitted size.
The permitted sizes are usually either powers of two, or form a
Fibonacci sequence (see below for example), such that any block except
the smallest can be divided into two smaller blocks of permitted sizes.

When the allocator receives a request for memory, it rounds the
requested size up to a permitted size, and returns the first block from
that size’s free list.  If the free list for that size is empty, the
allocator splits a block from a larger size and returns one of the
pieces, adding the other to the appropriate free list.

When blocks are recycled, there may be some attempt to merge adjacent
blocks into ones of a larger permitted size (*note coalescence: 38c.).
To make this easier, the free lists may be stored in order of address.
The main advantage of the buddy system is that coalescence is cheap
because the “buddy” of any free block can be calculated from its
address.

 [image src="MemoryPoolSystem-figures/buddy1.svg" alt="Diagram: A binary buddy heap before allocation." ]


Figure: A binary buddy heap before allocation

 [image src="MemoryPoolSystem-figures/buddy2.svg" alt="Diagram: A binary buddy heap after allocating a 8 kB block." ]


Figure: A binary buddy heap after allocating a 8 kB block.

 [image src="MemoryPoolSystem-figures/buddy3.svg" alt="Diagram: A binary buddy heap after allocating a 10 kB block; note the 6 kB wasted because of rounding up." ]


Figure: A binary buddy heap after allocating a 10 kB block; note the
6 kB wasted because of rounding up.

For example, an allocator in a binary buddy system might have sizes of
16, 32, 64, …, 64 kB. It might start off with a single block of 64 kB.
If the application requests a block of 8 kB, the allocator would check
its 8 kB free list and find no free blocks of that size.  It would then
split the 64 kB block into two block of 32 kB, split one of them into
two blocks of 16 kB, and split one of them into two blocks of 8 kB. The
allocator would then return one of the 8 kB blocks to the application
and keep the remaining three blocks of 8 kB, 16 kB, and 32 kB on the
appropriate free lists.  If the application then requested a block of
10 kB, the allocator would round this request up to 16 kB, and return
the 16 kB block from its free list, wasting 6 kB in the process.

A Fibonacci buddy system might use block sizes 16, 32, 48, 80, 128, 208,
… bytes, such that each size is the sum of the two preceding sizes.
When splitting a block from one free list, the two parts get added to
the two preceding free lists.

A buddy system can work very well or very badly, depending on how the
chosen sizes interact with typical requests for memory and what the
pattern of returned blocks is.  The rounding typically leads to a
significant amount of wasted memory, which is called *note internal
fragmentation: 379.  This can be reduced by making the permitted block
sizes closer together.


File: MemoryPoolSystem.info,  Node: Suballocators,  Prev: Buddy system,  Up: Allocation techniques

13.2.3 Suballocators
--------------------

There are many examples of application programs that include additional
memory management code called a *note suballocator: 16b2.  A
suballocator obtains large blocks of memory from the system memory
manager and allocates the memory to the application in smaller pieces.
Suballocators are usually written for one of the following reasons:

   * To avoid general inefficiency in the system memory manager;

   * To take advantage of special knowledge of the application’s memory
     requirements that cannot be expressed to the system memory manager;

   * To provide memory management services that the system memory
     manager does not supply.

In general, suballocators are less efficient than having a single memory
manager that is well-written and has a flexible interface.  It is also
harder to avoid memory management bugs if the memory manager is composed
of several layers, and if each application has its own variation of
suballocator.

Many applications have one or two sizes of block that form the vast
majority of their allocations.  One of the most common uses of a
suballocator is to supply the application with objects of one size.
This greatly reduces the problem of *note external fragmentation: 383.
Such a suballocator can have a very simple allocation policy.

There are dangers involved in making use of special knowledge of the
application’s memory requirements.  If those requirements change, then
the performance of the suballocator is likely to be much worse than that
of a general allocator.  It is often better to have a memory manager
that can respond dynamically to changing requirements.


File: MemoryPoolSystem.info,  Node: Recycling techniques,  Next: Memory management in various languages,  Prev: Allocation techniques,  Up: Introduction to memory management

13.3 Recycling techniques
=========================

There are many ways for automatic memory managers to determine what
memory is no longer required.  In the main, garbage collection relies on
determining which blocks are not pointed to by any program variables.
Some of the techniques for doing this are described briefly below, but
there are many potential pitfalls, and many possible refinements.  These
techniques can often be used in combination.

* Menu:

* Tracing collectors::
* Reference counts::


File: MemoryPoolSystem.info,  Node: Tracing collectors,  Next: Reference counts,  Up: Recycling techniques

13.3.1 Tracing collectors
-------------------------

Automatic memory managers that follow pointers to determine which blocks
of memory are *note reachable: 96. from program variables (known as the
*note root set: 1716.) are known as 'tracing' collectors.  The classic
example is the mark-sweep collector.

* Menu:

* Mark-sweep collection::
* Copying collection::
* Incremental collection::
* Conservative garbage collection::


File: MemoryPoolSystem.info,  Node: Mark-sweep collection,  Next: Copying collection,  Up: Tracing collectors

13.3.1.1 Mark-sweep collection
..............................

In a *note mark-sweep: 15fd. collection, the collector first examines
the program variables; any blocks of memory pointed to are added to a
list of blocks to be examined.  For each block on that list, it sets a
flag (the mark) on the block to show that it is still required, and also
that it has been processed.  It also adds to the list any blocks pointed
to by that block that have not yet been marked.  In this way, all blocks
that can be reached by the program are marked.

In the second phase, the collector 'sweeps' all allocated memory,
searching for blocks that have not been marked.  If it finds any, it
returns them to the allocator for reuse.

 [image src="MemoryPoolSystem-figures/mark-sweep.svg" alt="Diagram: Five memory blocks, three of which are reachable from program variables." ]


Figure: Five memory blocks, three of which are reachable from program
variables.

In the diagram above, block 1 is directly accessible from a program
variable, and blocks 2 and 3 are indirectly accessible.  Blocks 4 and 5
cannot be reached by the program.  The first step would mark block 1,
and remember blocks 2 and 3 for later processing.  The second step would
mark block 2.  The third step would mark block 3, but wouldn’t remember
block 2 as it is already marked.  The sweep phase would ignore blocks 1,
2, and 3 because they are marked, but would recycle blocks 4 and 5.

The two drawbacks of simple mark-sweep collection are:

   * it must scan the entire memory in use before any memory can be
     freed;

   * it must run to completion or, if interrupted, start again from
     scratch.

If a system requires real-time or interactive response, then simple
mark-sweep collection may be unsuitable as it stands, but many more
sophisticated garbage collection algorithms are derived from this
technique.


File: MemoryPoolSystem.info,  Node: Copying collection,  Next: Incremental collection,  Prev: Mark-sweep collection,  Up: Tracing collectors

13.3.1.2 Copying collection
...........................

After many memory blocks have been allocated and recycled, there are two
problems that typically occur:

   * the memory in use is widely scattered in memory, causing poor
     performance in the *note memory caches: 1622. or *note virtual
     memory: 51. systems of most modern computers (known as poor *note
     locality of reference: 1601.);

   * it becomes difficult to allocate large blocks because free memory
     is divided into small pieces, separated by blocks in use (known as
     *note external fragmentation: 383.).

One technique that can solve both these problems is *note copying
garbage collection: e3.  A copying garbage collector may move allocated
blocks around in memory and adjust any references to them to point to
the new location.  This is a very powerful technique and can be combined
with many other types of garbage collection, such as mark-sweep
collection.

The disadvantages of copying collection are:

   * it is difficult to combine with *note incremental garbage
     collection: d. (see below) because all references must be adjusted
     to remain consistent;

   * it is difficult to combine with *note conservative garbage
     collection: 349. (see below) because references cannot be
     confidently adjusted;

   * extra storage is required while both new and old copies of an
     object exist;

   * copying data takes extra time (proportional to the amount of *note
     live: 78. data).


File: MemoryPoolSystem.info,  Node: Incremental collection,  Next: Conservative garbage collection,  Prev: Copying collection,  Up: Tracing collectors

13.3.1.3 Incremental collection
...............................

Older garbage collection algorithms relied on being able to start
collection and continue working until the collection was complete,
without interruption.  This makes many interactive systems pause during
collection, and makes the presence of garbage collection obtrusive.

Fortunately, there are modern techniques (known as *note incremental
garbage collection: d.) to allow garbage collection to be performed in a
series of small steps while the program is never stopped for long.  In
this context, the program that uses and modifies the blocks is sometimes
known as the *note mutator: 30c.  While the collector is trying to
determine which blocks of memory are reachable by the mutator, the
mutator is busily allocating new blocks, modifying old blocks, and
changing the set of blocks it is actually looking at.

Incremental collection is usually achieved with either the cooperation
of the memory hardware or the mutator; this ensures that, whenever
memory in crucial locations is accessed, a small amount of necessary
bookkeeping is performed to keep the collector’s data structures
correct.


File: MemoryPoolSystem.info,  Node: Conservative garbage collection,  Prev: Incremental collection,  Up: Tracing collectors

13.3.1.4 Conservative garbage collection
........................................

Although garbage collection was first invented in 1958, many languages
have been designed and implemented without the possibility of garbage
collection in mind.  It is usually difficult to add normal garbage
collection to such a system, but there is a technique, known as *note
conservative garbage collection: 349, that can be used.

The usual problem with such a language is that it doesn’t provide the
collector with information about the data types, and the collector
cannot therefore determine what is a pointer and what isn’t.  A
conservative collector assumes that anything 'might' be a pointer.  It
regards any data value that looks like a pointer to or into a block of
allocated memory as preventing the recycling of that block.

Note that, because the collector does not know for certain which memory
locations contain pointers, it cannot readily be combined with copying
garbage collection.  Copying collection needs to know where pointers are
in order to update them when blocks are moved.

You might think that conservative garbage collection could easily
perform quite poorly, leaving a lot of garbage uncollected.  In
practice, it does quite well, and there are refinements that improve
matters further.


File: MemoryPoolSystem.info,  Node: Reference counts,  Prev: Tracing collectors,  Up: Recycling techniques

13.3.2 Reference counts
-----------------------

A reference count is a count of how many *note references: 24. (that is,
pointers) there are to a particular memory block from other blocks.  It
is used as the basis for some automatic recycling techniques that do not
rely on tracing.

* Menu:

* Simple reference counting::
* Deferred reference counting::
* One-bit reference counting::
* Weighted reference counting::


File: MemoryPoolSystem.info,  Node: Simple reference counting,  Next: Deferred reference counting,  Up: Reference counts

13.3.2.1 Simple reference counting
..................................

In a simple *note reference counting: 15e0. system, a reference count is
kept for each *note object: 1ab.  This count is incremented for each new
reference, and is decremented if a reference is overwritten, or if the
referring object is recycled.  If a reference count falls to zero, then
the object is no longer required and can be recycled.

Reference counting is frequently chosen as an automatic memory
management strategy because it seems simple to implement using *note
manual memory management: 8. primitives.  However, it is hard to
implement efficiently because of the cost of updating the counts.  It is
also hard to implement reliably, because the standard technique cannot
reclaim objects connected in a loop.  In many cases, it is an
inappropriate solution, and it would be preferable to use *note tracing
garbage collection: 15df. instead.

Reference counting is most useful in situations where it can be
guaranteed that there will be no loops and where modifications to the
reference structure are comparatively infrequent.  These circumstances
can occur in some types of database structure and some file systems.
Reference counting may also be useful if it is important that objects
are recycled promptly, such as in systems with tight memory constraints.

